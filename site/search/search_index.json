{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Krupy - Simplifying project template management in Python","text":"<p>Purpose :   Krupy stands as a robust Python library and CLI application crafted to simplify the generation and administration of project templates. Whether you're a template creator seeking to eliminate code redundancy or a user eager to kickstart new projects seamlessly, Krupy provides a versatile solution.</p> <p>A library and CLI app for rendering project templates.</p> <ul> <li>Works with local paths and Git URLs.</li> <li>Your project can include any file and Krupy can dynamically replace values in any kind of text file.</li> <li>It generates a beautiful output and takes care of not overwriting existing files unless instructed to do so.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<ol> <li>Install Python 3.8 or newer.</li> <li>Install Git 2.27 or newer.</li> <li>To use as a CLI app: <code>brew untap Krunal-Kevadiya/tap</code> <code>brew tap Krunal-Kevadiya/tap</code> <code>brew install krupy</code></li> </ol>"},{"location":"#example","title":"Example","text":"<ul> <li>Simple Example -&gt; https://github.com/Krunal-Kevadiya/krupytest.git</li> <li>Run Command -&gt; <code>krupy copy https://github.com/Krunal-Kevadiya/krupytest.git test</code></li> <li>Output  </li> </ul>"},{"location":"#quick-start","title":"Quick start","text":"<p>To create a template:</p> <pre><code>\ud83d\udcc1 my_krupy_template                        # your template project\n\u251c\u2500\u2500 \ud83d\udcc4 krupy.yml                            # your template configuration\n\u251c\u2500\u2500 \ud83d\udcc1 .git/                                 # your template is a Git repository\n\u251c\u2500\u2500 \ud83d\udcc1 {{project_name}}                      # a folder with a templated name\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 {{module_name}}.py.jinja          # a file with a templated name\n\u2514\u2500\u2500 \ud83d\udcc4 {{_krupy_conf.answers_file}}.jinja   # answers are recorded here\n</code></pre> krupy.yml<pre><code># questions\nproject_name:\n  type: str\n  help: What is your project name?\n\nmodule_name:\n  type: str\n  help: What is your Python module name?\n</code></pre> {{project_name}}/{{module_name}}.py.jinja<pre><code>print(\"Hello from {{module_name}}!\")\n</code></pre> {{_krupy_conf.answers_file}}.jinja<pre><code># Changes here will be overwritten by Krupy\n{{ _krupy_answers|to_nice_yaml -}}\n</code></pre> <p>To generate a project from the template:</p> <ul> <li>On the command-line:</li> </ul> <pre><code>krupy copy path/to/project/template path/to/destination\n</code></pre> <ul> <li>Or in Python code, programmatically:</li> </ul> <pre><code>from krupy import run_copy\n\n# Create a project from a local path\nrun_copy(\"path/to/project/template\", \"path/to/destination\")\n\n# Or from a Git URL.\nrun_copy(\"https://github.com/Krunal-Kevadiya/krupy.git\", \"path/to/destination\")\n\n# You can also use \"gh:\" as a shortcut of \"https://github.com/\"\nrun_copy(\"gh:Krunal-Kevadiya/krupy.git\", \"path/to/destination\")\n\n# Or \"gl:\" as a shortcut of \"https://gitlab.com/\"\nrun_copy(\"gl:Krunal-Kevadiya/krupy.git\", \"path/to/destination\")\n</code></pre>"},{"location":"#basic-concepts","title":"Basic concepts","text":"<p>Krupy is composed of these main concepts:</p> <ol> <li>Templates. They lay out how to generate the subproject.</li> <li>Questionaries. They are configured in the template. Answers are used to generate projects.</li> <li>Projects. This is where your real program lives. But it is usually generated and/or updated from a template.</li> </ol> <p>Krupy targets these main human audiences:</p> <ol> <li> <p>Template creators. Programmers that repeat code too much and prefer a tool to do it for them.</p> <p>Tip</p> <p>Krupy doesn't replace the DRY principle... but sometimes you simply can't be  DRY and you need a DRYing machine...</p> </li> <li> <p>Template consumers. Programmers that want to start a new project quickly, or that want to evolve it comfortably.</p> </li> </ol> <p>Non-humans should also be happy by using Krupy's CLI or API, as long as their expectations are the same as those of humans and as long as they have feelings.</p> <p>Templates have these goals:</p> <ol> <li>Code scaffolding. Help    consumers have a working source code tree as quickly as possible. All templates allow scaffolding.</li> <li>Code lifecycle management. When the template evolves, let consumers update their projects. Not all templates allow updating.</li> </ol> <p>Krupy tries to have a smooth learning curve that lets you create simple templates that can evolve into complex ones as needed.</p>"},{"location":"#browse-or-tag-public-templates","title":"Browse or tag public templates","text":"<p>You can browse public Krupy templates on GitHub using the krupy-template topic. Use them as inspiration!</p> <p>If you want your template to appear in that list, just add the topic to it! \ud83c\udff7</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. This project adheres to PEP 440 versioning schema, and the changelog itself conforms to Keep A Changelog.</p>"},{"location":"changelog/#200-2023-11-25","title":"[2.0.0] - 2023-11-25","text":"<ul> <li>Initial version release.</li> </ul>"},{"location":"comparisons/","title":"Comparing Krupy to other project generators","text":"<p>The subject of code scaffolding has been around for some time, and there are long established good projects.</p> <p>Here's a simple comparison. If you find something wrong, please open a PR and fix these docs! We don't want to be biased, but it's easy that we tend to be:</p> <p>Important</p> <p>Although Krupy was born as a code scaffolding tool, it is today a code lifecycle management tool. This makes it somehow unique. Most tools below are only scaffolders and the comparison is not complete due to that.</p> Feature Krupy Cookiecutter Yeoman Can template file names Yes Yes Yes Configuration Single YAML file<sup>1</sup> Single JSON file JS module Migrations Yes No No Programmed in Python Python NodeJS Requires handwriting JSON No Yes Yes Requires installing templates separately No No Yes Requires programming No No Yes, JS Requires templates to have a suffix Yes by default, configurable<sup>3</sup> No, not configurable You choose Task hooks Yes Yes Yes Context hooks Yes<sup>5</sup> Yes ? Template in a subfolder Not required, but you choose Yes, required Yes, required Template package format Git repo<sup>2</sup>, Git bundle, folder Git or Mercurial repo, Zip file NPM package Template updates Yes<sup>4</sup> No<sup>6</sup> No Templating engine Jinja Jinja EJS <ol> <li> <p>The file itself can include other YAML files.\u00a0\u21a9</p> </li> <li> <p>Git repo is recommended to be able to use advanced features such as template tagging and smart updates.\u00a0\u21a9</p> </li> <li> <p>A suffix is required by default. Defaults to <code>.jinja</code>, but can be configured to use a different suffix, or to use none.\u00a0\u21a9</p> </li> <li> <p>Only for Git templates, because Krupy uses Git tags to obtain available versions and extract smart diffs between them.\u00a0\u21a9</p> </li> <li> <p>Context hooks are provided through the ContextHook extension.\u00a0\u21a9</p> </li> <li> <p>Updates are possible through Cruft.\u00a0\u21a9</p> </li> </ol>"},{"location":"configuring/","title":"Configuring a template","text":""},{"location":"configuring/#configuration-sources","title":"Configuration sources","text":"<p>It is important that you understand how Krupy works. It has 2 kinds of configurations:</p> <ol> <li>Settings for Krupy itself. This includes things as minimal Krupy version    required, which subdirectory to render, tasks to run, etc.</li> <li>Answers. This is customized per template. The user answers template questions,    and those answers are stored as variables available for the template at rendering    time.</li> </ol> <p>Krupy reads settings from these sources, in this order of priority:</p> <ol> <li>Command line or API arguments.</li> <li>The krupy.yml file. Settings here always start with an    underscore (e.g. <code>_min_krupy_version</code>).</li> </ol> <p>Info</p> <p>Some settings are only available as CLI arguments, and some others only as template configurations. Some behave differently depending on where they are defined. Check the docs for each specific setting.</p> <p>Krupy obtains answers from these sources, in this order of priority:</p> <ol> <li>Command line or API arguments.</li> <li>Asking the user. Notice that Krupy will not ask any questions answered in the    previous source.</li> <li>Answer from last execution.</li> <li>Default values defined in the krupy.yml file.</li> </ol>"},{"location":"configuring/#the-krupyyml-file","title":"The krupy.yml file","text":"<p>The <code>krupy.yml</code> (or <code>krupy.yaml</code>) file is found in the root of the template, and it is the main entrypoint for managing your template configuration. It will be read and used for two purposes:</p> <ul> <li>Prompting the user for information.</li> <li>Applying template settings (excluding files, setting arguments     defaults, etc.).</li> </ul>"},{"location":"configuring/#questions","title":"Questions","text":"<p>For each key found, Krupy will prompt the user to fill or confirm the values before they become available to the project template.</p> <p>Example</p> <p>This <code>krupy.yml</code> file:</p> <pre><code>name_of_the_project: My awesome project\nnumber_of_eels: 1234\nyour_email: \"\"\n</code></pre> <p>Will result in a questionary similar to:</p> <p><pre>\n\ud83c\udfa4 name_of_the_project\n  My awesome project\n\ud83c\udfa4 number_of_eels (int)\n  1234\n\ud83c\udfa4 your_email\n</pre></p>"},{"location":"configuring/#advanced-prompt-formatting","title":"Advanced prompt formatting","text":"<p>Apart from the simplified format, as seen above, Krupy supports a more advanced format to ask users for data. To use it, the value must be a dict.</p> <p>Supported keys:</p> <ul> <li>type: User input must match this type. Options are: <code>bool</code>, <code>float</code>, <code>int</code>,     <code>json</code>, <code>str</code>, <code>yaml</code> (default).</li> <li>help: Additional text to help the user know what's this question for.</li> <li> <p>choices: To restrict possible values.</p> <p>Tip</p> <p>A choice value of <code>null</code> makes it become the same as its key.</p> <p>Validation and conditional choices</p> <p>A choice can be validated by using the extended syntax with dict-style and tuple-style choices. For example:</p> krupy.yml<pre><code>cloud:\n    type: str\n    help: Which cloud provider do you use?\n    choices:\n        - Any\n        - AWS\n        - Azure\n        - GCP\n\niac:\n    type: str\n    help: Which IaC tool do you use?\n    choices:\n        Terraform: tf\n        Cloud Formation:\n            value: cf\n            validator: \"{% if cloud != 'AWS' %}Requires AWS{% endif %}\"\n        Azure Resource Manager:\n            value: arm\n            validator: \"{% if cloud != 'Azure' %}Requires Azure{% endif %}\"\n        Deployment Manager:\n            value: dm\n            validator: \"{% if cloud != 'GCP' %}Requires GCP{% endif %}\"\n</code></pre> <p>When the rendered validator is a non-empty string, the choice is disabled and the message is shown. Choice validation is useful when the validity of a choice depends on the answer to a previous question.</p> <p>Warning</p> <p>You are able to use different types for each choice value, but it is not recommended because you can get to some weird scenarios.</p> <p>For example, try to understand this \ud83e\udd74</p> krupy.yml<pre><code>pick_one:\n    type: yaml # If you are mixing types, better be explicit\n    choices:\n        Nothing, thanks: \"null\" # Will be YAML-parsed and converted to null\n        Value is key: null # Value will be converted to \"Value is key\"\n        One and a half: 1.5\n        \"Yes\": true\n        Nope: no\n        Some array: \"[yaml, converts, this]\"\n</code></pre> <p>It's better to stick with a simple type and reason about it later in template code:</p> krupy.yml<pre><code>pick_one:\n    type: str\n    choices:\n        Nothing, thanks: \"\"\n        Value is key: null # Becomes \"Value is key\", which is a str\n        One and a half: \"1.5\"\n        \"Yes\": \"true\"\n        Nope: \"no\"\n        Some array: \"[str, keeps, this, as, a, str]\"\n</code></pre> </li> <li> <p>multiselect: When set to <code>true</code>, allows multiple choices. The answer will be a     <code>list[T]</code> instead of a <code>T</code> where <code>T</code> is of type <code>type</code>.</p> </li> <li>default: Leave empty to force the user to answer. Provide a default to save them     from typing it if it's quite common. When using <code>choices</code>, the default must be the     choice value, not its key, and it must match its type. If values are quite     long, you can use     YAML anchors.</li> <li>secret: When <code>true</code>, it hides the prompt displaying asterisks (<code>*****</code>) and     doesn't save the answer in the answers file. When     <code>true</code>, a default value is required.</li> <li> <p>placeholder: To provide a visual example for what would be a good value. It is     only shown while the answer is empty, so maybe it doesn't make much sense to provide     both <code>default</code> and <code>placeholder</code>. It must be a string.</p> <p>Warning</p> <p>Multiline placeholders are not supported currently, due to this upstream bug.</p> </li> <li> <p>multiline: When set to <code>true</code>, it allows multiline input. This is especially     useful when <code>type</code> is <code>json</code> or <code>yaml</code>.</p> </li> <li> <p>validator: Jinja template with which to validate the user input. This template     will be rendered with the combined answers as variables; it should render nothing     if the value is valid, and an error message to show to the user otherwise.</p> </li> <li> <p>when: Condition that, if <code>false</code>, skips the question.</p> <p>If it is a boolean, it is used directly. Setting it to <code>false</code> is useful for creating a computed value.</p> <p>If it is a string, it is converted to boolean using a parser similar to YAML, but only for boolean values. The string can be templated.</p> <p>If a question is skipped, its answer is not recorded, but its default value is available in the render context.</p> <p>Example</p> krupy.yaml<pre><code>project_creator:\n    type: str\n\nproject_license:\n    type: str\n    choices:\n        - GPLv3\n        - Public domain\n\ncopyright_holder:\n    type: str\n    default: |-\n        {% if project_license == 'Public domain' -%}\n            {#- Nobody owns public projects -#}\n            nobody\n        {%- else -%}\n            {#- By default, project creator is the owner -#}\n            {{ project_creator }}\n        {%- endif %}\n    # Only ask for copyright if project is not in the public domain\n    when: \"{{ project_license != 'Public domain' }}\"\n</code></pre> <p>Example</p> krupy.yml<pre><code>love_krupy:\n    type: bool # This makes Krupy ask for y/n\n    help: Do you love Krupy?\n    default: yes # Without a default, you force the user to answer\n\nproject_name:\n    type: str # Any value will be treated raw as a string\n    help: An awesome project needs an awesome name. Tell me yours.\n    default: paradox-specifier\n    validator: &gt;-\n        {% if not (project_name | regex_search('^[a-z][a-z0-9\\-]+$')) %}\n        project_name must start with a letter, followed one or more letters, digits or dashes all lowercase.\n        {% endif %}\n\nrocket_launch_password:\n    type: str\n    secret: true # This value will not be logged into .krupy-answers.yml\n    placeholder: my top secret password\n\n# I'll avoid default and help here, but you can use them too\nage:\n    type: int\n    validator: \"{% if age &lt;= 0 %}Must be positive{% endif %}\"\n\nheight:\n    type: float\n\nany_json:\n    help: Tell me anything, but format it as a one-line JSON string\n    type: json\n    multiline: true\n\nany_yaml:\n    help: Tell me anything, but format it as a one-line YAML string\n    type: yaml # This is the default type, also for short syntax questions\n    multiline: true\n\nyour_favorite_book:\n    # User will choose one of these and your template will get the value\n    choices:\n        - The Bible\n        - The Hitchhiker's Guide to the Galaxy\n\nproject_license:\n    # User will see only the dict key and choose one, but you will\n    # get the dict value in your template\n    choices:\n        MIT: &amp;mit_text |\n            Here I can write the full text of the MIT license.\n            This will be a long text, shortened here for example purposes.\n        Apache2: |\n            Full text of Apache2 license.\n    # When using choices, the default value is the value, **not** the key;\n    # that's why I'm using the YAML anchor declared above to avoid retyping the\n    # whole license\n    default: *mit_text\n    # You can still define the type, to make sure answers that come from --data\n    # CLI argument match the type that your template expects\n    type: str\n\nclose_to_work:\n    help: Do you live close to your work?\n    # This format works just like the dict one\n    choices:\n        - [at home, I work at home]\n        - [less than 10km, quite close]\n        - [more than 10km, not so close]\n        - [more than 100km, quite far away]\n</code></pre> </li> </ul>"},{"location":"configuring/#prompt-templating","title":"Prompt templating","text":"<p>Most of those options can be templated using Jinja.</p> <p>Keep in mind that the configuration is loaded as YAML, so the contents must be valid YAML and respect Krupy's structure. That is why we explicitly wrap some strings in double-quotes in the following examples.</p> <p>Answers provided through interactive prompting will not be rendered with Jinja, so you cannot use Jinja templating in your answers.</p> <p>Example</p> krupy.yml<pre><code># default\nusername:\n    type: str\n\norganization:\n    type: str\n\nemail:\n    type: str\n    # Notice that both `username` and `organization` have been already asked\n    default: \"{{ username }}@{{ organization }}.com\"\n\n# help\ncopyright_holder:\n    type: str\n    when: \"{% if organization != 'Public domain' %}true{% endif %}\"\n    help: The person or entity within {{ organization }} that holds copyrights.\n\n# type\ntarget:\n    type: str\n    choices:\n        - humans\n        - machines\n\nuser_config:\n    type: \"{% if target == 'humans' %}yaml{% else %}json{% endif %}\"\n\n# choices\ntitle:\n    type: str\n    help: Your title within {{ organization }}\n\ncontact:\n    choices:\n        Copyright holder: \"{{ copyright_holder }}\"\n        CEO: Alice Bob\n        CTO: Carl Dave\n        \"{{ title }}\": \"{{ username }}\"\n</code></pre> <p>Warning</p> <p>Keep in mind that:</p> <ol> <li>You can only template inside the value...</li> <li>... which must be a string to be templated.</li> <li>Also you won't be able to use variables that aren't yet declared.</li> </ol> krupy.yml<pre><code>your_age:\n    type: int\n\n# Valid\ndouble_it:\n    type: int\n    default: \"{{ your_age * 2}}\"\n\n# Invalid, the templating occurs outside of the parameter value\ndid_you_ask:\n    type: str\n    {% if your_age %}\n    default: \"yes\"\n    {% else %}\n    placeholder: \"nope\"\n    {% endif %}\n\n# Invalid, `a_random_word` wasn't answered yet\nother_random_word:\n    type: str\n    placeholder: \"Something different to {{ a_random_word }}\"\n\n# Invalid, YAML interprets curly braces\na_random_word:\n    type: str\n    default: {{ 'hello' }}\n</code></pre>"},{"location":"configuring/#include-other-yaml-files","title":"Include other YAML files","text":"<p>The <code>krupy.yml</code> file supports multiple documents as well as using the <code>!include</code> tag to include settings and questions from other YAML files. This allows you to split up a larger <code>krupy.yml</code> and enables you to reuse common partial sections from your templates. When multiple documents are used, care has to be taken with questions and settings that are defined in more than one document:</p> <ul> <li>A question with the same name overwrites definitions from an earlier document.</li> <li>Settings given in multiple documents for <code>exclude</code>, <code>skip_if_exists</code>,     <code>jinja_extensions</code> and <code>secret_questions</code> are concatenated.</li> <li>Other settings (such as <code>tasks</code> or <code>migrations</code>) overwrite previous definitions for     these settings.</li> </ul> <p>Hint</p> <p>You can use Git submodules to sanely include shared code into templates.</p> <p>Example</p> <p>This would be a valid <code>krupy.yml</code> file:</p> krupy.yml<pre><code>---\n# Krupy will load all these files\n!include shared-conf/common.*.yml\n\n# These 3 lines split the several YAML documents\n---\n# These two documents include common questions for these kind of projects\n!include common-questions/web-app.yml\n---\n!include common-questions/python-project.yml\n---\n\n# Here you can specify any settings or questions specific for your template\n_skip_if_exists:\n    - .password.txt\ncustom_question: default answer\n</code></pre> <p>that includes questions and settings from:</p> common-questions/python-project.yml<pre><code>version:\n    type: str\n    help: What is the version of your Python project?\n\n# Settings like `_skip_if_exists` are merged\n_skip_if_exists:\n    - \"pyproject.toml\"\n</code></pre>"},{"location":"configuring/#conditional-files-and-directories","title":"Conditional files and directories","text":"<p>You can take advantage of the ability to template file and directory names to make them \"conditional\", i.e. to only generate them based on the answers given by a user.</p> <p>For example, you can ask users if they want to use pre-commit:</p> krupy.yml<pre><code>use_precommit:\n    type: bool\n    default: false\n    help: Do you want to use pre-commit?\n</code></pre> <p>And then, you can generate a <code>.pre-commit-config.yaml</code> file only if they answered \"yes\":</p> <pre><code>\ud83d\udcc1 your_template\n\u251c\u2500\u2500 \ud83d\udcc4 krupy.yml\n\u2514\u2500\u2500 \ud83d\udcc4 {% if use_precommit %}.pre-commit-config.yaml{% endif %}.jinja\n</code></pre> <p>Important</p> <p>Note that the chosen template suffix must appear outside of the Jinja condition, otherwise the whole file won't be considered a template and will be copied as such in generated projects.</p> <p>You can even use the answers of questions with choices:</p> krupy.yml<pre><code>ci:\n    type: str\n    help: What Continuous Integration service do you want to use?\n    choices:\n        GitHub CI: github\n        GitLab CI: gitlab\n    default: github\n</code></pre> <pre><code>\ud83d\udcc1 your_template\n\u251c\u2500\u2500 \ud83d\udcc4 krupy.yml\n\u251c\u2500\u2500 \ud83d\udcc1 {% if ci == 'github' %}.github{% endif %}\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 workflows\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 ci.yml\n\u2514\u2500\u2500 \ud83d\udcc4 {% if ci == 'gitlab' %}.gitlab-ci.yml{% endif %}.jinja\n</code></pre> <p>Important</p> <p>Contrary to files, directories must not end with the template suffix.</p> <p>Warning</p> <p>On Windows, double-quotes are not valid characters in file and directory paths. This is why we used single-quotes in the example above.</p>"},{"location":"configuring/#generating-a-directory-structure","title":"Generating a directory structure","text":"<p>You can use answers to generate file names as well as whole directory structures.</p> krupy.yml<pre><code>package:\n    type: str\n    help: Package name\n</code></pre> <pre><code>\ud83d\udcc1 your_template\n\u251c\u2500\u2500 \ud83d\udcc4 krupy.yml\n\u2514\u2500\u2500 \ud83d\udcc4 {{ package.replace('.', _krupy_conf.sep) }}{{ _krupy_conf.sep }}__main__.py.jinja\n</code></pre> <p>If you answer</p> <p>your_package.cli.main</p> <p>Krupy will generate this structure:</p> <pre><code>\ud83d\udcc1 your_project\n\u2514\u2500\u2500 \ud83d\udcc1 your_package\n    \u2514\u2500\u2500 \ud83d\udcc1 cli\n        \u2514\u2500\u2500 \ud83d\udcc1 main\n            \u2514\u2500\u2500 \ud83d\udcc4 __main__.py\n</code></pre> <p>You can either use any separator, like <code>.</code>, and replace it with <code>_krupy_conf.sep</code>, like in the example above, or just use <code>/</code> in the answer (works on Windows too).</p>"},{"location":"configuring/#importing-jinja-templates-and-macros","title":"Importing Jinja templates and macros","text":"<p>You can include templates and import macros to reduce code duplication. A common scenario is the derivation of new values from answers, e.g. computing the slug of a human-readable name:</p> krupy.yml<pre><code>_exclude:\n    - name-slug\n\nname:\n    type: str\n    help: A nice human-readable name\n\nslug:\n    type: str\n    help: A slug of the name\n    default: \"{% include 'name-slug.jinja' %}\"\n</code></pre> name-slug.jinja<pre><code>{# For simplicity ... -#}\n{{ name|lower|replace(' ', '-') }}\n</code></pre> <pre><code>\ud83d\udcc1 your_template\n\u251c\u2500\u2500 \ud83d\udcc4 krupy.yml\n\u2514\u2500\u2500 \ud83d\udcc4 name-slug.jinja\n</code></pre> <p>It is also possible to include a template in a templated folder name</p> <pre><code>\ud83d\udcc1 your_template\n\u251c\u2500\u2500 \ud83d\udcc4 krupy.yml\n\u251c\u2500\u2500 \ud83d\udcc4 name-slug.jinja\n\u2514\u2500\u2500 \ud83d\udcc1 {% include 'name-slug.jinja' %}\n    \u2514\u2500\u2500 \ud83d\udcc4 __init__.py\n</code></pre> <p>or in a templated file name</p> <pre><code>\ud83d\udcc1 your_template\n\u251c\u2500\u2500 \ud83d\udcc4 krupy.yml\n\u251c\u2500\u2500 \ud83d\udcc4 name-slug.jinja\n\u2514\u2500\u2500 \ud83d\udcc4 {% include 'name-slug.jinja' %}.py\n</code></pre> <p>or in the templated content of a text file:</p> pyproject.toml.jinja<pre><code>[project]\nname = \"{% include 'name-slug.jinja' %}\"\n# ...\n</code></pre> <p>Similarly, a Jinja macro can be defined</p> slugify.jinja<pre><code>{# For simplicity ... -#}\n{% macro slugify(value) -%}\n{{ value|lower|replace(' ', '-') }}\n{%- endmacro %}\n</code></pre> <p>and imported, e.g. in <code>krupy.yml</code></p> krupy.yml<pre><code>_exclude:\n    - slugify\n\nname:\n    type: str\n    help: A nice human-readable name\n\nslug:\n    type: str\n    help: A slug of the name\n    default: \"{% from 'slugify.jinja' import slugify %}{{ slugify(name) }}\"\n</code></pre> <p>or in a templated folder name, in a templated file name, or in the templated content of a text file.</p> <p>Info</p> <p>Import/Include paths are relative to the template root.</p> <p>As the number of imported templates and macros grows, you may want to place them in a dedicated folder such as <code>includes</code>:</p> <pre><code>\ud83d\udcc1 your_template\n\u251c\u2500\u2500 \ud83d\udcc4 krupy.yml\n\u2514\u2500\u2500 \ud83d\udcc1 includes\n    \u251c\u2500\u2500 \ud83d\udcc4 name-slug.jinja\n    \u251c\u2500\u2500 \ud83d\udcc4 slugify.jinja\n    \u2514\u2500\u2500 \ud83d\udcc4 ...\n</code></pre> <p>Then, make sure to exclude this folder</p> krupy.yml<pre><code>_exclude:\n    - includes\n</code></pre> <p>or use a subdirectory, e.g.:</p> krupy.yml<pre><code>_subdirectory: template\n</code></pre> <p>In addition, Jinja include and import statements will need to use a POSIX path separator (also on Windows) which is not supported in templated folder and file names. For this reason, Krupy provides a function <code>pathjoin(*paths: str, mode: Literal[\"posix\", \"windows\", \"native\"] = \"posix\")</code>:</p> <pre><code>{% include pathjoin('includes', 'name-slug.jinja') %}\n</code></pre> <pre><code>{% from pathjoin('includes', 'slugify.jinja') import slugify %}\n</code></pre>"},{"location":"configuring/#available-settings","title":"Available settings","text":"<p>Template settings alter how the template is rendered. They come from several sources.</p> <p>Remember that the key must be prefixed with an underscore if you use it in the <code>krupy.yml</code> file.</p>"},{"location":"configuring/#answers_file","title":"<code>answers_file</code>","text":"<ul> <li>Format: <code>str</code></li> <li>CLI flags: <code>-a</code>, <code>--answers-file</code></li> <li>Default value: <code>.krupy-answers.yml</code></li> </ul> <p>Path to a file where answers will be recorded by default. The path must be relative to the project root.</p> <p>Tip</p> <p>Remember to add that file to your Git template if you want to support updates.</p> <p>Don't forget to read the docs about the answers file.</p> <p>Example</p> krupy.yml<pre><code>_answers_file: .my-custom-answers.yml\n</code></pre>"},{"location":"configuring/#cleanup_on_error","title":"<code>cleanup_on_error</code>","text":"<ul> <li>Format: <code>bool</code></li> <li>CLI flags: <code>-C</code>, <code>--no-cleanup</code> (used to disable this setting; only available in     <code>krupy copy</code> subcommand)</li> <li>Default value: <code>True</code></li> </ul> <p>When Krupy creates the destination path, if there's any failure when rendering the template (either in the rendering process or when running the tasks), Krupy will delete that folder.</p> <p>Krupy will never delete the folder if it didn't create it. For this reason, when running <code>krupy update</code>, this setting has no effect.</p> <p>Info</p> <p>Not supported in <code>krupy.yml</code>.</p>"},{"location":"configuring/#conflict","title":"<code>conflict</code>","text":"<ul> <li>Format: <code>Literal[\"rej\", \"inline\"]</code></li> <li>CLI flags: <code>-o</code>, <code>--conflict</code> (only available in <code>krupy update</code> subcommand)</li> <li>Default value: <code>inline</code></li> </ul> <p>When updating a project, sometimes Krupy doesn't know what to do with a diff code hunk. This option controls the output format if this happens. Using <code>rej</code>, creates <code>*.rej</code> files that contain the unresolved diffs. The <code>inline</code> option (default) includes the diff code hunk in the file itself, similar to the behavior of <code>git merge</code>.</p> <p>Info</p> <p>Not supported in <code>krupy.yml</code>.</p>"},{"location":"configuring/#context_lines","title":"<code>context_lines</code>","text":"<ul> <li>Format: <code>Int</code></li> <li>CLI flags: <code>-c</code>, <code>--context-lines</code> (only available in <code>krupy update</code> subcommand)</li> <li>Default value: <code>1</code></li> </ul> <p>During a project update, Krupy needs to compare the template evolution with the subproject evolution. This way, it can detect what changed, where and how to merge those changes. Refer here for more details on this process.</p> <p>The more lines you use, the more accurate Krupy will be when detecting conflicts. But you will also have more conflicts to solve by yourself. FWIW, Git uses 3 lines by default.</p> <p>The less lines you use, the less conflicts you will have. However, Krupy will not be so accurate and could even move lines around if the file it's comparing has several similar code chunks.</p> <p>Info</p> <p>Not supported in <code>krupy.yml</code>.</p>"},{"location":"configuring/#data","title":"<code>data</code>","text":"<ul> <li>Format: <code>dict|List[str=str]</code></li> <li>CLI flags: <code>-d</code>, <code>--data</code></li> <li>Default value: N/A</li> </ul> <p>Give answers to questions through CLI/API.</p> <p>This cannot be defined in <code>krupy.yml</code>, where its equivalent would be just normal questions with default answers.</p> <p>Example</p> <p>Example CLI usage to take all default answers from template, except the user name, which is overridden, and don't ask user anything else:</p> <pre><code>krupy copy -fd 'user_name=Manuel Calavera' template destination\n</code></pre>"},{"location":"configuring/#data_file","title":"<code>data_file</code>","text":"<ul> <li>Format: <code>str</code></li> <li>CLI flags: <code>--data-file</code></li> <li>Default value: N/A</li> </ul> <p>As an alternative to <code>-d, --data</code> you can also pass the path to a YAML file that contains your data.</p> <p>Info</p> <p>Not supported in <code>krupy.yml</code> or API calls. Only supported through the CLI.</p> <p>Example</p> <p>Example CLI usage with a YAML file containing data:</p> input.yml<pre><code>user_name: Manuel Calavera\nage: 7\nheight: 1.83\n</code></pre> <p>Passing a data file</p> <pre><code>krupy copy --data-file input.yml template destination\n</code></pre> <p>is equivalent to passing its content as key-value pairs:</p> <pre><code>krupy copy -d 'user_name=Manuel Calavera' -d 'age=7' -d 'height=1.83' template destination\n</code></pre> <p>If you'd like to override some of the answers in the file, <code>--data</code> flags always take precedence:</p> <pre><code>krupy copy -d 'user_name=Bilbo Baggins' --data-file input.yml template destination\n</code></pre> <p>Info</p> <p>Command line arguments passed via <code>--data</code> always take precedence over the data file.</p>"},{"location":"configuring/#envops","title":"<code>envops</code>","text":"<ul> <li>Format: <code>dict</code></li> <li>CLI flags: N/A</li> <li>Default value: <code>{\"keep_trailing_newline\": true}</code></li> </ul> <p>Configurations for the Jinja environment. Krupy uses the Jinja defaults whenever possible. The only exception at the moment is that Krupy keeps trailing newlines at the end of a template file. If you want to remove those, either remove them from the template or set <code>keep_trailing_newline</code> to <code>false</code>.</p> <p>See upstream docs to know available options.</p> <p>Warning</p> <p>Krupy and older had different, bracket-based defaults.</p> <p>If your template was created for Krupy, you need to add this configuration to your <code>krupy.yaml</code> to keep it working just like before:</p> <pre><code>_envops:\n    autoescape: false\n    block_end_string: \"%]\"\n    block_start_string: \"[%\"\n    comment_end_string: \"#]\"\n    comment_start_string: \"[#\"\n    keep_trailing_newline: true\n    variable_end_string: \"]]\"\n    variable_start_string: \"[[\"\n</code></pre> <p>By specifying this, your template will be compatible with Krupy.</p> <p>Krupy will apply these older defaults if your min_krupy_version is lower than 0.</p> <p>Krupy no longer uses the old defaults independent of min_krupy_version.</p>"},{"location":"configuring/#exclude","title":"<code>exclude</code>","text":"<ul> <li>Format: <code>List[str]</code></li> <li>CLI flags: <code>-x</code>, <code>--exclude</code></li> <li>Default value:     <code>[\"krupy.yaml\", \"krupy.yml\", \"~*\", \"*.py[co]\", \"__pycache__\", \".git\", \".DS_Store\", \".svn\"]</code></li> </ul> <p>Patterns for files/folders that must not be copied.</p> <p>The CLI option can be passed several times to add several patterns.</p> <p>Info</p> <p>When you define this parameter in <code>krupy.yml</code>, it will replace the default value.</p> <p>In this example, for instance, <code>\"krupy.yml\"</code> will not be excluded:</p> <p>Example</p> <pre><code>_exclude:\n    - \"*.bar\"\n    - \".git\"\n</code></pre> <p>Info</p> <p>When the subdirectory parameter is defined and its value is the path of an actual subdirectory (i.e. not <code>\"\"</code> or <code>\".\"</code> or <code>\"./\"</code>), then the default value of the <code>exclude</code> parameter is <code>[]</code>.</p> <p>Info</p> <p>When you add this parameter from CLI or API, it will not replace the values defined in <code>krupy.yml</code> (or the defaults, if missing).</p> <p>Instead, CLI/API definitions will extend those from <code>krupy.yml</code>.</p> <p>Example CLI usage to copy only a single file from the template</p> <pre><code>krupy copy --exclude '*' --exclude '!file-i-want' ./template ./destination\n</code></pre>"},{"location":"configuring/#force","title":"<code>force</code>","text":"<ul> <li>Format: <code>bool</code></li> <li>CLI flags: <code>-f</code>, <code>--force</code> (N/A in <code>krupy update</code>)</li> <li>Default value: <code>False</code></li> </ul> <p>Overwrite files that already exist, without asking.</p> <p>Also don't ask questions to the user; just use default values obtained from other sources.</p> <p>Info</p> <p>Not supported in <code>krupy.yml</code>.</p>"},{"location":"configuring/#defaults","title":"<code>defaults</code>","text":"<ul> <li>Format: <code>bool</code></li> <li>CLI flags: <code>--defaults</code></li> <li>Default value: <code>False</code></li> </ul> <p>Use default answers to questions.</p> <p>Attention</p> <p>Any question that does not have a default value must be answered via CLI/API. Otherwise, an error is raised.</p> <p>Info</p> <p>Not supported in <code>krupy.yml</code>.</p>"},{"location":"configuring/#overwrite","title":"<code>overwrite</code>","text":"<ul> <li>Format: <code>bool</code></li> <li>CLI flags: <code>--overwrite</code> (N/A in <code>krupy update</code> because it's implicit)</li> <li>Default value: <code>False</code></li> </ul> <p>Overwrite files that already exist, without asking.</p> <p>obtained from other sources.</p> <p>Info</p> <p>Not supported in <code>krupy.yml</code>.</p> <p>Required when updating from API.</p>"},{"location":"configuring/#jinja_extensions","title":"<code>jinja_extensions</code>","text":"<ul> <li>Format: <code>List[str]</code></li> <li>CLI flags: N/A</li> <li>Default value: <code>[]</code></li> </ul> <p>Additional Jinja2 extensions to load in the Jinja2 environment. Extensions can add filters, global variables and functions, or tags to the environment.</p> <p>The following extensions are always loaded:</p> <ul> <li>jinja2_ansible_filters.AnsibleCoreFiltersExtension:     this extension adds most of the     Ansible filters to     the environment.</li> </ul> <p>You don't need to tell your template users to install these extensions: Krupy depends on them, so they are always installed when Krupy is installed.</p> <p>Warning</p> <p>Including an extension allows Krupy to execute uncontrolled code, thus making the template potentially more dangerous. Be careful about what extensions you install.</p> <p>Note to template writers</p> <p>You must inform your users that they need to install the extensions alongside Krupy, i.e. in the same virtualenv where Krupy is installed. For example, if your template uses <code>jinja2_time.TimeExtension</code>, your users must install the <code>jinja2-time</code> Python package.</p> <pre><code># with pip, in the same virtualenv where Krupy is installed\npip install jinja2-time\n\n# if Krupy was installed with pipx\npipx inject krupy jinja2-time\n</code></pre> <p>Example</p> krupy.yml<pre><code>_jinja_extensions:\n    - jinja_markdown.MarkdownExtension\n    - jinja2_slug.SlugExtension\n    - jinja2_time.TimeExtension\n</code></pre> <p>Hint</p> <p>Examples of extensions you can use:</p> <ul> <li> <p>Native Jinja2 extensions:</p> <ul> <li>expression statement,     which can be used to alter the Jinja context (answers, filters, etc.) or execute other operations, without outputting anything.</li> <li>loop controls, which adds the <code>break</code> and <code>continue</code>     keywords for Jinja loops.</li> <li>debug extension, which can dump the current context     thanks to the added <code>{% debug %}</code> tag.</li> </ul> </li> <li> <p>From cookiecutter:</p> <ul> <li>cookiecutter.extensions.JsonifyExtension:     provides a <code>jsonify</code> filter, to format a dictionary as JSON. Note that Krupy     natively provides a <code>to_nice_json</code> filter that can achieve the same thing.</li> <li> <p>cookiecutter.extensions.RandomStringExtension:     provides a <code>random_ascii_string(length, punctuation=False)</code> global function.     Note that Krupy natively provides the <code>ans_random</code> and <code>hash</code> filters that can     be used to achieve the same thing:</p> <p>Example</p> <pre><code>{{ 999999999999999999999999999999999|ans_random|hash('sha512') }}\n</code></pre> </li> <li> <p>cookiecutter.extensions.SlugifyExtension:     provides a <code>slugify</code> filter using     python-slugify.</p> </li> </ul> </li> <li> <p>krupy_templates_extensions.TemplateExtensionLoader:     enhances the extension loading mechanism to allow templates writers to put their     extensions directly in their templates. It also allows to modify the rendering context     (the Jinja variables that you can use in your templates) before     rendering templates, see using a context hook.</p> </li> <li>jinja_markdown.MarkdownExtension:     provides a <code>markdown</code> tag that will render Markdown to HTML using     PyMdown extensions.</li> <li>jinja2_slug.SlugExtension: provides     a <code>slug</code> filter using unicode-slugify.</li> <li>jinja2_time.TimeExtension: adds a     <code>now</code> tag that provides convenient access to the     arrow.now() API.</li> <li>jinja2_jsonschema.JsonSchemaExtension:     adds a <code>jsonschema</code> filter for validating data against a JSON/YAML schema.</li> </ul> <p>Search for more extensions on GitHub using the jinja2-extension topic, or other Jinja2 topics, or on PyPI using the jinja + extension keywords.</p>"},{"location":"configuring/#message_after_copy","title":"<code>message_after_copy</code>","text":"<ul> <li>Format: <code>str</code></li> <li>CLI flags: N/A</li> <li>Default value: <code>\"\"</code></li> </ul> <p>A message to be printed after generating or regenerating a project successfully.</p> <p>If the message contains Jinja code, it will be rendered with the same context as the rest of the template. A Jinja include expression may be used to import a message from a file.</p> <p>The message is suppressed when Krupy is run in quiet mode.</p> <p>Example</p> krupy.yml<pre><code>project_name:\n    type: str\n    help: An awesome project needs an awesome name. Tell me yours.\n\n_message_after_copy: |\n    Your project \"{{ project_name }}\" has been created successfully!\n\n    Next steps:\n\n    1. Change directory to the project root:\n\n       $ cd {{ _krupy_conf.dst_path }}\n\n    2. Read \"CONTRIBUING.md\" and start coding.\n</code></pre>"},{"location":"configuring/#message_after_update","title":"<code>message_after_update</code>","text":"<ul> <li>Format: <code>str</code></li> <li>CLI flags: N/A</li> <li>Default value: <code>\"\"</code></li> </ul> <p>Like message_after_copy but printed after updating a project.</p> <p>Example</p> krupy.yml<pre><code>project_name:\n    type: str\n    help: An awesome project needs an awesome name. Tell me yours.\n\n_message_after_update: |\n    Your project \"{{ project_name }}\" has been updated successfully!\n    In case there are any conflicts, please resolve them. Then,\n    you're done.\n</code></pre>"},{"location":"configuring/#message_before_copy","title":"<code>message_before_copy</code>","text":"<ul> <li>Format: <code>str</code></li> <li>CLI flags: N/A</li> <li>Default value: <code>\"\"</code></li> </ul> <p>Like message_after_copy but printed before generating or regenerating a project.</p> <p>Example</p> krupy.yml<pre><code>project_name:\n    type: str\n    help: An awesome project needs an awesome name. Tell me yours.\n\n_message_before_copy: |\n    Thanks for generating a project using our template.\n\n    You'll be asked a series of questions whose answers will be used to\n    generate a tailored project for you.\n</code></pre>"},{"location":"configuring/#message_before_update","title":"<code>message_before_update</code>","text":"<ul> <li>Format: <code>str</code></li> <li>CLI flags: N/A</li> <li>Default value: <code>\"\"</code></li> </ul> <p>Like message_before_copy but printed before updating a project.</p> <p>Example</p> krupy.yml<pre><code>project_name:\n    type: str\n    help: An awesome project needs an awesome name. Tell me yours.\n\n_message_before_update: |\n    Thanks for updating your project using our template.\n\n    You'll be asked a series of questions whose answers are pre-populated\n    with previously entered values. Feel free to change them as needed.\n</code></pre>"},{"location":"configuring/#migrations","title":"<code>migrations</code>","text":"<ul> <li>Format: <code>List[dict]</code></li> <li>CLI flags: N/A</li> <li>Default value: <code>[]</code></li> </ul> <p>Migrations are like tasks, but each item in the list is a <code>dict</code> with these keys:</p> <ul> <li>version: Indicates the version that the template update has to go through to     trigger this migration. It is evaluated using PEP 440.</li> <li>before (optional): Commands to execute before performing the update. The answers     file is reloaded after running migrations in this stage, to let you migrate answer     values.</li> <li>after (optional): Commands to execute after performing the update.</li> </ul> <p>Migrations will run in the same order as declared here (so you could even run a migration for a higher version before running a migration for a lower version if the higher one is declared before and the update passes through both).</p> <p>They will only run when new version &gt;= declared version &gt; old version. And only when updating (not when copying for the 1st time).</p> <p>If the migrations definition contains Jinja code, it will be rendered with the same context as the rest of the template.</p> <p>Migration processes will receive these environment variables:</p> <ul> <li><code>$STAGE</code>: Either <code>before</code> or <code>after</code>.</li> <li><code>$VERSION_FROM</code>: Git commit description of the template as it was     before updating.</li> <li><code>$VERSION_TO</code>: Git commit description of the template as it will be     after updating.</li> <li><code>$VERSION_CURRENT</code>: The <code>version</code> detector as you indicated it when describing     migration tasks.</li> <li><code>$VERSION_PEP440_FROM</code>, <code>$VERSION_PEP440_TO</code>, <code>$VERSION_PEP440_CURRENT</code>: Same as the     above, but normalized into a standard PEP 440 version string indicator. If your     scripts use these environment variables to perform migrations, you probably will     prefer to use these variables.</li> </ul> <p>Example</p> krupy.yml<pre><code>_migrations:\n    - version: v1.0.0\n      before:\n          - rm ./old-folder\n      after:\n          # {{ _krupy_conf.src_path }} points to the path where the template was\n          # cloned, so it can be helpful to run migration scripts stored there.\n          - invoke -r {{ _krupy_conf.src_path }} -c migrations migrate $VERSION_CURRENT\n</code></pre>"},{"location":"configuring/#min_krupy_version","title":"<code>min_krupy_version</code>","text":"<ul> <li>Format: <code>str</code></li> <li>CLI flags: N/A</li> <li>Default value: N/A</li> </ul> <p>Specifies the minimum required version of Krupy to generate a project from this template. The version must be follow the PEP 440 syntax. Upon generating or updating a project, if the installed version of Krupy is less than the required one, the generation will be aborted and an error will be shown to the user.</p> <p>Info</p> <p>If Krupy detects that there is a major version difference, it will warn you about possible incompatibilities. Remember that a new major release means that some features can be dropped or changed, so it's probably a good idea to ask the template maintainer to update it.</p> <p>Example</p> krupy.yml<pre><code>_min_krupy_version: \"4.1.0\"\n</code></pre>"},{"location":"configuring/#pretend","title":"<code>pretend</code>","text":"<ul> <li>Format: <code>bool</code></li> <li>CLI flags: <code>-n</code>, <code>--pretend</code></li> <li>Default value: <code>False</code></li> </ul> <p>Run but do not make any changes.</p> <p>Info</p> <p>Not supported in <code>krupy.yml</code>.</p>"},{"location":"configuring/#preserve_symlinks","title":"<code>preserve_symlinks</code>","text":"<ul> <li>Format: <code>bool</code></li> <li>CLI flags: N/A</li> <li>Default value: <code>False</code></li> </ul> <p>Keep symlinks as symlinks. If this is set to <code>False</code> symlinks will be replaced with the file they point to.</p> <p>When set to <code>True</code> and the symlink ends with the template suffix (<code>.jinja</code> by default) the target path of the symlink will be rendered as a jinja template.</p>"},{"location":"configuring/#quiet","title":"<code>quiet</code>","text":"<ul> <li>Format: <code>bool</code></li> <li>CLI flags: <code>-q</code>, <code>--quiet</code></li> <li>Default value: <code>False</code></li> </ul> <p>Suppress status output.</p> <p>Info</p> <p>Not supported in <code>krupy.yml</code>.</p>"},{"location":"configuring/#secret_questions","title":"<code>secret_questions</code>","text":"<ul> <li>Format: <code>List[str]</code></li> <li>CLI flags: N/A</li> <li>Default value: <code>[]</code></li> </ul> <p>Question variables to mark as secret questions. This is especially useful when questions are provided in the simplified prompt format. It's equivalent to configuring <code>secret: true</code> in the advanced prompt format.</p> <p>Example</p> krupy.yml<pre><code>_secret_questions:\n    - password\n\nuser: johndoe\npassword: s3cr3t\n</code></pre>"},{"location":"configuring/#skip_if_exists","title":"<code>skip_if_exists</code>","text":"<ul> <li>Format: <code>List[str]</code></li> <li>CLI flags: <code>-s</code>, <code>--skip</code></li> <li>Default value: <code>[]</code></li> </ul> <p>Patterns for files/folders that must be skipped if they already exist.</p> <p>Example</p> <p>For example, it can be used if your project generates a password the 1st time and you don't want to override it next times:</p> krupy.yml<pre><code>_skip_if_exists:\n    - .secret_password.yml\n</code></pre> .secret_password.yml.jinja<pre><code>{{999999999999999999999999999999999|ans_random|hash('sha512')}}\n</code></pre>"},{"location":"configuring/#subdirectory","title":"<code>subdirectory</code>","text":"<ul> <li>Format: <code>str</code></li> <li>CLI flags: N/A</li> <li>Default value: N/A</li> </ul> <p>Subdirectory to use as the template root when generating a project. If not specified, the root of the template is used.</p> <p>This allows you to keep separate the template metadata and the template code.</p> <p>Tip</p> <p>If your template is meant to be applied to other templates (a.k.a. recursive templates), use this option to be able to use updates.</p> <p>Example</p> krupy.yml<pre><code>_subdirectory: template\n</code></pre> <p>Can I have multiple templates in a single repo using this option?</p> <p>The Krupy recommendation is: 1 template = 1 Git repository.</p> <p>Why? Unlike almost all other templating engines, Krupy supports smart project updates. For that, Krupy needs to know in which version it was copied last time, and to which version you are evolving. Krupy gets that information from Git tags. Git tags are shared across the whole Git repository. Using a repository to host multiple templates would lead to many corner case situations that we don't want to support.</p> <p>So, in Krupy, the subdirectory option is just there to let template owners separate templates metadata from template source code. This way, for example, you can have different dotfiles for you template and for the projects it generates.</p> <p>Example project with different <code>.gitignore</code> files</p> <p>Project layout<pre><code>\ud83d\udcc1 my_krupy_template\n\u251c\u2500\u2500 \ud83d\udcc4 krupy.yml       # (1)\n\u251c\u2500\u2500 \ud83d\udcc4 .gitignore       # (2)\n\u2514\u2500\u2500 \ud83d\udcc1 template         # (3)\n    \u2514\u2500\u2500 \ud83d\udcc4 .gitignore   # (4)\n</code></pre> </p> <ol> <li>Same contents as the example above.</li> <li>Ignore instructions for the template repo.</li> <li>The configured template subdirectory.</li> <li>Ignore instructions for projects generated with the template.</li> </ol> <p>However, it is true that the value of this option can itself be templated. This would let you have different templates that all use the same questionary, and the used template would be saved as an answer. It would let the user update safely and change that option in the future.</p> <p>Example</p> <p>With this questions file and this directory structure, the user will be prompted which Python engine to use, and the project will be generated using the subdirectory whose name matches the answer from the user:</p> krupy.yaml<pre><code>_subdirectory: \"{{ python_engine }}\"\npython_engine:\n    type: str\n    choices:\n        - poetry\n        - pipenv\n</code></pre> <p>Project layout<pre><code>\ud83d\udcc1 my_krupy_template\n\u251c\u2500\u2500 \ud83d\udcc4 krupy.yaml # (1)\n\u251c\u2500\u2500 \ud83d\udcc1 poetry\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 {{ _krupy_conf.answers_file }}.jinja # (2)\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 pyproject.toml.jinja\n\u2514\u2500\u2500 \ud83d\udcc1 pipenv\n    \u251c\u2500\u2500 \ud83d\udcc4 {{ _krupy_conf.answers_file }}.jinja\n    \u2514\u2500\u2500 \ud83d\udcc4 Pipfile.jinja\n</code></pre> </p> <ol> <li>The configuration from the previous example snippet.</li> <li>See the answers file docs to understand.</li> </ol>"},{"location":"configuring/#tasks","title":"<code>tasks</code>","text":"<ul> <li>Format: <code>List[str|List[str]]</code></li> <li>CLI flags: N/A</li> <li>Default value: <code>[]</code></li> </ul> <p>Commands to execute after generating or updating a project from your template.</p> <p>They run ordered, and with the <code>$STAGE=task</code> variable in their environment.</p> <p>Example</p> krupy.yml<pre><code>_tasks:\n    # Strings get executed under system's default shell\n    - \"git init\"\n    - \"rm {{ name_of_the_project }}/README.md\"\n    # Arrays are executed without shell, saving you the work of escaping arguments\n    - [invoke, \"--search-root={{ _krupy_conf.src_path }}\", after-copy]\n    # You are able to output the full conf to JSON, to be parsed by your script\n    - [invoke, end-process, \"--full-conf={{ _krupy_conf|to_json }}\"]\n    # Your script can be run by the same Python environment used to run Krupy\n    - [\"{{ _krupy_python }}\", task.py]\n    # OS-specific task (supported values are \"linux\", \"macos\", \"windows\" and `None`)\n    - &gt;-\n      {% if _krupy_conf.os in ['linux', 'macos'] %}\n      rm {{ name_of_the_project }}/README.md\n      {% elif _krupy_conf.os == 'windows' %}\n      Remove-Item {{ name_of_the_project }}/README.md\n      {% endif %}\n</code></pre> <p>Note: the example assumes you use Invoke as your task manager. But it's just an example. The point is that we're showing how to build and call commands.</p>"},{"location":"configuring/#templates_suffix","title":"<code>templates_suffix</code>","text":"<ul> <li>Format: <code>str</code></li> <li>CLI flags: N/A</li> <li>Default value: <code>.jinja</code></li> </ul> <p>Suffix that instructs which files are to be processed by Jinja as templates.</p> <p>Example</p> krupy.yml<pre><code>_templates_suffix: .my-custom-suffix\n</code></pre> <p>An empty suffix is also valid, and will instruct Krupy to copy and render every file, except those that are excluded by default. If an error happens while trying to read a file as a template, it will fallback to a simple copy (it will typically happen for binary files like images). At the contrary, if such an error happens and the templates suffix is not empty, Krupy will abort and print an error message.</p> <p>Example</p> krupy.yml<pre><code>_templates_suffix: \"\"\n</code></pre> <p>If there is a file with the template suffix next to another one without it, the one without suffix will be ignored.</p> <p>Example</p> <p><pre><code>\ud83d\udcc1 my_krupy_template\n\u251c\u2500\u2500 \ud83d\udcc4 README.md           # Your template's README, ignored at rendering\n\u251c\u2500\u2500 \ud83d\udcc4 README.md.jinja     # README that will be rendered\n\u2514\u2500\u2500 \ud83d\udcc4 CONTRIBUTING.md     # Used both for the template and the subprojects\n</code></pre> </p> <p>Warning</p> <p>Krupy and older had a different default value: <code>.tmpl</code>. If you wish to keep it, add it to your <code>krupy.yml</code> to keep it future-proof.</p> <p>Krupy will apply that old default if your min_krupy_version is lower than 0.</p> <p>Krupy no longer uses the old default independent of min_krupy_version.</p>"},{"location":"configuring/#unsafe","title":"<code>unsafe</code>","text":"<ul> <li>Format: <code>bool</code></li> <li>CLI flags: <code>--UNSAFE</code>, <code>--trust</code></li> <li>Default value: <code>False</code></li> </ul> <p>Krupy templates can use dangerous features that allow arbitrary code execution:</p> <ul> <li>Jinja extensions</li> <li>Migrations</li> <li>Tasks</li> </ul> <p>Therefore, these features are disabled by default and Krupy will raise an error (and exit from the CLI with code <code>4</code>) when they are found in a template. In this case, please verify that no malicious code gets executed by any of the used features. When you're sufficiently confident or willing to take the risk, set <code>unsafe=True</code> or pass the CLI switch <code>--UNSAFE</code> or <code>--trust</code>.</p> <p>Danger</p> <p>Please be sure you understand the risks when allowing unsafe features!</p> <p>Info</p> <p>Not supported in <code>krupy.yml</code>.</p>"},{"location":"configuring/#use_prereleases","title":"<code>use_prereleases</code>","text":"<ul> <li>Format: <code>bool</code></li> <li>CLI flags: <code>g</code>, <code>--prereleases</code></li> <li>Default value: <code>False</code></li> </ul> <p>Imagine that the template supports updates and contains these 2 Git tags: <code>v1.0.0</code> and <code>v2.0.0a1</code>. Krupy will copy by default <code>v1.0.0</code> unless you add <code>--prereleases</code>.</p> <p>Also, if you run <code>krupy update</code>, Krupy would ignore the <code>v2.0.0a1</code> tag unless this flag is enabled.</p> <p>Warning</p> <p>This behavior is new from Krupy. Before that release, prereleases were never ignored.</p> <p>Info</p> <p>Not supported in <code>krupy.yml</code>.</p>"},{"location":"configuring/#vcs_ref","title":"<code>vcs_ref</code>","text":"<ul> <li>Format: <code>str</code></li> <li>CLI flags: <code>-r</code>, <code>--vcs-ref</code></li> <li>Default value: N/A (use latest release)</li> </ul> <p>When copying or updating from a Git-versioned template, indicate which template version to copy.</p> <p>This is stored automatically in the answers file, like this:</p> <pre><code>_commit: v1.0.0\n</code></pre> <p>Info</p> <p>Not supported in <code>krupy.yml</code>.</p> <p>By default, Krupy will copy from the last release found in template Git tags, sorted as PEP 440.</p>"},{"location":"configuring/#_envquestions","title":"<code>_envquestions</code>","text":"<ul> <li>Format: <code>dict</code></li> <li>CLI flags: N/A</li> <li>Default value: <code>{\"is_visible_count\": false, \"is_visible_mark\": false, \"is_visible_type\": false, \"is_visible_default_value\": false}</code></li> </ul> <p>Configurations for the Krupy environment.</p> <p>Warning</p> <p>Krupy and older had different, bracket-based defaults.</p> <p>If your template was created for Krupy, you need to add this configuration to your <code>krupy.yaml</code> to keep it working just like before:</p> <pre><code>_envquestions:\n    is_visible_count: false,\n    is_visible_mark: false,\n    is_visible_type: false,\n    is_visible_default_value: false,\n    style: { \"qmark\": \"fg:#5F819D\", \"question\": \"fg:#FF9D00\" },\n</code></pre> <p>By specifying this, your template will be compatible with Krupy.</p> <p>Krupy will apply these older defaults if your min_krupy_version is lower than 0.</p> <p>Krupy no longer uses the old defaults independent of min_krupy_version.</p>"},{"location":"configuring/#patterns-syntax","title":"Patterns syntax","text":"<p>Krupy supports matching names against patterns in a gitignore style fashion. This works for the options <code>exclude</code> and <code>skip</code>. This means you can write patterns as you would for any <code>.gitignore</code> file. The full range of the gitignore syntax is supported via pathspec.</p> <p>For example, with the following settings in your <code>krupy.yml</code> file would exclude all files ending with <code>txt</code> from being copied to the destination folder, except the file <code>a.txt</code>.</p> <pre><code>_exclude:\n    # match all text files...\n    - \"*.txt\"\n    # .. but not this one:\n    - \"!a.txt\"\n</code></pre>"},{"location":"configuring/#the-krupy-answersyml-file","title":"The <code>.krupy-answers.yml</code> file","text":"<p>If the destination path exists and a <code>.krupy-answers.yml</code> file is present there, it will be used to load the last user's answers to the questions made in the <code>krupy.yml</code> file.</p> <p>This makes projects easier to update because when the user is asked, the default answers will be the last ones they used.</p> <p>The file must be called exactly <code>{{ _krupy_conf.answers_file }}.jinja</code> (or ended with your chosen suffix) in your template's root folder) to allow applying multiple templates to the same subproject.</p> <p>The default name will be <code>.krupy-answers.yml</code>, but you can define a different default path for this file.</p> <p>The file must have this content:</p> <pre><code># Changes here will be overwritten by Krupy; NEVER EDIT MANUALLY\n{{ _krupy_answers|to_nice_yaml -}}\n</code></pre> <p>Important</p> <p>Did you notice that <code>NEVER EDIT MANUALLY</code> part? It is important.</p> <p>The builtin <code>_krupy_answers</code> variable includes all data needed to smooth future updates of this project. This includes (but is not limited to) all JSON-serializable values declared as user questions in the krupy.yml file.</p> <p>As you can see, you also have the power to customize what will be logged here. Keys that start with an underscore (<code>_</code>) are specific to Krupy. Other keys should match questions in <code>krupy.yml</code>.</p> <p>The path to the answers file must be expressed relative to the project root, because:</p> <ul> <li>Its value must be available at render time.</li> <li>It is used to update projects, and for that a project must be git-tracked. So, the     file must be in the repo anyway.</li> </ul>"},{"location":"configuring/#applying-multiple-templates-to-the-same-subproject","title":"Applying multiple templates to the same subproject","text":"<p>Imagine this scenario:</p> <ol> <li>You use one framework that has a public template to generate a project. It's    available at <code>https://github.com/example-framework/framework-template.git</code>.</li> <li>You have a generic template that you apply to all your projects to use the same    pre-commit configuration (formatters, linters, static type checkers...). You have    published that in <code>https://gitlab.com/my-stuff/pre-commit-template.git</code>.</li> <li>You have a private template that configures your subproject to run in your internal    CI. It's found in <code>git@gitlab.example.com:my-company/ci-template.git</code>.</li> </ol> <p>All 3 templates are completely independent:</p> <ul> <li>Anybody can generate a project for the specific framework, no matter if they want to     use pre-commit or not.</li> <li>You want to share the same pre-commit configurations, no matter if the subproject is     for one or another framework.</li> <li>You want to have a centralized CI configuration for all your company projects, no     matter their pre-commit configuration or the framework they rely on.</li> </ul> <p>Well, don't worry. Krupy has you covered. You just need to use a different answers file for each one. All of them contain a <code>{{ _krupy_conf.answers_file }}.jinja</code> file as specified above. Then you apply all the templates to the same project:</p> <pre><code>mkdir my-project\ncd my-project\ngit init\n# Apply framework template\nkrupy copy -a .krupy-answers.main.yml https://github.com/example-framework/framework-template.git .\ngit add .\ngit commit -m 'Start project based on framework template'\n# Apply pre-commit template\nkrupy copy -a .krupy-answers.pre-commit.yml https://gitlab.com/my-stuff/pre-commit-template.git .\ngit add .\npre-commit run -a  # Just in case \ud83d\ude09\ngit commit -am 'Apply pre-commit template'\n# Apply internal CI template\nkrupy copy -a .krupy-answers.ci.yml git@gitlab.example.com:my-company/ci-template.git .\ngit add .\ngit commit -m 'Apply internal CI template'\n</code></pre> <p>Done!</p> <p>After a while, when templates get new releases, updates are handled separately for each template:</p> <pre><code>krupy update -a .krupy-answers.main.yml\nkrupy update -a .krupy-answers.pre-commit.yml\nkrupy update -a .krupy-answers.ci.yml\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/Krunal-Kevadiya/krupy/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"Feature request\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>The project could always use more documentation, whether as part of the official project docs, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/Krunal-Kevadiya/krupy/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are   welcome. :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up the project for local development.</p> <ol> <li>Fork the Krupy repo on GitHub.</li> <li> <p>Clone your fork locally:</p> <pre><code>git clone git@github.com:my-user/krupy.git\ncd krupy\n</code></pre> </li> <li> <p>Use Direnv to set up a development environment:</p> <pre><code># Let direnv do its magic\ndirenv allow\n</code></pre> <p>Direnv will take some time to load for the 1st time. It will download all development dependencies, including Poetry, and it will use it to create a virtualenv and install Krupy with all its development dependencies too.</p> </li> <li> <p>Create a branch for local development:</p> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass all tests:</p> <pre><code>poe test\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>git add .\ncz commit  # use `git commit` if you prefer, but this helps\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request has code, it should include tests.</li> <li>Check that all checks pass on GitHub CI.</li> <li>If something significant changed, modify docs.</li> </ol>"},{"location":"contributing/#commit-message-guidelines","title":"Commit message guidelines","text":"<p>Follow Conventional Commits standard.</p> <p>We use Commitizen to handle Krupy releases. This tool generates the appropriate tag based on that standard. It also writes our changelog. Changes that are included there are of type <code>fix</code>, <code>feat</code> and <code>refactor</code>; also <code>BREAKING CHANGE:</code> trailers will appear. If your change is not meaningful in the changelog, then please don't use one of those categories.</p> <p>If you're a maintainer and you want to merge a PR that will produce a confusing changelog, then please squash the PR on merge, and change the commit message to make it meaningful. Remember to respect co-autorship when squashing, especially if multiple authors were involved.</p>"},{"location":"contributing/#tips","title":"Tips","text":"<p>To run a subset of tests:</p> <pre><code>poe test tests/the-tests-file.py\n</code></pre>"},{"location":"creating/","title":"Creating a template","text":"<p>A template is a directory: usually the root folder of a Git repository.</p> <p>The content of the files inside the project template is copied to the destination without changes, unless they end with <code>.jinja</code> (or your chosen suffix). In that case, the templating engine will be used to render them.</p> <p>Jinja2 templating is used. Learn more about it by reading Jinja2 documentation.</p> <p>If a YAML file named <code>krupy.yml</code> or <code>krupy.yaml</code> is found in the root of the project, the user will be prompted to fill in or confirm the default values.</p>"},{"location":"creating/#minimal-example","title":"Minimal example","text":"<pre><code>\ud83d\udcc1 my_krupy_template                            # your template project\n\u251c\u2500\u2500 \ud83d\udcc4 krupy.yml                                # your template configuration\n\u251c\u2500\u2500 \ud83d\udcc1 .git/                                     # your template is a Git repository\n\u251c\u2500\u2500 \ud83d\udcc1 {{project_name}}                          # a folder with a templated name\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 {{module_name}}.py.jinja              # a file with a templated name\n\u2514\u2500\u2500 \ud83d\udcc4 {{_krupy_conf.answers_file}}.jinja       # answers are recorded here\n</code></pre> krupy.yml<pre><code># questions\nproject_name:\n    type: str\n    help: What is your project name?\n\nmodule_name:\n    type: str\n    help: What is your Python module name?\n</code></pre> {{project_name}}/{{module_name}}.py.jinja<pre><code>print(\"Hello from {{module_name}}!\")\n</code></pre> {{_krupy_conf.answers_file}}.jinja<pre><code># Changes here will be overwritten by Krupy\n{{ _krupy_answers|to_nice_yaml -}}\n</code></pre> <p>Generating a project from this template with <code>super_project</code> and <code>world</code> as answers for the <code>project_name</code> and <code>module_name</code> questions respectively would create in the following directory and files:</p> <pre><code>\ud83d\udcc1 generated_project\n\u251c\u2500\u2500 \ud83d\udcc1 super_project\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 world.py\n\u2514\u2500\u2500 \ud83d\udcc4 .krupy-answers.yml\n</code></pre> super_project/world.py<pre><code>print(\"Hello from world!\")\n</code></pre> .krupy-answers.yml<pre><code># Changes here will be overwritten by Krupy\n_commit: 0.1.0\n_src_path: gh:your_account/your_template\nproject_name: super_project\nmodule_name: world\n</code></pre> <p>Krupy allows much more advanced templating: see the next chapter, configuring a template, to see all the configurations options and their usage.</p>"},{"location":"creating/#template-helpers","title":"Template helpers","text":"<p>In addition to all the features Jinja supports, Krupy includes:</p> <ul> <li> <p>All functions and filters from     jinja2-ansible-filters.</p> <ul> <li>This includes the <code>to_nice_yaml</code> filter, which is used extensively in our     context.</li> </ul> </li> <li> <p><code>_krupy_answers</code> includes the current answers dict, but slightly modified to make     it suitable to autoupdate your project safely:</p> <ul> <li>It doesn't contain secret answers.</li> <li>It doesn't contain any data that is not easy to render to JSON or YAML.</li> <li>It contains special keys like <code>_commit</code> and <code>_src_path</code>, indicating how the last     template update was done.</li> </ul> </li> <li><code>_krupy_conf</code> includes a representation of the current Krupy      Worker object, also slightly modified:<ul> <li>It only contains JSON-serializable data.</li> <li>You can serialize it with <code>{{ _krupy_conf|to_json }}</code>.</li> <li>\u26a0\ufe0f It contains secret answers inside its <code>.data</code> key.</li> <li>Modifying it doesn't alter the current rendering configuration.</li> <li>It contains the current commit hash from the template in     <code>{{ _krupy_conf.vcs_ref_hash }}</code>.</li> <li>Contains Operating System-specific directory separator under <code>sep</code> key.</li> </ul> </li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#can-krupy-be-applied-over-a-preexisting-project","title":"Can Krupy be applied over a preexisting project?","text":"<p>Yes, of course. Krupy understands this use case out of the box. That's actually what powers features such as updating or the ability of applying multiple templates to the same subproject.</p> <p>Example</p> <pre><code>krupy copy https://github.com/me/my-template.git ./my-preexisting-git-project\n</code></pre>"},{"location":"faq/#how-to-use-krupy-from-docker-or-podman","title":"How to use Krupy from Docker or Podman?","text":"<p>Krupy doesn't provide an image by default. However, it does provide a nix package, so you can use Nix to run Krupy reproducibly from within a container:</p> <pre><code># Change for docker if needed\nengine=podman\n\n# You can pin the version; example: github:Krunal-Kevadiya/krupy/v8.0.0\nkrupy=github:Krunal-Kevadiya/krupy\n\n$engine container run --rm -it docker.io/nixos/nix \\\n    nix --extra-experimental-features 'nix-command flakes' --accept-flake-config \\\n    run $krupy -- --help\n</code></pre> <p>You can even generate a reproducible minimal docker image with just Krupy inside, with:</p> <pre><code>nix bundle --bundler github:NixOS/bundlers#toDockerImage \\\n    github:Krunal-Kevadiya/krupy#packages.x86_64-linux.default\ndocker load &lt; python*krupy*.tar.gz\n</code></pre>"},{"location":"faq/#how-to-create-computed-values","title":"How to create computed values?","text":"<p>Combine <code>default</code> and <code>when: false</code>.</p> <p>Example</p> krupy.yaml<pre><code>copyright_year:\n    type: int\n    default: 2024\n\nnext_year:\n    type: int\n    default: \"{{ copyright_year + 1 }}\" # This computes the value\n    when: false # This makes sure it isn't asked nor stored\n</code></pre> <p>See advanced prompt formatting docs. If you need more power, see below.</p>"},{"location":"faq/#how-can-i-alter-the-context-before-rendering-the-project","title":"How can I alter the context before rendering the project?","text":"<p>Use the <code>ContextHook</code> extension. It lets you modify the context used to render templates, so that you can add, change or remove variables. Since it is a Python extension, you have the full power of Python at your fingertips, at the cost of having to mark the template as unsafe.</p> <p>In order for Krupy to be able to load and use the extension when generating a project, it must be installed alongside Krupy itself. More details in the <code>jinja_extensions</code> docs.</p> <p>You can then configure your Jinja extensions in Krupy's configuration file:</p> krupy.yaml<pre><code>_jinja_extensions:\n    - krupy_templates_extensions.TemplateExtensionLoader\n    - extensions/context.py:ContextUpdater\n</code></pre> <p>Following this example, you are supposed to provide a <code>context.py</code> file in the <code>extensions</code> folder at the root of your template to modify the context. If for example your <code>krupy.yaml</code> contains a multiple-choice variable like this:</p> krupy.yaml<pre><code>flavor:\n    type: str\n    choices:\n        - docker\n        - instances\n        - kubernetes\n        - none\n</code></pre> <p>The <code>context.py</code> file contains your context hook which could look like:</p> extensions/context.py<pre><code>from krupy_templates_extensions import ContextHook\n\n\nclass ContextUpdater(ContextHook):\n    def hook(self, context):\n        flavor = context[\"flavor\"]  # user's answer to the \"flavor\" question\n        return {\n            \"isDocker\": flavor == \"docker\"\n            \"isK8s\": flavor == \"kubernetes\"\n            \"isInstances\": flavor == \"instances\"\n            \"isLite\": flavor == \"none\"\n            \"isNotDocker\": flavor != \"docker\"\n            \"isNotK8s\": flavor != \"kubernetes\"\n            \"isNotInstances\": flavor != \"instances\"\n            \"isNotLite\": flavor != \"none\"\n            \"hasContainers\": flavor in {\"docker\", \"kubernetes\"}\n        }\n</code></pre> <p>Before rendering each templated file/folder, the context will be updated with this new context object that you return from the hook. If you wish to update the context in-place rather than update it, set the <code>update</code> class attribute to false:</p> extensions/context.py<pre><code>from krupy_templates_extensions import ContextHook\n\n\nclass ContextUpdater(ContextHook):\n    update = False\n\n    def hook(self, context):\n        flavor = context[\"flavor\"]  # user's answer to the \"flavor\" question\n\n        context[\"isDocker\"] = flavor == \"docker\"\n        context[\"isK8s\"] = flavor == \"kubernetes\"\n        context[\"isInstances\"] = flavor == \"instances\"\n        context[\"isLite\"] = flavor == \"none\"\n\n        context[\"isNotDocker\"] = flavor != \"docker\"\n        context[\"isNotK8s\"] = flavor != \"kubernetes\"\n        context[\"isNotInstances\"] = flavor != \"instances\"\n        context[\"isNotLite\"] = flavor != \"none\"\n\n        context[\"hasContainers\"] = context[\"isDocker\"] or context[\"isK8s\"]\n\n        # you can now actually remove items from the context\n        del context[\"flavor\"]\n</code></pre> <p>Now you can use these added variables in your Jinja templates, and in files and folders names!</p>"},{"location":"faq/#why-krupy-consumes-a-lot-of-resources","title":"Why Krupy consumes a lot of resources?","text":"<p>If the repository containing the template is a shallow clone, the git process called by Krupy might consume unusually high resources. To avoid that, use a fully-cloned repository.</p>"},{"location":"faq/#while-developing-why-the-template-doesnt-include-dirty-changes","title":"While developing, why the template doesn't include dirty changes?","text":"<p>Krupy follows a specific algorithm to choose what reference to use from the template. It also includes dirty changes in the <code>HEAD</code> ref while developing locally.</p> <p>However, did you make sure you are selecting the <code>HEAD</code> ref for copying?</p> <p>Imagine this is the status of your dirty template in <code>./src</code>:</p> <pre><code>$ git -C ./src status --porcelain=v1\n?? new-file.txt\n\n$ git -C ./src tag\nv1.0.0\nv2.0.0\n</code></pre> <p>Now, if you copy that template into a folder like this:</p> <pre><code>$ krupy copy ./src ./dst\n</code></pre> <p>... you'll notice there's no <code>new-file.txt</code>. Why?</p> <p>Well, Krupy indeed included that into the <code>HEAD</code> ref. However, it still selected <code>v2.0.0</code> as the ref to copy, because that's what Krupy does.</p> <p>However, if you do this:</p> <pre><code>$ krupy copy -r HEAD ./src ./dst\n</code></pre> <p>... then you'll notice <code>new-file.txt</code> does exist. You passed a specific ref to copy, so Krupy skips its autodetection and just goes for the <code>HEAD</code> you already chose.</p>"},{"location":"generating/","title":"Generating a project","text":"<p>Warning</p> <p>Generate projects only from trusted templates as their tasks run with the same level of access as your user.</p> <p>As seen in the quick usage section, you can generate a project from a template using the <code>krupy</code> command-line tool:</p> <pre><code>krupy copy path/to/project/template path/to/destination\n</code></pre> <p>Or within Python code:</p> <pre><code>krupy.run_copy(\"path/to/project/template\", \"path/to/destination\")\n</code></pre> <p>The \"template\" parameter can be a local path, an URL, or a shortcut URL:</p> <ul> <li>GitHub: <code>gh:namespace/project</code></li> <li>GitLab: <code>gl:namespace/project</code></li> </ul> <p>If Krupy doesn't detect your remote URL as a Git repository, make sure it starts with one of <code>git+https://</code>, <code>git+ssh://</code>, <code>git@</code> or <code>git://</code>, or it ends with <code>.git</code>.</p> <p>Use the <code>--data</code> command-line argument or the <code>data</code> parameter of the <code>krupy.run_copy()</code> function to pass whatever extra context you want to be available in the templates. The arguments can be any valid Python value, even a function.</p> <p>Use the <code>--vcs-ref</code> command-line argument to checkout a particular Git ref before generating the project.</p> <p>All the available options are described with the <code>--help-all</code> option.</p>"},{"location":"generating/#templates-versions","title":"Templates versions","text":"<p>By default, Krupy will copy from the last release found in template Git tags, sorted as PEP 440, regardless of whether the template is from a URL or a local clone of a Git repository.</p>"},{"location":"generating/#copying-dirty-changes","title":"Copying dirty changes","text":"<p>If you use a local clone of a template repository that has had any uncommitted modifications made, Krupy will use this modified working copy of the template to aid development of new template features.</p> <p>If you would like to override the version of template being installed, the --vcs-ref argument can be used to specify a branch, tag or other reference to use.</p> <p>For example to use the latest master branch from a public repository:</p> <pre><code>krupy copy --vcs-ref master https://github.com/foo/krupy-template.git ./path/to/destination\n</code></pre> <p>Or to work from the current checked out revision of a local template (including dirty changes):</p> <pre><code>krupy copy --vcs-ref HEAD path/to/project/template path/to/destination\n</code></pre>"},{"location":"generating/#regenerating-a-project","title":"Regenerating a project","text":"<p>When you execute <code>krupy recopy $project</code> again over a preexisting <code>$project</code>, Krupy will just reapply the template on it, keeping answers but ignoring previous history.</p> <p>Warning</p> <p>This is not the recommended approach for updating a project, where you usually want Krupy to respect the project evolution wherever it doesn't conflict with the template evolution.</p>"},{"location":"updating/","title":"Updating a project","text":"<p>Krupy enables the code lifecycle management for generated projects. There are several common use cases for that, including but not limited to</p> <ol> <li> <p>Update the answers to previous questions</p> <p>Questions can be reanswered to fit the latest requirements of the generated projects. This is helpful, especially when the template includes optional tools that fit into different phases of a project. In that case, template consumers are able to activate the optional tools gradually when the project matures.</p> </li> <li> <p>Sync updates from evolved templates</p> <p>The template creators might update the template to add new functionalities or bug fixes. The generated project can get updated if the template consumers want to keep it to the latest version.</p> </li> </ol> <p>The best way to update a project from its template is when all of these conditions are true:</p> <ol> <li>The destination folder includes a valid <code>.krupy-answers.yml</code>    file.</li> <li>The template is versioned with Git (with tags).</li> <li>The destination folder is versioned with Git.</li> </ol> <p>If that's your case, then just enter the destination folder, make sure <code>git status</code> shows it clean, and run:</p> <pre><code>krupy update\n</code></pre> <p>This will read all available Git tags, will compare them using PEP 440, and will check out the latest one before updating. To update to the latest commit, add <code>--vcs-ref=HEAD</code>. You can use any other Git ref you want.</p> <p>When updating, Krupy will do its best to respect your project evolution by using the answers you provided when copied last time. However, sometimes it's impossible for Krupy to know what to do with a diff code hunk. In those cases, krupy handles the conflict in one of two ways, controlled with the <code>--conflict</code> option:</p> <ul> <li><code>--conflict rej</code>: Creates a separate <code>.rej</code> file for each file with conflicts. These     files contain the unresolved diffs.</li> <li><code>--conflict inline</code> (default): Updates the file with conflict markers. This is quite     similar to the conflict markers created when a <code>git merge</code> command encounters a     conflict. For more information, see the \"Checking Out Conflicts\" section of the     <code>git</code> documentation.</li> </ul> <p>If the update results in conflicts, you should review those manually before committing.</p> <p>You probably don't want to lose important changes or to include merge conflicts in your Git history, but if you aren't careful, it's easy to make mistakes.</p> <p>That's why the recommended way to prevent these mistakes is to add a pre-commit (or equivalent) hook that forbids committing conflict files or markers. The recommended hook configuration depends on the <code>conflict</code> setting you use.</p>"},{"location":"updating/#preventing-commit-of-merge-conflicts","title":"Preventing Commit of Merge Conflicts","text":"<p>If you use <code>--conflict rej</code> (the default):</p> .pre-commit-config.yaml<pre><code>repos:\n    - repo: local\n      hooks:\n          # Prevent committing .rej files\n          - id: forbidden-files\n            name: forbidden files\n            entry: found Krupy update rejection files; review them and remove them\n            language: fail\n            files: \"\\\\.rej$\"\n    - repo: https://github.com/pre-commit/pre-commit-hooks\n      rev: v4.3.0\n      hooks:\n          # Prevent committing inline conflict markers\n          - id: check-merge-conflict\n            args: [--assume-in-merge]\n</code></pre>"},{"location":"updating/#never-change-the-answers-file-manually","title":"Never change the answers file manually","text":"<p>Important</p> <p>Never update <code>.krupy-answers.yml</code> manually.</p> <p>This will trick Krupy, making it believe that those modified answers produced the current subproject, while it was produced by a different answers set. This will produce unpredictable behavior of the smart diff algorithm used for updates, which may work under certain circumstances, but not always.</p> <p>This is an unsupported way to update. Please do not open issues if you updated this way.</p> <p>The correct process to update a subproject is:</p> <ol> <li>Run <code>krupy update</code>.</li> <li>Answer the questions. They'll default to your answers on your last update.</li> </ol> <p>If you want to just reuse all previous answers:</p> <pre><code>krupy update --defaults\n</code></pre> <p>If you want to change just one question, and leave all others untouched, and don't want to go through the whole questionary again:</p> <pre><code>krupy update --defaults --data updated_question=\"my new answer\"\n</code></pre>"},{"location":"updating/#how-the-update-works","title":"How the update works","text":"<p>To understand how the updating process works, take a look at this diagram:</p> <pre><code>graph TD\n\n%% nodes ----------------------------------------------------------\ntemplate_repo(\"template repository\")\ntemplate_current(\"/tmp/template&lt;br&gt;(current tag)\")\ntemplate_latest(\"/tmp/template&lt;br&gt;(latest tag)\")\n\nproject_regen(\"/tmp/project&lt;br&gt;(fresh, current version)\")\nproject_current(\"current project\")\nproject_half(\"half migrated&lt;br&gt;project\")\nproject_updated(\"updated project\")\nproject_applied(\"updated project&lt;br&gt;(diff applied)\")\nproject_full(\"fully updated&lt;br&gt;and migrated project\")\n\nupdate[\"update current&lt;br&gt;project in-place&lt;br&gt;(prompting)&lt;br&gt;+ run tasks again\"]\ncompare[\"compare to get diff\"]\napply[\"apply diff\"]\n\ndiff(\"diff\")\n\n%% edges ----------------------------------------------------------\n        template_repo --&gt; |git clone| template_current\n        template_repo --&gt; |git clone| template_latest\n\n     template_current --&gt; |generate and run tasks| project_regen\n      project_current --&gt; compare\n      project_current --&gt; |apply pre-migrations| project_half\n        project_regen --&gt; compare\n         project_half --&gt; update\n      template_latest --&gt; update\n               update --&gt; project_updated\n              compare --&gt; diff\n                 diff --&gt; apply\n      project_updated --&gt; apply\n                apply --&gt; project_applied\n      project_applied --&gt; |apply post-migrations| project_full\n\n%% style ----------------------------------------------------------\nclassDef blackborder stroke:#000;\nclass compare,update,apply blackborder;</code></pre> <p>As you can see here, <code>krupy</code> does several things:</p> <ul> <li>It regenerates a fresh project from the current template version.</li> <li>Then, it compares both version to get the diff from \"fresh project\" to \"current     project\".</li> <li>Now, it applies pre-migrations to your project, and updates the current project with     the latest template changes (asking for confirmation).</li> <li>Finally, it re-applies the previously obtained diff and then runs the     post-migrations.</li> </ul>"},{"location":"updating/#recover-from-a-broken-update","title":"Recover from a broken update","text":"<p>Usually Krupy will replay the last project generation without problems. However, sometimes that process can break. Examples:</p> <ul> <li>When the last update was relying on some external resources that are no longer     available.</li> <li>When the old and new versions of the template depend on different incompatible     versions of the same Jinja extension, but Krupy can only use one.</li> <li>When the old version of the template was built for an older version of Krupy.</li> </ul> <p>Generally, you should keep your templates as pure and simple as possible to avoid those situations. But it can still happen.</p> <p>To overcome this, use the krupy recopy command, which will discard all the smart update algorithm explained above. It will behave just like if you were applying the template for the first time, but it will keep your answers from the last update.</p> <p>Of course, the experience will be less satisfactory. The new template will override any changes found in your local project. But you can use a Git diff tool to overcome that. After doing this, further updates generally keep on working as usual.</p>"},{"location":"reference/krupy/cli/","title":"cli.py","text":"<p>Command line entrypoint. This module declares the Krupy CLI applications.</p> <p>Basically, there are 3 different commands you can run:</p> <ul> <li> <p><code>krupy</code>, the main app, which is a shortcut for the     <code>copy</code> and <code>update</code> subapps.</p> <p>If the destination project is found and has an answers file with enough information, it will become a shortcut for <code>krupy update</code>.</p> <p>Otherwise it will be a shortcut for <code>krupy copy</code>.</p> <p>Example</p> <pre><code># Copy a new project\nkrupy gh:Krunal-Kevadiya/krupytest my-project\n# Update it\ncd my-project\nkrupy\n</code></pre> </li> <li> <p><code>krupy copy</code>, used to bootstrap a new project from     a template.</p> <p>Example</p> <pre><code>krupy copy gh:Krunal-Kevadiya/krupytest my-project\n</code></pre> </li> <li> <p><code>krupy update</code> to update a preexisting     project to a newer version of its template.</p> <p>Example</p> <pre><code>krupy update\n</code></pre> </li> </ul> <p>Below are the docs of each one of those.</p> <p>CLI help generated from <code>krupy --help-all</code>:</p> <pre><code>krupy 0.1.6\n\nCreate a new project from a template.\n\nDocs in https://krupy.readthedocs.io/\n\nWARNING! Use only trusted project templates, as they might execute code with the same level of access as\nyour user.\n\n\nUsage:\n    krupy [SWITCHES] [SUBCOMMAND [SWITCHES]] args...\n\nMeta-switches:\n    -h, --help         Prints this help message and quits\n    --help-all         Prints help messages of all sub-commands and quits\n    -v, --version      Prints the program's version and quits\n\nSub-commands:\n    copy               Copy from a template source to a destination.; see 'krupy copy --help' for more\n                       info\n    recopy             Recopy a subproject from its original template; see 'krupy recopy --help' for more\n                       info\n    update             Update a subproject from its original template; see 'krupy update --help' for more\n                       info\n\nkrupy copy 0.1.6\n\nCopy from a template source to a destination.\n\nUsage:\n    krupy copy [SWITCHES] template_src destination_path\n\nHidden-switches:\n    -h, --help                         Prints this help message and quits\n    --help-all                         Prints help messages of all sub-commands and quits\n    -v, --version                      Prints the program's version and quits\n\nSwitches:\n    -C, --no-cleanup                   On error, do not delete destination if it was created by Krupy.\n    --UNSAFE, --trust                  Allow templates with unsafe features (Jinja extensions,\n                                       migrations, tasks)\n    -a, --answers-file VALUE:str       Update using this path (relative to `destination_path`) to find\n                                       the answers file\n    -d, --data VARIABLE=VALUE:str      Make VARIABLE available as VALUE when rendering the template; may\n                                       be given multiple times\n    --data-file PATH:ExistingFile      Load data from a YAML file\n    -f, --force                        Same as `--defaults --overwrite`.\n    -g, --prereleases                  Use prereleases to compare template VCS tags.\n    -l, --defaults                     Use default answers to questions, which might be null if not\n                                       specified.\n    -n, --pretend                      Run but do not make any changes\n    -q, --quiet                        Suppress status output\n    -r, --vcs-ref VALUE:str            Git reference to checkout in `template_src`. If you do not specify\n                                       it, it will try to checkout the latest git tag, as sorted using\n                                       the PEP 440 algorithm. If you want to checkout always the latest\n                                       version, use `--vcs-ref=HEAD`.\n    -s, --skip VALUE:str               Skip specified files if they exist already; may be given multiple\n                                       times\n    -w, --overwrite                    Overwrite files that already exist, without asking.\n    -x, --exclude VALUE:str            A name or shell-style pattern matching files or folders that must\n                                       not be copied; may be given multiple times\n\n\nkrupy recopy 0.1.6\n\nRecopy a subproject from its original template\n\nThe copy must have a valid answers file which contains info from the last Krupy execution, including the\nsource template (it must be a key called `_src_path`).\n\nThis command will ignore any diff that you have generated since the last `krupy` execution. It will act\nas if it were the 1st time you apply the template to the destination path. However, it will keep the\nanswers.\n\nIf you want a smarter update that respects your project evolution, use `krupy update` instead.\n\nUsage:\n    krupy recopy [SWITCHES] [destination_path=.]\n\nHidden-switches:\n    -h, --help                         Prints this help message and quits\n    --help-all                         Prints help messages of all sub-commands and quits\n    -v, --version                      Prints the program's version and quits\n\nSwitches:\n    -A, --skip-answered                Skip questions that have already been answered\n    --UNSAFE, --trust                  Allow templates with unsafe features (Jinja extensions,\n                                       migrations, tasks)\n    -a, --answers-file VALUE:str       Update using this path (relative to `destination_path`) to find\n                                       the answers file\n    -d, --data VARIABLE=VALUE:str      Make VARIABLE available as VALUE when rendering the template; may\n                                       be given multiple times\n    --data-file PATH:ExistingFile      Load data from a YAML file\n    -f, --force                        Same as `--defaults --overwrite`.\n    -g, --prereleases                  Use prereleases to compare template VCS tags.\n    -l, --defaults                     Use default answers to questions, which might be null if not\n                                       specified.\n    -n, --pretend                      Run but do not make any changes\n    -q, --quiet                        Suppress status output\n    -r, --vcs-ref VALUE:str            Git reference to checkout in `template_src`. If you do not specify\n                                       it, it will try to checkout the latest git tag, as sorted using\n                                       the PEP 440 algorithm. If you want to checkout always the latest\n                                       version, use `--vcs-ref=HEAD`.\n    -s, --skip VALUE:str               Skip specified files if they exist already; may be given multiple\n                                       times\n    -w, --overwrite                    Overwrite files that already exist, without asking.\n    -x, --exclude VALUE:str            A name or shell-style pattern matching files or folders that must\n                                       not be copied; may be given multiple times\n\n\nkrupy update 0.1.6\n\nUpdate a subproject from its original template\n\nThe copy must have a valid answers file which contains info from the last Krupy execution, including the\nsource template (it must be a key called `_src_path`).\n\nIf that file contains also `_commit`, and `destination_path` is a git repository, this command will do\nits best to respect the diff that you have generated since the last `krupy` execution. To avoid that, use\n`krupy recopy` instead.\n\nUsage:\n    krupy update [SWITCHES] [destination_path=.]\n\nHidden-switches:\n    -h, --help                              Prints this help message and quits\n    --help-all                              Prints help messages of all sub-commands and quits\n    -v, --version                           Prints the program's version and quits\n\nSwitches:\n    -A, --skip-answered                     Skip questions that have already been answered\n    --UNSAFE, --trust                       Allow templates with unsafe features (Jinja extensions,\n                                            migrations, tasks)\n    -a, --answers-file VALUE:str            Update using this path (relative to `destination_path`) to\n                                            find the answers file\n    -c, --context-lines VALUE:int           Lines of context to use for detecting conflicts. Increase for\n                                            accuracy, decrease for resilience.; the default is 3\n    -d, --data VARIABLE=VALUE:str           Make VARIABLE available as VALUE when rendering the template;\n                                            may be given multiple times\n    --data-file PATH:ExistingFile           Load data from a YAML file\n    -g, --prereleases                       Use prereleases to compare template VCS tags.\n    -l, -f, --defaults                      Use default answers to questions, which might be null if not\n                                            specified.\n    -n, --pretend                           Run but do not make any changes\n    -o, --conflict VALUE:{rej, inline}      Behavior on conflict: Create .rej files, or add inline\n                                            conflict markers.; the default is inline\n    -q, --quiet                             Suppress status output\n    -r, --vcs-ref VALUE:str                 Git reference to checkout in `template_src`. If you do not\n                                            specify it, it will try to checkout the latest git tag, as\n                                            sorted using the PEP 440 algorithm. If you want to checkout\n                                            always the latest version, use `--vcs-ref=HEAD`.\n    -s, --skip VALUE:str                    Skip specified files if they exist already; may be given\n                                            multiple times\n    -x, --exclude VALUE:str                 A name or shell-style pattern matching files or folders that\n                                            must not be copied; may be given multiple times\n</code></pre>"},{"location":"reference/krupy/cli/#krupy.cli.KrupyApp","title":"<code> KrupyApp            (Application)         </code>","text":"<p>The Krupy CLI application.</p> Source code in <code>krupy/cli.py</code> <pre><code>class KrupyApp(cli.Application):\n    \"\"\"The Krupy CLI application.\"\"\"\n\n    DESCRIPTION = \"Create a new project from a template.\"\n    DESCRIPTION_MORE = (\n        dedent(\n            \"\"\"\\\n            Docs in https://krupy.readthedocs.io/\n\n            \"\"\"\n        )\n        + (\n            colors.yellow\n            | dedent(\n                \"\"\"\\\n                WARNING! Use only trusted project templates, as they might\n                execute code with the same level of access as your user.\\n\n                \"\"\"\n            )\n        )\n    )\n    VERSION = krupy_version()\n    CALL_MAIN_IF_NESTED_COMMAND = False\n</code></pre>"},{"location":"reference/krupy/cli/#krupy.cli.KrupyCopySubApp","title":"<code> KrupyCopySubApp            (_Subcommand)         </code>","text":"<p>The <code>krupy copy</code> subcommand.</p> <p>Use this subcommand to bootstrap a new subproject from a template, or to override a preexisting subproject ignoring its history diff.</p> Source code in <code>krupy/cli.py</code> <pre><code>@KrupyApp.subcommand(\"copy\")\nclass KrupyCopySubApp(_Subcommand):\n    \"\"\"The `krupy copy` subcommand.\n\n    Use this subcommand to bootstrap a new subproject from a template, or to override\n    a preexisting subproject ignoring its history diff.\n    \"\"\"\n\n    DESCRIPTION = \"Copy from a template source to a destination.\"\n\n    cleanup_on_error = cli.Flag(\n        [\"-C\", \"--no-cleanup\"],\n        default=True,\n        help=\"On error, do not delete destination if it was created by Krupy.\",\n    )\n    defaults = cli.Flag(\n        [\"-l\", \"--defaults\"],\n        help=\"Use default answers to questions, which might be null if not specified.\",\n    )\n    force = cli.Flag(\n        [\"-f\", \"--force\"],\n        help=\"Same as `--defaults --overwrite`.\",\n    )\n    overwrite = cli.Flag(\n        [\"-w\", \"--overwrite\"],\n        help=\"Overwrite files that already exist, without asking.\",\n    )\n\n    @handle_exceptions\n    def main(self, template_src: str, destination_path: str) -&gt; int:\n        \"\"\"Call [run_copy][krupy.main.Worker.run_copy].\n\n        Params:\n            template_src:\n                Indicate where to get the template from.\n\n                This can be a git URL or a local path.\n\n            destination_path:\n                Where to generate the new subproject. It must not exist or be empty.\n        \"\"\"\n        with self._worker(\n            template_src,\n            destination_path,\n            cleanup_on_error=self.cleanup_on_error,\n            defaults=self.force or self.defaults,\n            overwrite=self.force or self.overwrite,\n        ) as worker:\n            worker.run_copy()\n        return 0\n</code></pre>"},{"location":"reference/krupy/cli/#krupy.cli.KrupyCopySubApp.main","title":"<code>main(self, template_src, destination_path)</code>","text":"<p>Call run_copy.</p> <p>Parameters:</p> Name Type Description Default <code>template_src</code> <code>str</code> <p>Indicate where to get the template from.</p> <p>This can be a git URL or a local path.</p> required <code>destination_path</code> <code>str</code> <p>Where to generate the new subproject. It must not exist or be empty.</p> required Source code in <code>krupy/cli.py</code> <pre><code>@handle_exceptions\ndef main(self, template_src: str, destination_path: str) -&gt; int:\n    \"\"\"Call [run_copy][krupy.main.Worker.run_copy].\n\n    Params:\n        template_src:\n            Indicate where to get the template from.\n\n            This can be a git URL or a local path.\n\n        destination_path:\n            Where to generate the new subproject. It must not exist or be empty.\n    \"\"\"\n    with self._worker(\n        template_src,\n        destination_path,\n        cleanup_on_error=self.cleanup_on_error,\n        defaults=self.force or self.defaults,\n        overwrite=self.force or self.overwrite,\n    ) as worker:\n        worker.run_copy()\n    return 0\n</code></pre>"},{"location":"reference/krupy/cli/#krupy.cli.KrupyRecopySubApp","title":"<code> KrupyRecopySubApp            (_Subcommand)         </code>","text":"<p>The <code>krupy recopy</code> subcommand.</p> <p>Use this subcommand to update an existing subproject from a template that supports updates, ignoring any subproject evolution since the last Krupy execution.</p> Source code in <code>krupy/cli.py</code> <pre><code>@KrupyApp.subcommand(\"recopy\")\nclass KrupyRecopySubApp(_Subcommand):\n    \"\"\"The `krupy recopy` subcommand.\n\n    Use this subcommand to update an existing subproject from a template that\n    supports updates, ignoring any subproject evolution since the last Krupy\n    execution.\n    \"\"\"\n\n    DESCRIPTION = \"Recopy a subproject from its original template\"\n    DESCRIPTION_MORE = dedent(\n        \"\"\"\\\n        The copy must have a valid answers file which contains info from the\n        last Krupy execution, including the source template (it must be a key\n        called `_src_path`).\n\n        This command will ignore any diff that you have generated since the\n        last `krupy` execution. It will act as if it were the 1st time you\n        apply the template to the destination path. However, it will keep the\n        answers.\n\n        If you want a smarter update that respects your project evolution, use\n        `krupy update` instead.\n        \"\"\"\n    )\n\n    defaults = cli.Flag(\n        [\"-l\", \"--defaults\"],\n        help=\"Use default answers to questions, which might be null if not specified.\",\n    )\n    force = cli.Flag(\n        [\"-f\", \"--force\"],\n        help=\"Same as `--defaults --overwrite`.\",\n    )\n    overwrite = cli.Flag(\n        [\"-w\", \"--overwrite\"],\n        help=\"Overwrite files that already exist, without asking.\",\n    )\n    skip_answered = cli.Flag(\n        [\"-A\", \"--skip-answered\"],\n        default=False,\n        help=\"Skip questions that have already been answered\",\n    )\n\n    @handle_exceptions\n    def main(self, destination_path: cli.ExistingDirectory = \".\") -&gt; int:\n        \"\"\"Call [run_recopy][krupy.main.Worker.run_recopy].\n\n        Parameters:\n            destination_path:\n                Only the destination path is needed to update, because the\n                `src_path` comes from [the answers file][the-krupy-answersyml-file].\n\n                The subproject must exist. If not specified, the currently\n                working directory is used.\n        \"\"\"\n        with self._worker(\n            dst_path=destination_path,\n            defaults=self.force or self.defaults,\n            overwrite=self.force or self.overwrite,\n            skip_answered=self.skip_answered,\n        ) as worker:\n            worker.run_recopy()\n        return 0\n</code></pre>"},{"location":"reference/krupy/cli/#krupy.cli.KrupyRecopySubApp.main","title":"<code>main(self, destination_path='.')</code>","text":"<p>Call run_recopy.</p> <p>Parameters:</p> Name Type Description Default <code>destination_path</code> <code>ExistingDirectory</code> <p>Only the destination path is needed to update, because the <code>src_path</code> comes from the answers file.</p> <p>The subproject must exist. If not specified, the currently working directory is used.</p> <code>'.'</code> Source code in <code>krupy/cli.py</code> <pre><code>@handle_exceptions\ndef main(self, destination_path: cli.ExistingDirectory = \".\") -&gt; int:\n    \"\"\"Call [run_recopy][krupy.main.Worker.run_recopy].\n\n    Parameters:\n        destination_path:\n            Only the destination path is needed to update, because the\n            `src_path` comes from [the answers file][the-krupy-answersyml-file].\n\n            The subproject must exist. If not specified, the currently\n            working directory is used.\n    \"\"\"\n    with self._worker(\n        dst_path=destination_path,\n        defaults=self.force or self.defaults,\n        overwrite=self.force or self.overwrite,\n        skip_answered=self.skip_answered,\n    ) as worker:\n        worker.run_recopy()\n    return 0\n</code></pre>"},{"location":"reference/krupy/cli/#krupy.cli.KrupyUpdateSubApp","title":"<code> KrupyUpdateSubApp            (_Subcommand)         </code>","text":"<p>The <code>krupy update</code> subcommand.</p> <p>Use this subcommand to update an existing subproject from a template that supports updates, respecting that subproject evolution since the last Krupy execution.</p> Source code in <code>krupy/cli.py</code> <pre><code>@KrupyApp.subcommand(\"update\")\nclass KrupyUpdateSubApp(_Subcommand):\n    \"\"\"The `krupy update` subcommand.\n\n    Use this subcommand to update an existing subproject from a template\n    that supports updates, respecting that subproject evolution since the last\n    Krupy execution.\n    \"\"\"\n\n    DESCRIPTION = \"Update a subproject from its original template\"\n    DESCRIPTION_MORE = dedent(\n        \"\"\"\\\n        The copy must have a valid answers file which contains info\n        from the last Krupy execution, including the source template\n        (it must be a key called `_src_path`).\n\n        If that file contains also `_commit`, and `destination_path` is a git\n        repository, this command will do its best to respect the diff that you have\n        generated since the last `krupy` execution. To avoid that, use `krupy recopy`\n        instead.\n        \"\"\"\n    )\n\n    conflict = cli.SwitchAttr(\n        [\"-o\", \"--conflict\"],\n        cli.Set(\"rej\", \"inline\"),\n        default=\"inline\",\n        help=(\n            \"Behavior on conflict: Create .rej files, or add inline conflict markers.\"\n        ),\n    )\n    context_lines = cli.SwitchAttr(\n        [\"-c\", \"--context-lines\"],\n        int,\n        default=3,\n        help=(\n            \"Lines of context to use for detecting conflicts. Increase for \"\n            \"accuracy, decrease for resilience.\"\n        ),\n    )\n    defaults = cli.Flag(\n        [\"-l\", \"-f\", \"--defaults\"],\n        help=\"Use default answers to questions, which might be null if not specified.\",\n    )\n    skip_answered = cli.Flag(\n        [\"-A\", \"--skip-answered\"],\n        default=False,\n        help=\"Skip questions that have already been answered\",\n    )\n\n    @handle_exceptions\n    def main(self, destination_path: cli.ExistingDirectory = \".\") -&gt; int:\n        \"\"\"Call [run_update][krupy.main.Worker.run_update].\n\n        Parameters:\n            destination_path:\n                Only the destination path is needed to update, because the\n                `src_path` comes from [the answers file][the-krupy-answersyml-file].\n\n                The subproject must exist. If not specified, the currently\n                working directory is used.\n        \"\"\"\n        with self._worker(\n            dst_path=destination_path,\n            conflict=self.conflict,\n            context_lines=self.context_lines,\n            defaults=self.defaults,\n            skip_answered=self.skip_answered,\n            overwrite=True,\n        ) as worker:\n            worker.run_update()\n        return 0\n</code></pre>"},{"location":"reference/krupy/cli/#krupy.cli.KrupyUpdateSubApp.main","title":"<code>main(self, destination_path='.')</code>","text":"<p>Call run_update.</p> <p>Parameters:</p> Name Type Description Default <code>destination_path</code> <code>ExistingDirectory</code> <p>Only the destination path is needed to update, because the <code>src_path</code> comes from the answers file.</p> <p>The subproject must exist. If not specified, the currently working directory is used.</p> <code>'.'</code> Source code in <code>krupy/cli.py</code> <pre><code>@handle_exceptions\ndef main(self, destination_path: cli.ExistingDirectory = \".\") -&gt; int:\n    \"\"\"Call [run_update][krupy.main.Worker.run_update].\n\n    Parameters:\n        destination_path:\n            Only the destination path is needed to update, because the\n            `src_path` comes from [the answers file][the-krupy-answersyml-file].\n\n            The subproject must exist. If not specified, the currently\n            working directory is used.\n    \"\"\"\n    with self._worker(\n        dst_path=destination_path,\n        conflict=self.conflict,\n        context_lines=self.context_lines,\n        defaults=self.defaults,\n        skip_answered=self.skip_answered,\n        overwrite=True,\n    ) as worker:\n        worker.run_update()\n    return 0\n</code></pre>"},{"location":"reference/krupy/cli/#krupy.cli.handle_exceptions","title":"<code>handle_exceptions(method, *args, **kwargs)</code>","text":"<p>Handle keyboard interruption while running a method.</p> Source code in <code>krupy/cli.py</code> <pre><code>@decorator\ndef handle_exceptions(method, *args, **kwargs):\n    \"\"\"Handle keyboard interruption while running a method.\"\"\"\n    try:\n        try:\n            return method(*args, **kwargs)\n        except KeyboardInterrupt:\n            raise UserMessageError(\"Execution stopped by user\")\n    except UserMessageError as error:\n        print(colors.red | \"\\n\".join(error.args), file=sys.stderr)\n        return 1\n    except UnsafeTemplateError as error:\n        print(colors.red | \"\\n\".join(error.args), file=sys.stderr)\n        # DOCS https://github.com/Krunal-Kevadiya/krupy/issues/1328#issuecomment-1723214165\n        return 0b100\n</code></pre>"},{"location":"reference/krupy/errors/","title":"errors.py","text":"<p>Custom exceptions used by Krupy.</p>"},{"location":"reference/krupy/errors/#krupy.errors.ConfigFileError","title":"<code> ConfigFileError            (ValueError, KrupyError)         </code>","text":"<p>Parent class defining problems with the config file.</p> Source code in <code>krupy/errors.py</code> <pre><code>class ConfigFileError(ValueError, KrupyError):\n    \"\"\"Parent class defining problems with the config file.\"\"\"\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.DirtyLocalWarning","title":"<code> DirtyLocalWarning            (UserWarning, KrupyWarning)         </code>","text":"<p>Changes and untracked files present in template.</p> Source code in <code>krupy/errors.py</code> <pre><code>class DirtyLocalWarning(UserWarning, KrupyWarning):\n    \"\"\"Changes and untracked files present in template.\"\"\"\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.ExtensionNotFoundError","title":"<code> ExtensionNotFoundError            (UserMessageError)         </code>","text":"<p>Extensions listed in the configuration could not be loaded.</p> Source code in <code>krupy/errors.py</code> <pre><code>class ExtensionNotFoundError(UserMessageError):\n    \"\"\"Extensions listed in the configuration could not be loaded.\"\"\"\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.InvalidConfigFileError","title":"<code> InvalidConfigFileError            (ConfigFileError)         </code>","text":"<p>Indicates that the config file is wrong.</p> Source code in <code>krupy/errors.py</code> <pre><code>class InvalidConfigFileError(ConfigFileError):\n    \"\"\"Indicates that the config file is wrong.\"\"\"\n\n    def __init__(self, conf_path: Path, quiet: bool):\n        msg = str(conf_path)\n        printf_exception(self, \"INVALID CONFIG FILE\", msg=msg, quiet=quiet)\n        super().__init__(msg)\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.InvalidTypeError","title":"<code> InvalidTypeError            (TypeError, KrupyError)         </code>","text":"<p>The question type is not among the supported ones.</p> Source code in <code>krupy/errors.py</code> <pre><code>class InvalidTypeError(TypeError, KrupyError):\n    \"\"\"The question type is not among the supported ones.\"\"\"\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.KrupyAnswersInterrupt","title":"<code> KrupyAnswersInterrupt            (KrupyError, KeyboardInterrupt)         </code>","text":"<p>KrupyAnswersInterrupt is raised during interactive question prompts.</p> <p>It typically follows a KeyboardInterrupt (i.e. ctrl-c) and provides an opportunity for the caller to conduct additional cleanup, such as writing the partially completed answers to a file.</p> <p>Attributes:</p> Name Type Description <code>answers</code> <p>AnswersMap that contains the partially completed answers object.</p> <code>last_question</code> <p>Question representing the last_question that was asked at the time the interrupt was raised.</p> <code>template</code> <p>Template that was being processed for answers.</p> Source code in <code>krupy/errors.py</code> <pre><code>class KrupyAnswersInterrupt(KrupyError, KeyboardInterrupt):\n    \"\"\"KrupyAnswersInterrupt is raised during interactive question prompts.\n\n    It typically follows a KeyboardInterrupt (i.e. ctrl-c) and provides an\n    opportunity for the caller to conduct additional cleanup, such as writing\n    the partially completed answers to a file.\n\n    Attributes:\n        answers:\n            AnswersMap that contains the partially completed answers object.\n\n        last_question:\n            Question representing the last_question that was asked at the time\n            the interrupt was raised.\n\n        template:\n            Template that was being processed for answers.\n\n    \"\"\"\n\n    def __init__(\n        self, answers: \"AnswersMap\", last_question: \"Question\", template: \"Template\"\n    ) -&gt; None:\n        self.answers = answers\n        self.last_question = last_question\n        self.template = template\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.KrupyError","title":"<code> KrupyError            (Exception)         </code>","text":"<p>Base class for all other Krupy errors.</p> Source code in <code>krupy/errors.py</code> <pre><code>class KrupyError(Exception):\n    \"\"\"Base class for all other Krupy errors.\"\"\"\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.KrupyWarning","title":"<code> KrupyWarning            (Warning)         </code>","text":"<p>Base class for all other Krupy warnings.</p> Source code in <code>krupy/errors.py</code> <pre><code>class KrupyWarning(Warning):\n    \"\"\"Base class for all other Krupy warnings.\"\"\"\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.MultipleConfigFilesError","title":"<code> MultipleConfigFilesError            (ConfigFileError)         </code>","text":"<p>Both krupy.yml and krupy.yaml found, and that's an error.</p> Source code in <code>krupy/errors.py</code> <pre><code>class MultipleConfigFilesError(ConfigFileError):\n    \"\"\"Both krupy.yml and krupy.yaml found, and that's an error.\"\"\"\n\n    def __init__(self, conf_paths: \"PathSeq\"):\n        msg = str(conf_paths)\n        printf_exception(self, \"MULTIPLE CONFIG FILES\", msg=msg)\n        super().__init__(msg)\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.OldTemplateWarning","title":"<code> OldTemplateWarning            (UserWarning, KrupyWarning)         </code>","text":"<p>Template was designed for an older Krupy version.</p> Source code in <code>krupy/errors.py</code> <pre><code>class OldTemplateWarning(UserWarning, KrupyWarning):\n    \"\"\"Template was designed for an older Krupy version.\"\"\"\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.PathError","title":"<code> PathError            (KrupyError, ValueError)         </code>","text":"<p>The path is invalid in the given context.</p> Source code in <code>krupy/errors.py</code> <pre><code>class PathError(KrupyError, ValueError):\n    \"\"\"The path is invalid in the given context.\"\"\"\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.PathNotAbsoluteError","title":"<code> PathNotAbsoluteError            (PathError)         </code>","text":"<p>The path is not absolute, but it should be.</p> Source code in <code>krupy/errors.py</code> <pre><code>class PathNotAbsoluteError(PathError):\n    \"\"\"The path is not absolute, but it should be.\"\"\"\n\n    def __init__(self, *, path: Path) -&gt; None:\n        super().__init__(f'\"{path}\" is not an absolute path')\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.PathNotRelativeError","title":"<code> PathNotRelativeError            (PathError)         </code>","text":"<p>The path is not relative, but it should be.</p> Source code in <code>krupy/errors.py</code> <pre><code>class PathNotRelativeError(PathError):\n    \"\"\"The path is not relative, but it should be.\"\"\"\n\n    def __init__(self, *, path: Path) -&gt; None:\n        super().__init__(f'\"{path}\" is not a relative path')\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.ShallowCloneWarning","title":"<code> ShallowCloneWarning            (UserWarning, KrupyWarning)         </code>","text":"<p>The template repository is a shallow clone.</p> Source code in <code>krupy/errors.py</code> <pre><code>class ShallowCloneWarning(UserWarning, KrupyWarning):\n    \"\"\"The template repository is a shallow clone.\"\"\"\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.UnknownKrupyVersionWarning","title":"<code> UnknownKrupyVersionWarning            (UserWarning, KrupyWarning)         </code>","text":"<p>Cannot determine installed Krupy version.</p> Source code in <code>krupy/errors.py</code> <pre><code>class UnknownKrupyVersionWarning(UserWarning, KrupyWarning):\n    \"\"\"Cannot determine installed Krupy version.\"\"\"\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.UnsafeTemplateError","title":"<code> UnsafeTemplateError            (KrupyError)         </code>","text":"<p>Unsafe Krupy template features are used without explicit consent.</p> Source code in <code>krupy/errors.py</code> <pre><code>class UnsafeTemplateError(KrupyError):\n    \"\"\"Unsafe Krupy template features are used without explicit consent.\"\"\"\n\n    def __init__(self, features: Sequence[str]):\n        assert features\n        s = \"s\" if len(features) &gt; 1 else \"\"\n        super().__init__(\n            f\"Template uses potentially unsafe feature{s}: {', '.join(features)}.\\n\"\n            \"If you trust this template, consider adding the `--trust` option when running `krupy copy/update`.\"\n        )\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.UnsupportedVersionError","title":"<code> UnsupportedVersionError            (UserMessageError)         </code>","text":"<p>Krupy version does not support template version.</p> Source code in <code>krupy/errors.py</code> <pre><code>class UnsupportedVersionError(UserMessageError):\n    \"\"\"Krupy version does not support template version.\"\"\"\n</code></pre>"},{"location":"reference/krupy/errors/#krupy.errors.UserMessageError","title":"<code> UserMessageError            (KrupyError)         </code>","text":"<p>Exit the program giving a message to the user.</p> Source code in <code>krupy/errors.py</code> <pre><code>class UserMessageError(KrupyError):\n    \"\"\"Exit the program giving a message to the user.\"\"\"\n</code></pre>"},{"location":"reference/krupy/main/","title":"main.py","text":"<p>Main functions and classes, used to generate or update projects.</p>"},{"location":"reference/krupy/main/#krupy.main.Worker","title":"<code> Worker        </code>  <code>dataclass</code>","text":"<p>Krupy process state manager.</p> <p>This class represents the state of a krupy work, and contains methods to actually produce the desired work.</p> <p>To use it properly, use it as a context manager and fill all dataclass fields.</p> <p>Then, execute one of its main methods, which are prefixed with <code>run_</code>:</p> <ul> <li>run_copy to copy a subproject.</li> <li>run_recopy to recopy a subproject.</li> <li>run_update to update a subproject.</li> </ul> <p>Examples:</p> <pre><code>with Worker(\n    src_path=\"https://github.com/Krunal-Kevadiya/krupytest.git\", \"output\"\n) as worker:\n    worker.run_copy()\n</code></pre> <p>Attributes:</p> Name Type Description <code>src_path</code> <code>Optional[str]</code> <p>String that can be resolved to a template path, be it local or remote.</p> <p>See krupy.vcs.get_repo.</p> <p>If it is <code>None</code>, then it means that you are updating a project, and the original <code>src_path</code> will be obtained from the answers file.</p> <code>dst_path</code> <code>Path</code> <p>Destination path where to render the subproject.</p> <code>answers_file</code> <code>Optional[pathlib.Path]</code> <p>Indicates the path for the answers file.</p> <p>The path must be relative to <code>dst_path</code>.</p> <p>If it is <code>None</code>, the default value will be obtained from krupy.template.Template.answers_relpath.</p> <code>vcs_ref</code> <code>Optional[str]</code> <p>Specify the VCS tag/commit to use in the template.</p> <code>data</code> <code>Dict[str, Any]</code> <p>Answers to the questionary defined in the template.</p> <code>exclude</code> <code>Sequence[str]</code> <p>User-chosen additional file exclusion patterns.</p> <code>use_prereleases</code> <code>bool</code> <p>Consider prereleases when detecting the latest one?</p> <p>See use_prereleases.</p> <p>Useless if specifying a vcs_ref.</p> <code>skip_if_exists</code> <code>Sequence[str]</code> <p>User-chosen additional file skip patterns.</p> <code>cleanup_on_error</code> <code>bool</code> <p>Delete <code>dst_path</code> if there's an error?</p> <p>See cleanup_on_error.</p> <code>defaults</code> <code>bool</code> <p>When <code>True</code>, use default answers to questions, which might be null if not specified.</p> <p>See defaults.</p> <code>user_defaults</code> <code>Dict[str, Any]</code> <p>Specify user defaults that may override a template's defaults during question prompts.</p> <code>overwrite</code> <code>bool</code> <p>When <code>True</code>, Overwrite files that already exist, without asking.</p> <p>See overwrite.</p> <code>pretend</code> <code>bool</code> <p>When <code>True</code>, produce no real rendering.</p> <p>See pretend.</p> <code>quiet</code> <code>bool</code> <p>When <code>True</code>, disable all output.</p> <p>See quiet.</p> <code>conflict</code> <code>Literal['inline', 'rej']</code> <p>One of \"inline\" (default), \"rej\".</p> <code>context_lines</code> <code>int</code> <p>Lines of context to consider when solving conflicts in updates.</p> <p>With more lines, context resolution is more accurate, but it will also produce more conflicts if your subproject has evolved.</p> <p>With less lines, context resolution is less accurate, but it will respect better the evolution of your subproject.</p> <code>unsafe</code> <code>bool</code> <p>When <code>True</code>, allow usage of unsafe templates.</p> <p>See unsafe</p> Source code in <code>krupy/main.py</code> <pre><code>@dataclass(config=ConfigDict(extra=\"forbid\"))\nclass Worker:\n    \"\"\"Krupy process state manager.\n\n    This class represents the state of a krupy work, and contains methods to\n    actually produce the desired work.\n\n    To use it properly, use it as a context manager and fill all dataclass fields.\n\n    Then, execute one of its main methods, which are prefixed with `run_`:\n\n    -   [run_copy][krupy.main.Worker.run_copy] to copy a subproject.\n    -   [run_recopy][krupy.main.Worker.run_recopy] to recopy a subproject.\n    -   [run_update][krupy.main.Worker.run_update] to update a subproject.\n\n    Example:\n        ```python\n        with Worker(\n            src_path=\"https://github.com/Krunal-Kevadiya/krupytest.git\", \"output\"\n        ) as worker:\n            worker.run_copy()\n        ```\n\n    Attributes:\n        src_path:\n            String that can be resolved to a template path, be it local or remote.\n\n            See [krupy.vcs.get_repo][].\n\n            If it is `None`, then it means that you are\n            [updating a project][updating-a-project], and the original\n            `src_path` will be obtained from\n            [the answers file][the-krupy-answersyml-file].\n\n        dst_path:\n            Destination path where to render the subproject.\n\n        answers_file:\n            Indicates the path for [the answers file][the-krupy-answersyml-file].\n\n            The path must be relative to `dst_path`.\n\n            If it is `None`, the default value will be obtained from\n            [krupy.template.Template.answers_relpath][].\n\n        vcs_ref:\n            Specify the VCS tag/commit to use in the template.\n\n        data:\n            Answers to the questionary defined in the template.\n\n        exclude:\n            User-chosen additional [file exclusion patterns][exclude].\n\n        use_prereleases:\n            Consider prereleases when detecting the *latest* one?\n\n            See [use_prereleases][].\n\n            Useless if specifying a [vcs_ref][].\n\n        skip_if_exists:\n            User-chosen additional [file skip patterns][skip_if_exists].\n\n        cleanup_on_error:\n            Delete `dst_path` if there's an error?\n\n            See [cleanup_on_error][].\n\n        defaults:\n            When `True`, use default answers to questions, which might be null if not specified.\n\n            See [defaults][].\n\n        user_defaults:\n            Specify user defaults that may override a template's defaults during question prompts.\n\n        overwrite:\n            When `True`, Overwrite files that already exist, without asking.\n\n            See [overwrite][].\n\n        pretend:\n            When `True`, produce no real rendering.\n\n            See [pretend][].\n\n        quiet:\n            When `True`, disable all output.\n\n            See [quiet][].\n\n        conflict:\n            One of \"inline\" (default), \"rej\".\n\n        context_lines:\n            Lines of context to consider when solving conflicts in updates.\n\n            With more lines, context resolution is more accurate, but it will\n            also produce more conflicts if your subproject has evolved.\n\n            With less lines, context resolution is less accurate, but it will\n            respect better the evolution of your subproject.\n\n        unsafe:\n            When `True`, allow usage of unsafe templates.\n\n            See [unsafe][]\n    \"\"\"\n\n    src_path: Optional[str] = None\n    dst_path: Path = Path(\".\")\n    answers_file: Optional[RelativePath] = None\n    vcs_ref: OptStr = None\n    data: AnyByStrDict = field(default_factory=dict)\n    exclude: StrSeq = ()\n    use_prereleases: bool = False\n    skip_if_exists: StrSeq = ()\n    cleanup_on_error: bool = True\n    defaults: bool = False\n    user_defaults: AnyByStrDict = field(default_factory=dict)\n    overwrite: bool = False\n    pretend: bool = False\n    quiet: bool = False\n    conflict: Literal[\"inline\", \"rej\"] = \"inline\"\n    context_lines: PositiveInt = 3\n    unsafe: bool = False\n    skip_answered: bool = False\n\n    answers: AnswersMap = field(default_factory=AnswersMap, init=False)\n    _cleanup_hooks: List[Callable] = field(default_factory=list, init=False)\n\n    def __enter__(self):\n        \"\"\"Allow using worker as a context manager.\"\"\"\n        return self\n\n    def __exit__(self, type, value, traceback):\n        \"\"\"Clean up garbage files after worker usage ends.\"\"\"\n        if value is not None:\n            # exception was raised from code inside context manager:\n            # try to clean up, ignoring any exception, then re-raise\n            with suppress(Exception):\n                self._cleanup()\n            raise value\n        # otherwise clean up and let any exception bubble up\n        self._cleanup()\n\n    def _cleanup(self):\n        \"\"\"Execute all stored cleanup methods.\"\"\"\n        for method in self._cleanup_hooks:\n            method()\n\n    def _check_unsafe(self, mode: Literal[\"copy\", \"update\"]) -&gt; None:\n        \"\"\"Check whether a template uses unsafe features.\"\"\"\n        if self.unsafe:\n            return\n        features: Set[str] = set()\n        if self.template.jinja_extensions:\n            features.add(\"jinja_extensions\")\n        if self.template.tasks:\n            features.add(\"tasks\")\n        if mode == \"update\" and self.subproject.template:\n            if self.subproject.template.jinja_extensions:\n                features.add(\"jinja_extensions\")\n            if self.subproject.template.tasks:\n                features.add(\"tasks\")\n            for stage in get_args(Literal[\"before\", \"after\"]):\n                if self.template.migration_tasks(stage, self.subproject.template):\n                    features.add(\"migrations\")\n                    break\n        if features:\n            raise UnsafeTemplateError(sorted(features))\n\n    def _print_message(self, message: str) -&gt; None:\n        if message and not self.quiet:\n            print(self._render_string(message), file=sys.stderr)\n\n    def _answers_to_remember(self) -&gt; Mapping:\n        \"\"\"Get only answers that will be remembered in the krupy answers file.\"\"\"\n        # All internal values must appear first\n        answers: AnyByStrDict = {}\n        commit = self.template.commit\n        src = self.template.url\n        for key, value in ((\"_commit\", commit), (\"_src_path\", src)):\n            if value is not None:\n                answers[key] = value\n        # Other data goes next\n        answers.update(\n            (str(k), v)\n            for (k, v) in self.answers.combined.items()\n            if not k.startswith(\"_\")\n            and k not in self.answers.hidden\n            and k not in self.template.secret_questions\n            and k in self.template.questions_data\n            and isinstance(k, JSONSerializable)\n            and isinstance(v, JSONSerializable)\n        )\n        return answers\n\n    def _execute_tasks(self, tasks: Sequence[Task]) -&gt; None:\n        \"\"\"Run the given tasks.\n\n        Arguments:\n            tasks: The list of tasks to run.\n        \"\"\"\n        for i, task in enumerate(tasks):\n            task_cmd = task.cmd\n            if isinstance(task_cmd, str):\n                task_cmd = self._render_string(task_cmd)\n                use_shell = True\n            else:\n                task_cmd = [self._render_string(str(part)) for part in task_cmd]\n                use_shell = False\n            if not self.quiet:\n                print(\n                    colors.info\n                    | f\" &gt; Running task {i + 1} of {len(tasks)}: {task_cmd}\",\n                    file=sys.stderr,\n                )\n            if self.pretend:\n                continue\n            with local.cwd(self.subproject.local_abspath), local.env(**task.extra_env):\n                subprocess.run(task_cmd, shell=use_shell, check=True, env=local.env)\n\n    def _render_context(self) -&gt; Mapping:\n        \"\"\"Produce render context for Jinja.\"\"\"\n        # Backwards compatibility\n        # FIXME Remove it?\n        conf = asdict(self)\n        conf.pop(\"_cleanup_hooks\")\n        conf.update(\n            {\n                \"answers_file\": self.answers_relpath,\n                \"src_path\": self.template.local_abspath,\n                \"vcs_ref_hash\": self.template.commit_hash,\n                \"sep\": os.sep,\n                \"os\": OS,\n            }\n        )\n\n        return dict(\n            DEFAULT_DATA,\n            **self.answers.combined,\n            _krupy_answers=self._answers_to_remember(),\n            _krupy_conf=conf,\n            _folder_name=self.subproject.local_abspath.name,\n            _krupy_python=sys.executable,\n        )\n\n    def _path_matcher(self, patterns: Iterable[str]) -&gt; Callable[[Path], bool]:\n        \"\"\"Produce a function that matches against specified patterns.\"\"\"\n        # TODO Is normalization really needed?\n        normalized_patterns = (normalize(\"NFD\", pattern) for pattern in patterns)\n        spec = PathSpec.from_lines(\"gitwildmatch\", normalized_patterns)\n        return spec.match_file\n\n    def _solve_render_conflict(self, dst_relpath: Path):\n        \"\"\"Properly solve render conflicts.\n\n        It can ask the user if running in interactive mode.\n        \"\"\"\n        assert not dst_relpath.is_absolute()\n        printf(\n            \"conflict\",\n            dst_relpath,\n            style=Style.DANGER,\n            quiet=self.quiet,\n            file_=sys.stderr,\n        )\n        if self.match_skip(dst_relpath):\n            printf(\n                \"skip\",\n                dst_relpath,\n                style=Style.OK,\n                quiet=self.quiet,\n                file_=sys.stderr,\n            )\n            return False\n        if self.overwrite or dst_relpath == self.answers_relpath:\n            printf(\n                \"overwrite\",\n                dst_relpath,\n                style=Style.WARNING,\n                quiet=self.quiet,\n                file_=sys.stderr,\n            )\n            return True\n        return bool(ask(f\" Overwrite {dst_relpath}?\", default=True))\n\n    def _render_allowed(\n        self,\n        dst_relpath: Path,\n        is_dir: bool = False,\n        is_symlink: bool = False,\n        expected_contents: Union[bytes, Path] = b\"\",\n    ) -&gt; bool:\n        \"\"\"Determine if a file or directory can be rendered.\n\n        Args:\n            dst_relpath:\n                Relative path to destination.\n            is_dir:\n                Indicate if the path must be treated as a directory or not.\n            is_symlink:\n                Indicate if the path must be treated as a symlink or not.\n            expected_contents:\n                Used to compare existing file contents with them. Allows to know if\n                rendering is needed.\n        \"\"\"\n        assert not dst_relpath.is_absolute()\n        assert not expected_contents or not is_dir, \"Dirs cannot have expected content\"\n        dst_abspath = Path(self.subproject.local_abspath, dst_relpath)\n        if dst_relpath != Path(\".\") and self.match_exclude(dst_relpath):\n            return False\n        try:\n            previous_content: Union[bytes, Path]\n            if is_symlink:\n                previous_content = readlink(dst_abspath)\n            else:\n                previous_content = dst_abspath.read_bytes()\n        except FileNotFoundError:\n            printf(\n                \"create\",\n                dst_relpath,\n                style=Style.OK,\n                quiet=self.quiet,\n                file_=sys.stderr,\n            )\n            return True\n        except PermissionError as error:\n            # HACK https://bugs.python.org/issue43095\n            if not (error.errno == 13 and platform.system() == \"Windows\"):\n                raise\n        except IsADirectoryError:\n            assert is_dir\n        if is_dir or previous_content == expected_contents:\n            printf(\n                \"identical\",\n                dst_relpath,\n                style=Style.IGNORE,\n                quiet=self.quiet,\n                file_=sys.stderr,\n            )\n            return True\n        return self._solve_render_conflict(dst_relpath)\n\n    def _ask(self) -&gt; None:\n        \"\"\"Ask the questions of the questionary and record their answers.\"\"\"\n        result = AnswersMap(\n            user_defaults=self.user_defaults,\n            init=self.data,\n            last=self.subproject.last_answers,\n            metadata=self.template.metadata,\n        )\n\n        index = 0\n        questionSize = self.template.questions_data.items().__len__()\n        for var_name, details in self.template.questions_data.items():\n            index = index + 1\n            question = Question(\n                answers=result,\n                jinja_env=self.jinja_env,\n                var_name=var_name,\n                envquestions=self.template.envquestions,\n                **details,\n            )\n            if self.skip_answered and var_name in result.last:\n                # Skip a question when the user already answered it.\n                continue\n            # Skip a question when the skip condition is met.\n            if not question.get_when():\n                # Omit its answer from the answers file.\n                result.hide(var_name)\n                # Skip immediately to the next question when it has no default\n                # value.\n                if question.default is MISSING:\n                    continue\n            if var_name in result.init:\n                # Try to parse the answer value.\n                answer = question.parse_answer(result.init[var_name])\n                # Try to validate the answer value if the question has a\n                # validator.\n                question.validate_answer(answer)\n                # At this point, the answer value is valid. Do not ask the\n                # question again, but set answer as the user's answer instead.\n                result.user[var_name] = answer\n                continue\n\n            # Display TUI and ask user interactively only without --defaults\n            try:\n                if self.defaults:\n                    new_answer = question.get_default()\n                    if new_answer is MISSING:\n                        raise ValueError(f'Question \"{var_name}\" is required')\n                else:\n                    new_answer = unsafe_prompt(\n                        [question.get_questionary_structure(f\"[{index}/{questionSize}]\")],\n                        answers={question.var_name: question.get_default()},\n                    )[question.var_name]\n            except KeyboardInterrupt as err:\n                raise KrupyAnswersInterrupt(result, question, self.template) from err\n            result.user[var_name] = new_answer\n\n        self.answers = result\n\n    @cached_property\n    def answers_relpath(self) -&gt; Path:\n        \"\"\"Obtain the proper relative path for the answers file.\n\n        It comes from:\n\n        1. User choice.\n        2. Template default.\n        3. Krupy default.\n        \"\"\"\n        path = self.answers_file or self.template.answers_relpath\n        template = self.jinja_env.from_string(str(path))\n        return Path(template.render(**self.answers.combined))\n\n    @cached_property\n    def all_exclusions(self) -&gt; StrSeq:\n        \"\"\"Combine default, template and user-chosen exclusions.\"\"\"\n        return self.template.exclude + tuple(self.exclude)\n\n    @cached_property\n    def jinja_env(self) -&gt; SandboxedEnvironment:\n        \"\"\"Return a pre-configured Jinja environment.\n\n        Respects template settings.\n        \"\"\"\n        paths = [str(self.template.local_abspath)]\n        loader = FileSystemLoader(paths)\n        default_extensions = [\n            \"jinja2_ansible_filters.AnsibleCoreFiltersExtension\",\n        ]\n        extensions = default_extensions + list(self.template.jinja_extensions)\n        # We want to minimize the risk of hidden malware in the templates\n        # so we use the SandboxedEnvironment instead of the regular one.\n        # Of course we still have the post-copy tasks to worry about, but at least\n        # they are more visible to the final user.\n        try:\n            env = SandboxedEnvironment(\n                loader=loader, extensions=extensions, **self.template.envops\n            )\n        except ModuleNotFoundError as error:\n            raise ExtensionNotFoundError(\n                f\"Krupy could not load some Jinja extensions:\\n{error}\\n\"\n                \"Make sure to install these extensions alongside Krupy itself.\\n\"\n                \"See the docs at https://krupy.readthedocs.io/en/latest/configuring/#jinja_extensions\"\n            )\n        # patch the `to_json` filter to support Pydantic dataclasses\n        env.filters[\"to_json\"] = partial(\n            env.filters[\"to_json\"], default=to_jsonable_python\n        )\n\n        # Add a global function to join filesystem paths.\n        separators = {\n            \"posix\": \"/\",\n            \"windows\": \"\\\\\",\n            \"native\": os.path.sep,\n        }\n\n        def _pathjoin(\n            *path: str, mode: Literal[\"posix\", \"windows\", \"native\"] = \"posix\"\n        ) -&gt; str:\n            return separators[mode].join(path)\n\n        env.globals[\"pathjoin\"] = _pathjoin\n        return env\n\n    @cached_property\n    def match_exclude(self) -&gt; Callable[[Path], bool]:\n        \"\"\"Get a callable to match paths against all exclusions.\"\"\"\n        return self._path_matcher(self.all_exclusions)\n\n    @cached_property\n    def match_skip(self) -&gt; Callable[[Path], bool]:\n        \"\"\"Get a callable to match paths against all skip-if-exists patterns.\"\"\"\n        return self._path_matcher(\n            map(\n                self._render_string,\n                tuple(chain(self.skip_if_exists, self.template.skip_if_exists)),\n            )\n        )\n\n    def _render_file(self, src_abspath: Path) -&gt; None:\n        \"\"\"Render one file.\n\n        Args:\n            src_abspath:\n                The absolute path to the file that will be rendered.\n        \"\"\"\n        # TODO Get from main.render_file()\n        assert src_abspath.is_absolute()\n        src_relpath = src_abspath.relative_to(self.template.local_abspath).as_posix()\n        src_renderpath = src_abspath.relative_to(self.template_copy_root)\n        dst_relpath = self._render_path(src_renderpath)\n        if dst_relpath is None:\n            return\n        if src_abspath.name.endswith(self.template.templates_suffix):\n            try:\n                tpl = self.jinja_env.get_template(src_relpath)\n            except UnicodeDecodeError:\n                if self.template.templates_suffix:\n                    # suffix is not empty, re-raise\n                    raise\n                # suffix is empty, fallback to copy\n                new_content = src_abspath.read_bytes()\n            else:\n                new_content = tpl.render(**self._render_context()).encode()\n        else:\n            new_content = src_abspath.read_bytes()\n        dst_abspath = Path(self.subproject.local_abspath, dst_relpath)\n        src_mode = src_abspath.stat().st_mode\n        if not self._render_allowed(dst_relpath, expected_contents=new_content):\n            return\n        if not self.pretend:\n            dst_abspath.parent.mkdir(parents=True, exist_ok=True)\n            dst_abspath.write_bytes(new_content)\n            dst_abspath.chmod(src_mode)\n\n    def _render_symlink(self, src_abspath: Path) -&gt; None:\n        \"\"\"Render one symlink.\n\n        Args:\n            src_abspath:\n                Symlink to be rendered. It must be an absolute path within\n                the template.\n        \"\"\"\n        assert src_abspath.is_absolute()\n        src_relpath = src_abspath.relative_to(self.template_copy_root)\n        dst_relpath = self._render_path(src_relpath)\n        if dst_relpath is None:\n            return\n        dst_abspath = Path(self.subproject.local_abspath, dst_relpath)\n\n        src_target = readlink(src_abspath)\n        if src_abspath.name.endswith(self.template.templates_suffix):\n            dst_target = Path(self._render_string(str(src_target)))\n        else:\n            dst_target = src_target\n\n        if not self._render_allowed(\n            dst_relpath,\n            expected_contents=dst_target,\n            is_symlink=True,\n        ):\n            return\n\n        if not self.pretend:\n            # symlink_to doesn't overwrite existing files, so delete it first\n            if dst_abspath.is_symlink() or dst_abspath.exists():\n                dst_abspath.unlink()\n            dst_abspath.symlink_to(dst_target)\n            if sys.platform == \"darwin\":\n                # Only macOS supports permissions on symlinks.\n                # Other platforms just copy the permission of the target\n                src_mode = src_abspath.lstat().st_mode\n                dst_abspath.lchmod(src_mode)\n\n    def _render_folder(self, src_abspath: Path) -&gt; None:\n        \"\"\"Recursively render a folder.\n\n        Args:\n            src_path:\n                Folder to be rendered. It must be an absolute path within\n                the template.\n        \"\"\"\n        assert src_abspath.is_absolute()\n        src_relpath = src_abspath.relative_to(self.template_copy_root)\n        dst_relpath = self._render_path(src_relpath)\n        if dst_relpath is None:\n            return\n        if not self._render_allowed(dst_relpath, is_dir=True):\n            return\n        dst_abspath = Path(self.subproject.local_abspath, dst_relpath)\n        if not self.pretend:\n            dst_abspath.mkdir(parents=True, exist_ok=True)\n        for file in src_abspath.iterdir():\n            if file.is_symlink() and self.template.preserve_symlinks:\n                self._render_symlink(file)\n            elif file.is_dir():\n                self._render_folder(file)\n            else:\n                self._render_file(file)\n\n    def _render_path(self, relpath: Path) -&gt; Optional[Path]:\n        \"\"\"Render one relative path.\n\n        Args:\n            relpath:\n                The relative path to be rendered. Obviously, it can be templated.\n        \"\"\"\n        is_template = relpath.name.endswith(self.template.templates_suffix)\n        templated_sibling = (\n            self.template.local_abspath / f\"{relpath}{self.template.templates_suffix}\"\n        )\n        # With an empty suffix, the templated sibling always exists.\n        if templated_sibling.exists() and self.template.templates_suffix:\n            return None\n        if self.template.templates_suffix and is_template:\n            relpath = relpath.with_suffix(\"\")\n        rendered_parts = []\n        for part in relpath.parts:\n            # Skip folder if any part is rendered as an empty string\n            part = self._render_string(part)\n            if not part:\n                return None\n            # {{ _krupy_conf.answers_file }} becomes the full path; in that case,\n            # restore part to be just the end leaf\n            if str(self.answers_relpath) == part:\n                part = Path(part).name\n            rendered_parts.append(part)\n        result = Path(*rendered_parts)\n        if not is_template:\n            templated_sibling = (\n                self.template.local_abspath\n                / f\"{result}{self.template.templates_suffix}\"\n            )\n            if templated_sibling.exists():\n                return None\n        return result\n\n    def _render_string(self, string: str) -&gt; str:\n        \"\"\"Render one templated string.\n\n        Args:\n            string:\n                The template source string.\n        \"\"\"\n        tpl = self.jinja_env.from_string(string)\n        return tpl.render(**self._render_context())\n\n    @cached_property\n    def subproject(self) -&gt; Subproject:\n        \"\"\"Get related subproject.\"\"\"\n        result = Subproject(\n            local_abspath=self.dst_path.absolute(),\n            answers_relpath=self.answers_file or Path(\".krupy-answers.yml\"),\n        )\n        self._cleanup_hooks.append(result._cleanup)\n        return result\n\n    @cached_property\n    def template(self) -&gt; Template:\n        \"\"\"Get related template.\"\"\"\n        url = self.src_path\n        if not url:\n            if self.subproject.template is None:\n                raise TypeError(\"Template not found\")\n            url = str(self.subproject.template.url)\n        result = Template(\n            url=url, ref=self.vcs_ref, use_prereleases=self.use_prereleases\n        )\n        self._cleanup_hooks.append(result._cleanup)\n        return result\n\n    @cached_property\n    def template_copy_root(self) -&gt; Path:\n        \"\"\"Absolute path from where to start copying.\n\n        It points to the cloned template local abspath + the rendered subdir, if any.\n        \"\"\"\n        subdir = self._render_string(self.template.subdirectory) or \"\"\n        return self.template.local_abspath / subdir\n\n    # Main operations\n    def run_copy(self) -&gt; None:\n        \"\"\"Generate a subproject from zero, ignoring what was in the folder.\n\n        If `dst_path` was missing, it will be\n        created. Otherwise, `src_path` be rendered\n        directly into it, without worrying about evolving what was there\n        already.\n\n        See [generating a project][generating-a-project].\n        \"\"\"\n        self._check_unsafe(\"copy\")\n        self._print_message(self.template.message_before_copy)\n        self._ask()\n        was_existing = self.subproject.local_abspath.exists()\n        src_abspath = self.template_copy_root\n        try:\n            if not self.quiet:\n                # TODO Unify printing tools\n                print(\n                    f\"\\nCopying from template version {self.template.version}\",\n                    file=sys.stderr,\n                )\n            self._render_folder(src_abspath)\n            if not self.quiet:\n                # TODO Unify printing tools\n                print(\"\")  # padding space\n            self._execute_tasks(self.template.tasks)\n        except Exception:\n            if not was_existing and self.cleanup_on_error:\n                rmtree(self.subproject.local_abspath)\n            raise\n        self._print_message(self.template.message_after_copy)\n        if not self.quiet:\n            # TODO Unify printing tools\n            print(\"\")  # padding space\n\n    def run_recopy(self) -&gt; None:\n        \"\"\"Update a subproject, keeping answers but discarding evolution.\"\"\"\n        if self.subproject.template is None:\n            raise UserMessageError(\n                \"Cannot recopy because cannot obtain old template references \"\n                f\"from `{self.subproject.answers_relpath}`.\"\n            )\n        with replace(self, src_path=self.subproject.template.url) as new_worker:\n            return new_worker.run_copy()\n\n    def run_update(self) -&gt; None:\n        \"\"\"Update a subproject that was already generated.\n\n        See [updating a project][updating-a-project].\n        \"\"\"\n        self._check_unsafe(\"update\")\n        # Check all you need is there\n        if self.subproject.vcs != \"git\":\n            raise UserMessageError(\n                \"Updating is only supported in git-tracked subprojects.\"\n            )\n        if self.subproject.is_dirty():\n            raise UserMessageError(\n                \"Destination repository is dirty; cannot continue. \"\n                \"Please commit or stash your local changes and retry.\"\n            )\n        if self.subproject.template is None or self.subproject.template.ref is None:\n            raise UserMessageError(\n                \"Cannot update because cannot obtain old template references \"\n                f\"from `{self.subproject.answers_relpath}`.\"\n            )\n        if self.template.commit is None:\n            raise UserMessageError(\n                \"Updating is only supported in git-tracked templates.\"\n            )\n        if not self.subproject.template.version:\n            raise UserMessageError(\n                \"Cannot update: version from last update not detected.\"\n            )\n        if not self.template.version:\n            raise UserMessageError(\"Cannot update: version from template not detected.\")\n        if self.subproject.template.version &gt; self.template.version:\n            raise UserMessageError(\n                f\"You are downgrading from {self.subproject.template.version} to {self.template.version}. \"\n                \"Downgrades are not supported.\"\n            )\n        if not self.overwrite:\n            # Only git-tracked subprojects can be updated, so the user can\n            # review the diff before committing; so we can safely avoid\n            # asking for confirmation\n            raise UserMessageError(\"Enable overwrite to update a subproject.\")\n        self._print_message(self.template.message_before_update)\n        if not self.quiet:\n            # TODO Unify printing tools\n            print(\n                f\"Updating to template version {self.template.version}\", file=sys.stderr\n            )\n        self._apply_update()\n        self._print_message(self.template.message_after_update)\n\n    def _apply_update(self):\n        git = get_git()\n        subproject_top = Path(\n            git(\n                \"-C\",\n                self.subproject.local_abspath,\n                \"rev-parse\",\n                \"--show-toplevel\",\n            ).strip()\n        )\n        subproject_subdir = self.subproject.local_abspath.relative_to(subproject_top)\n\n        with TemporaryDirectory(\n            prefix=f\"{__name__}.old_copy.\"\n        ) as old_copy, TemporaryDirectory(prefix=f\"{__name__}.new_copy.\") as new_copy:\n            # Copy old template into a temporary destination\n            with replace(\n                self,\n                dst_path=old_copy / subproject_subdir,\n                data=self.subproject.last_answers,\n                defaults=True,\n                quiet=True,\n                src_path=self.subproject.template.url,\n                vcs_ref=self.subproject.template.commit,\n            ) as old_worker:\n                old_worker.run_copy()\n            # Extract diff between temporary destination and real destination\n            with local.cwd(old_copy):\n                self._git_initialize_repo()\n                git(\"remote\", \"add\", \"real_dst\", \"file://\" + str(subproject_top))\n                git(\"fetch\", \"--depth=1\", \"real_dst\", \"HEAD\")\n                diff_cmd = git[\n                    \"diff-tree\", f\"--unified={self.context_lines}\", \"HEAD...FETCH_HEAD\"\n                ]\n                try:\n                    diff = diff_cmd(\"--inter-hunk-context=-1\")\n                except ProcessExecutionError:\n                    print(\n                        colors.warn\n                        | \"Make sure Git &gt;= 2.24 is installed to improve updates.\",\n                        file=sys.stderr,\n                    )\n                    diff = diff_cmd(\"--inter-hunk-context=0\")\n            # Run pre-migration tasks\n            self._execute_tasks(\n                self.template.migration_tasks(\"before\", self.subproject.template)\n            )\n            # Clear last answers cache to load possible answers migration, if skip_answered flag is not set\n            if self.skip_answered is False:\n                self.answers = AnswersMap()\n                with suppress(AttributeError):\n                    del self.subproject.last_answers\n            # Do a normal update in final destination\n            with replace(\n                self,\n                # Files can change due to the historical diff, and those\n                # changes are not detected in this process, so it's better to\n                # say nothing than lie.\n                # TODO\n                quiet=True,\n            ) as current_worker:\n                current_worker.run_copy()\n                self.answers = current_worker.answers\n            # Render with the same answers in an empty dir to avoid pollution\n            with replace(\n                self,\n                dst_path=new_copy / subproject_subdir,\n                data=self.answers.combined,\n                defaults=True,\n                quiet=True,\n                src_path=self.subproject.template.url,\n            ) as new_worker:\n                new_worker.run_copy()\n            compared = dircmp(old_copy, new_copy)\n            # Try to apply cached diff into final destination\n            with local.cwd(subproject_top):\n                apply_cmd = git[\"apply\", \"--reject\", \"--exclude\", self.answers_relpath]\n                for skip_pattern in chain(\n                    self.skip_if_exists, self.template.skip_if_exists\n                ):\n                    apply_cmd = apply_cmd[\"--exclude\", skip_pattern]\n                (apply_cmd &lt;&lt; diff)(retcode=None)\n                if self.conflict == \"inline\":\n                    status = git(\"status\", \"--porcelain\").strip().splitlines()\n                    for line in status:\n                        # Find merge rejections\n                        if not (line.startswith(\"?? \") and line.endswith(\".rej\")):\n                            continue\n                        # FIXME Test with a file named '`\u00e2 \u00f1\"', see it fail, fix it\n                        fname = line[3:-4]\n                        # Undo possible non-rejected chunks\n                        git(\"checkout\", \"--\", fname)\n                        # 3-way-merge the file directly\n                        git(\n                            \"merge-file\",\n                            \"-L\",\n                            \"before updating\",\n                            \"-L\",\n                            \"last update\",\n                            \"-L\",\n                            \"after updating\",\n                            fname,\n                            Path(old_copy) / fname,\n                            Path(new_copy) / fname,\n                            retcode=None,\n                        )\n                        # Remove rejection witness\n                        Path(f\"{fname}.rej\").unlink()\n            # Trigger recursive removal of deleted files in last template version\n            _remove_old_files(subproject_top, compared)\n\n        # Run post-migration tasks\n        self._execute_tasks(\n            self.template.migration_tasks(\"after\", self.subproject.template)\n        )\n\n    def _git_initialize_repo(self):\n        \"\"\"Initialize a git repository in the current directory.\"\"\"\n        git = get_git()\n        git(\"init\", retcode=None)\n        git(\"add\", \".\")\n        git(\"config\", \"user.name\", \"Krupy\")\n        git(\"config\", \"user.email\", \"krupy@krupy\")\n        # 1st commit could fail if any pre-commit hook reformats code\n        # 2nd commit uses --no-verify to disable pre-commit-like checks\n        git(\"commit\", \"--allow-empty\", \"-am\", \"dumb commit 1\", retcode=None)\n        git(\"commit\", \"--allow-empty\", \"-am\", \"dumb commit 2\", \"--no-verify\")\n        git(\"config\", \"--unset\", \"user.name\")\n        git(\"config\", \"--unset\", \"user.email\")\n</code></pre>"},{"location":"reference/krupy/main/#krupy.main.Worker.all_exclusions","title":"<code>all_exclusions: Sequence[str]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Combine default, template and user-chosen exclusions.</p>"},{"location":"reference/krupy/main/#krupy.main.Worker.answers_relpath","title":"<code>answers_relpath: Path</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Obtain the proper relative path for the answers file.</p> <p>It comes from:</p> <ol> <li>User choice.</li> <li>Template default.</li> <li>Krupy default.</li> </ol>"},{"location":"reference/krupy/main/#krupy.main.Worker.jinja_env","title":"<code>jinja_env: SandboxedEnvironment</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Return a pre-configured Jinja environment.</p> <p>Respects template settings.</p>"},{"location":"reference/krupy/main/#krupy.main.Worker.match_exclude","title":"<code>match_exclude: Callable[[pathlib.Path], bool]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get a callable to match paths against all exclusions.</p>"},{"location":"reference/krupy/main/#krupy.main.Worker.match_skip","title":"<code>match_skip: Callable[[pathlib.Path], bool]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get a callable to match paths against all skip-if-exists patterns.</p>"},{"location":"reference/krupy/main/#krupy.main.Worker.subproject","title":"<code>subproject: Subproject</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get related subproject.</p>"},{"location":"reference/krupy/main/#krupy.main.Worker.template","title":"<code>template: Template</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get related template.</p>"},{"location":"reference/krupy/main/#krupy.main.Worker.template_copy_root","title":"<code>template_copy_root: Path</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Absolute path from where to start copying.</p> <p>It points to the cloned template local abspath + the rendered subdir, if any.</p>"},{"location":"reference/krupy/main/#krupy.main.Worker.__enter__","title":"<code>__enter__(self)</code>  <code>special</code>","text":"<p>Allow using worker as a context manager.</p> Source code in <code>krupy/main.py</code> <pre><code>def __enter__(self):\n    \"\"\"Allow using worker as a context manager.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/krupy/main/#krupy.main.Worker.__exit__","title":"<code>__exit__(self, type, value, traceback)</code>  <code>special</code>","text":"<p>Clean up garbage files after worker usage ends.</p> Source code in <code>krupy/main.py</code> <pre><code>def __exit__(self, type, value, traceback):\n    \"\"\"Clean up garbage files after worker usage ends.\"\"\"\n    if value is not None:\n        # exception was raised from code inside context manager:\n        # try to clean up, ignoring any exception, then re-raise\n        with suppress(Exception):\n            self._cleanup()\n        raise value\n    # otherwise clean up and let any exception bubble up\n    self._cleanup()\n</code></pre>"},{"location":"reference/krupy/main/#krupy.main.Worker.run_copy","title":"<code>run_copy(self)</code>","text":"<p>Generate a subproject from zero, ignoring what was in the folder.</p> <p>If <code>dst_path</code> was missing, it will be created. Otherwise, <code>src_path</code> be rendered directly into it, without worrying about evolving what was there already.</p> <p>See generating a project.</p> Source code in <code>krupy/main.py</code> <pre><code>def run_copy(self) -&gt; None:\n    \"\"\"Generate a subproject from zero, ignoring what was in the folder.\n\n    If `dst_path` was missing, it will be\n    created. Otherwise, `src_path` be rendered\n    directly into it, without worrying about evolving what was there\n    already.\n\n    See [generating a project][generating-a-project].\n    \"\"\"\n    self._check_unsafe(\"copy\")\n    self._print_message(self.template.message_before_copy)\n    self._ask()\n    was_existing = self.subproject.local_abspath.exists()\n    src_abspath = self.template_copy_root\n    try:\n        if not self.quiet:\n            # TODO Unify printing tools\n            print(\n                f\"\\nCopying from template version {self.template.version}\",\n                file=sys.stderr,\n            )\n        self._render_folder(src_abspath)\n        if not self.quiet:\n            # TODO Unify printing tools\n            print(\"\")  # padding space\n        self._execute_tasks(self.template.tasks)\n    except Exception:\n        if not was_existing and self.cleanup_on_error:\n            rmtree(self.subproject.local_abspath)\n        raise\n    self._print_message(self.template.message_after_copy)\n    if not self.quiet:\n        # TODO Unify printing tools\n        print(\"\")  # padding space\n</code></pre>"},{"location":"reference/krupy/main/#krupy.main.Worker.run_recopy","title":"<code>run_recopy(self)</code>","text":"<p>Update a subproject, keeping answers but discarding evolution.</p> Source code in <code>krupy/main.py</code> <pre><code>def run_recopy(self) -&gt; None:\n    \"\"\"Update a subproject, keeping answers but discarding evolution.\"\"\"\n    if self.subproject.template is None:\n        raise UserMessageError(\n            \"Cannot recopy because cannot obtain old template references \"\n            f\"from `{self.subproject.answers_relpath}`.\"\n        )\n    with replace(self, src_path=self.subproject.template.url) as new_worker:\n        return new_worker.run_copy()\n</code></pre>"},{"location":"reference/krupy/main/#krupy.main.Worker.run_update","title":"<code>run_update(self)</code>","text":"<p>Update a subproject that was already generated.</p> <p>See updating a project.</p> Source code in <code>krupy/main.py</code> <pre><code>def run_update(self) -&gt; None:\n    \"\"\"Update a subproject that was already generated.\n\n    See [updating a project][updating-a-project].\n    \"\"\"\n    self._check_unsafe(\"update\")\n    # Check all you need is there\n    if self.subproject.vcs != \"git\":\n        raise UserMessageError(\n            \"Updating is only supported in git-tracked subprojects.\"\n        )\n    if self.subproject.is_dirty():\n        raise UserMessageError(\n            \"Destination repository is dirty; cannot continue. \"\n            \"Please commit or stash your local changes and retry.\"\n        )\n    if self.subproject.template is None or self.subproject.template.ref is None:\n        raise UserMessageError(\n            \"Cannot update because cannot obtain old template references \"\n            f\"from `{self.subproject.answers_relpath}`.\"\n        )\n    if self.template.commit is None:\n        raise UserMessageError(\n            \"Updating is only supported in git-tracked templates.\"\n        )\n    if not self.subproject.template.version:\n        raise UserMessageError(\n            \"Cannot update: version from last update not detected.\"\n        )\n    if not self.template.version:\n        raise UserMessageError(\"Cannot update: version from template not detected.\")\n    if self.subproject.template.version &gt; self.template.version:\n        raise UserMessageError(\n            f\"You are downgrading from {self.subproject.template.version} to {self.template.version}. \"\n            \"Downgrades are not supported.\"\n        )\n    if not self.overwrite:\n        # Only git-tracked subprojects can be updated, so the user can\n        # review the diff before committing; so we can safely avoid\n        # asking for confirmation\n        raise UserMessageError(\"Enable overwrite to update a subproject.\")\n    self._print_message(self.template.message_before_update)\n    if not self.quiet:\n        # TODO Unify printing tools\n        print(\n            f\"Updating to template version {self.template.version}\", file=sys.stderr\n        )\n    self._apply_update()\n    self._print_message(self.template.message_after_update)\n</code></pre>"},{"location":"reference/krupy/main/#krupy.main.run_copy","title":"<code>run_copy(src_path, dst_path='.', data=None, **kwargs)</code>","text":"<p>Copy a template to a destination, from zero.</p> <p>This is a shortcut for run_copy.</p> <p>See Worker fields to understand this function's args.</p> Source code in <code>krupy/main.py</code> <pre><code>def run_copy(\n    src_path: str,\n    dst_path: StrOrPath = \".\",\n    data: Optional[AnyByStrDict] = None,\n    **kwargs,\n) -&gt; Worker:\n    \"\"\"Copy a template to a destination, from zero.\n\n    This is a shortcut for [run_copy][krupy.main.Worker.run_copy].\n\n    See [Worker][krupy.main.Worker] fields to understand this function's args.\n    \"\"\"\n    if data is not None:\n        kwargs[\"data\"] = data\n    with Worker(src_path=src_path, dst_path=Path(dst_path), **kwargs) as worker:\n        worker.run_copy()\n    return worker\n</code></pre>"},{"location":"reference/krupy/main/#krupy.main.run_recopy","title":"<code>run_recopy(dst_path='.', data=None, **kwargs)</code>","text":"<p>Update a subproject from its template, discarding subproject evolution.</p> <p>This is a shortcut for run_recopy.</p> <p>See Worker fields to understand this function's args.</p> Source code in <code>krupy/main.py</code> <pre><code>def run_recopy(\n    dst_path: StrOrPath = \".\", data: Optional[AnyByStrDict] = None, **kwargs\n) -&gt; Worker:\n    \"\"\"Update a subproject from its template, discarding subproject evolution.\n\n    This is a shortcut for [run_recopy][krupy.main.Worker.run_recopy].\n\n    See [Worker][krupy.main.Worker] fields to understand this function's args.\n    \"\"\"\n    if data is not None:\n        kwargs[\"data\"] = data\n    with Worker(dst_path=Path(dst_path), **kwargs) as worker:\n        worker.run_recopy()\n    return worker\n</code></pre>"},{"location":"reference/krupy/main/#krupy.main.run_update","title":"<code>run_update(dst_path='.', data=None, **kwargs)</code>","text":"<p>Update a subproject, from its template.</p> <p>This is a shortcut for run_update.</p> <p>See Worker fields to understand this function's args.</p> Source code in <code>krupy/main.py</code> <pre><code>def run_update(\n    dst_path: StrOrPath = \".\",\n    data: Optional[AnyByStrDict] = None,\n    **kwargs,\n) -&gt; Worker:\n    \"\"\"Update a subproject, from its template.\n\n    This is a shortcut for [run_update][krupy.main.Worker.run_update].\n\n    See [Worker][krupy.main.Worker] fields to understand this function's args.\n    \"\"\"\n    if data is not None:\n        kwargs[\"data\"] = data\n    with Worker(dst_path=Path(dst_path), **kwargs) as worker:\n        worker.run_update()\n    return worker\n</code></pre>"},{"location":"reference/krupy/subproject/","title":"subproject.py","text":"<p>Objects to interact with subprojects.</p> <p>A subproject is a project that gets rendered and/or updated with Krupy.</p>"},{"location":"reference/krupy/subproject/#krupy.subproject.Subproject","title":"<code> Subproject        </code>  <code>dataclass</code>","text":"<p>Object that represents the subproject and its current state.</p> <p>Attributes:</p> Name Type Description <code>local_abspath</code> <code>Path</code> <p>Absolute path on local disk pointing to the subproject root folder.</p> <code>answers_relpath</code> <code>Path</code> <p>Relative path to the answers file.</p> Source code in <code>krupy/subproject.py</code> <pre><code>@dataclass\nclass Subproject:\n    \"\"\"Object that represents the subproject and its current state.\n\n    Attributes:\n        local_abspath:\n            Absolute path on local disk pointing to the subproject root folder.\n\n        answers_relpath:\n            Relative path to [the answers file][the-krupy-answersyml-file].\n    \"\"\"\n\n    local_abspath: AbsolutePath\n    answers_relpath: Path = Path(\".krupy-answers.yml\")\n\n    _cleanup_hooks: List[Callable] = field(default_factory=list, init=False)\n\n    def is_dirty(self) -&gt; bool:\n        \"\"\"Indicate if the local template root is dirty.\n\n        Only applicable for VCS-tracked templates.\n        \"\"\"\n        if self.vcs == \"git\":\n            with local.cwd(self.local_abspath):\n                return bool(get_git()(\"status\", \"--porcelain\").strip())\n        return False\n\n    def _cleanup(self):\n        \"\"\"Remove temporary files and folders created by the subproject.\"\"\"\n        for method in self._cleanup_hooks:\n            method()\n\n    @property\n    def _raw_answers(self) -&gt; AnyByStrDict:\n        \"\"\"Get last answers, loaded raw as yaml.\"\"\"\n        try:\n            return yaml.safe_load(\n                (self.local_abspath / self.answers_relpath).read_text()\n            )\n        except OSError:\n            return {}\n\n    @cached_property\n    def last_answers(self) -&gt; AnyByStrDict:\n        \"\"\"Last answers, excluding private ones (except _src_path and _commit).\"\"\"\n        return {\n            key: value\n            for key, value in self._raw_answers.items()\n            if key in {\"_src_path\", \"_commit\"} or not key.startswith(\"_\")\n        }\n\n    @cached_property\n    def template(self) -&gt; Optional[Template]:\n        \"\"\"Template, as it was used the last time.\"\"\"\n        last_url = self.last_answers.get(\"_src_path\")\n        last_ref = self.last_answers.get(\"_commit\")\n        if last_url:\n            result = Template(url=last_url, ref=last_ref)\n            self._cleanup_hooks.append(result._cleanup)\n            return result\n\n    @cached_property\n    def vcs(self) -&gt; Optional[VCSTypes]:\n        \"\"\"VCS type of the subproject.\"\"\"\n        if is_in_git_repo(self.local_abspath):\n            return \"git\"\n</code></pre>"},{"location":"reference/krupy/subproject/#krupy.subproject.Subproject.last_answers","title":"<code>last_answers: Dict[str, Any]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Last answers, excluding private ones (except _src_path and _commit).</p>"},{"location":"reference/krupy/subproject/#krupy.subproject.Subproject.template","title":"<code>template: Optional[krupy.template.Template]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Template, as it was used the last time.</p>"},{"location":"reference/krupy/subproject/#krupy.subproject.Subproject.vcs","title":"<code>vcs: Optional[Literal['git']]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>VCS type of the subproject.</p>"},{"location":"reference/krupy/subproject/#krupy.subproject.Subproject.is_dirty","title":"<code>is_dirty(self)</code>","text":"<p>Indicate if the local template root is dirty.</p> <p>Only applicable for VCS-tracked templates.</p> Source code in <code>krupy/subproject.py</code> <pre><code>def is_dirty(self) -&gt; bool:\n    \"\"\"Indicate if the local template root is dirty.\n\n    Only applicable for VCS-tracked templates.\n    \"\"\"\n    if self.vcs == \"git\":\n        with local.cwd(self.local_abspath):\n            return bool(get_git()(\"status\", \"--porcelain\").strip())\n    return False\n</code></pre>"},{"location":"reference/krupy/template/","title":"template.py","text":"<p>Tools related to template management.</p>"},{"location":"reference/krupy/template/#krupy.template.Task","title":"<code> Task        </code>  <code>dataclass</code>","text":"<p>Object that represents a task to execute.</p> <p>Attributes:</p> Name Type Description <code>cmd</code> <code>Union[str, Sequence[str]]</code> <p>Command to execute.</p> <code>extra_env</code> <code>Mapping[str, str]</code> <p>Additional environment variables to set while executing the command.</p> Source code in <code>krupy/template.py</code> <pre><code>@dataclass\nclass Task:\n    \"\"\"Object that represents a task to execute.\n\n    Attributes:\n        cmd:\n            Command to execute.\n\n        extra_env:\n            Additional environment variables to set while executing the command.\n    \"\"\"\n\n    cmd: Union[str, Sequence[str]]\n    extra_env: Env = field(default_factory=dict)\n</code></pre>"},{"location":"reference/krupy/template/#krupy.template.Template","title":"<code> Template        </code>  <code>dataclass</code>","text":"<p>Object that represents a template and its current state.</p> <p>See configuring a template.</p> <p>Attributes:</p> Name Type Description <code>url</code> <code>str</code> <p>Absolute origin that points to the template.</p> <p>It can be:</p> <ul> <li>A local path.</li> <li>A Git url. Note: if something fails, prefix the URL with <code>git+</code>.</li> </ul> <code>ref</code> <code>Optional[str]</code> <p>The tag to checkout in the template.</p> <p>Only used if <code>url</code> points to a VCS-tracked template.</p> <p>If <code>None</code>, then it will checkout the latest tag, sorted by PEP440. Otherwise it will checkout the reference used here.</p> <p>Usually it should be a tag, or <code>None</code>.</p> <code>use_prereleases</code> <code>bool</code> <p>When <code>True</code>, the template's latest release will consider prereleases.</p> <p>Only used if:</p> <ul> <li><code>url</code> points to a VCS-tracked template</li> <li><code>ref</code> is <code>None</code>.</li> </ul> <p>Helpful if you want to test templates before doing a proper release, but you need some features that require a proper PEP440 version identifier.</p> Source code in <code>krupy/template.py</code> <pre><code>@dataclass\nclass Template:\n    \"\"\"Object that represents a template and its current state.\n\n    See [configuring a template][configuring-a-template].\n\n    Attributes:\n        url:\n            Absolute origin that points to the template.\n\n            It can be:\n\n            - A local path.\n            - A Git url. Note: if something fails, prefix the URL with `git+`.\n\n        ref:\n            The tag to checkout in the template.\n\n            Only used if `url` points to a VCS-tracked template.\n\n            If `None`, then it will checkout the latest tag, sorted by PEP440.\n            Otherwise it will checkout the reference used here.\n\n            Usually it should be a tag, or `None`.\n\n        use_prereleases:\n            When `True`, the template's *latest* release will consider prereleases.\n\n            Only used if:\n\n            - `url` points to a VCS-tracked template\n            - `ref` is `None`.\n\n            Helpful if you want to test templates before doing a proper release, but you\n            need some features that require a proper PEP440 version identifier.\n    \"\"\"\n\n    url: str\n    ref: OptStr = None\n    use_prereleases: bool = False\n\n    def _cleanup(self) -&gt; None:\n        temp_clone = self._temp_clone()\n        if temp_clone:\n            rmtree(\n                temp_clone,\n                ignore_errors=False,\n                onerror=handle_remove_readonly,\n            )\n\n    def _temp_clone(self) -&gt; Optional[Path]:\n        \"\"\"Get the path to the temporary clone of the template.\n\n        If the template hasn't yet been cloned, or if it was a local template,\n        then there's no temporary clone and this will return `None`.\n        \"\"\"\n        if \"local_abspath\" not in self.__dict__:\n            return None\n        clone_path = self.local_abspath\n        original_path = Path(self.url).expanduser()\n        with suppress(OSError):  # triggered for URLs on Windows\n            original_path = original_path.resolve()\n        if clone_path != original_path:\n            return clone_path\n        return None\n\n    @cached_property\n    def _raw_config(self) -&gt; AnyByStrDict:\n        \"\"\"Get template configuration, raw.\n\n        It reads [the `krupy.yml` file][the-krupyyml-file].\n        \"\"\"\n        conf_paths = [\n            p\n            for p in self.local_abspath.glob(\"krupy.*\")\n            if p.is_file() and re.match(r\"\\.ya?ml\", p.suffix, re.I)\n        ]\n        if len(conf_paths) &gt; 1:\n            raise MultipleConfigFilesError(conf_paths)\n        elif len(conf_paths) == 1:\n            return load_template_config(conf_paths[0])\n        return {}\n\n    @cached_property\n    def answers_relpath(self) -&gt; Path:\n        \"\"\"Get the answers file relative path, as specified in the template.\n\n        If not specified, returns the default `.krupy-answers.yml`.\n\n        See [answers_file][].\n        \"\"\"\n        result = Path(self.config_data.get(\"answers_file\", \".krupy-answers.yml\"))\n        assert not result.is_absolute()\n        return result\n\n    @cached_property\n    def commit(self) -&gt; OptStr:\n        \"\"\"If the template is VCS-tracked, get its commit description.\"\"\"\n        if self.vcs == \"git\":\n            with local.cwd(self.local_abspath):\n                return get_git()(\"describe\", \"--tags\", \"--always\").strip()\n\n    @cached_property\n    def commit_hash(self) -&gt; OptStr:\n        \"\"\"If the template is VCS-tracked, get its commit full hash.\"\"\"\n        if self.vcs == \"git\":\n            return get_git()(\"-C\", self.local_abspath, \"rev-parse\", \"HEAD\").strip()\n\n    @cached_property\n    def config_data(self) -&gt; AnyByStrDict:\n        \"\"\"Get config from the template.\n\n        It reads [the `krupy.yml` file][the-krupyyml-file] to get its\n        [settings][available-settings].\n        \"\"\"\n        result = filter_config(self._raw_config)[0]\n        with suppress(KeyError):\n            verify_krupy_version(result[\"min_krupy_version\"])\n        return result\n\n    @cached_property\n    def envops(self) -&gt; Mapping:\n        \"\"\"Get the Jinja configuration specified in the template, or default values.\n\n        See [envops][].\n        \"\"\"\n        result = self.config_data.get(\"envops\", {})\n        if \"keep_trailing_newline\" not in result:\n            # NOTE: we want to keep trailing newlines in templates as this is what a\n            #       user will most likely expects as a default.\n            #       See https://github.com/Krunal-Kevadiya/krupy/issues/464\n            result[\"keep_trailing_newline\"] = True\n        return result\n\n    @cached_property\n    def envquestions(self) -&gt; Mapping:\n        \"\"\"Get the Jinja configuration specified in the template, or default values.\n\n        See [envquestions][].\n        \"\"\"\n        result = self.config_data.get(\"envquestions\", {})\n        if \"is_visible_count\" not in result:\n            result[\"is_visible_count\"] = True\n        if \"is_visible_mark\" not in result:\n            result[\"is_visible_mark\"] = True\n        if \"is_visible_type\" not in result:\n            result[\"is_visible_type\"] = True\n        if \"is_visible_default_value\" not in result:\n            result[\"is_visible_default_value\"] = True\n        if \"style\" not in result:\n            result[\"style\"] = {}\n        return result\n\n    @cached_property\n    def exclude(self) -&gt; Tuple[str, ...]:\n        \"\"\"Get exclusions specified in the template, or default ones.\n\n        See [exclude][].\n        \"\"\"\n        return tuple(\n            self.config_data.get(\n                \"exclude\",\n                DEFAULT_EXCLUDE if Path(self.subdirectory) == Path(\".\") else [],\n            )\n        )\n\n    @cached_property\n    def jinja_extensions(self) -&gt; Tuple[str, ...]:\n        \"\"\"Get Jinja2 extensions specified in the template, or `()`.\n\n        See [jinja_extensions][].\n        \"\"\"\n        return tuple(self.config_data.get(\"jinja_extensions\", ()))\n\n    @cached_property\n    def message_after_copy(self) -&gt; str:\n        \"\"\"Get message to print after copy action specified in the template.\"\"\"\n        return self.config_data.get(\"message_after_copy\", \"\")\n\n    @cached_property\n    def message_after_update(self) -&gt; str:\n        \"\"\"Get message to print after update action specified in the template.\"\"\"\n        return self.config_data.get(\"message_after_update\", \"\")\n\n    @cached_property\n    def message_before_copy(self) -&gt; str:\n        \"\"\"Get message to print before copy action specified in the template.\"\"\"\n        return self.config_data.get(\"message_before_copy\", \"\")\n\n    @cached_property\n    def message_before_update(self) -&gt; str:\n        \"\"\"Get message to print before update action specified in the template.\"\"\"\n        return self.config_data.get(\"message_before_update\", \"\")\n\n    @cached_property\n    def metadata(self) -&gt; AnyByStrDict:\n        \"\"\"Get template metadata.\n\n        This data, if any, should be saved in the answers file to be able to\n        restore the template to this same state.\n        \"\"\"\n        result: AnyByStrDict = {\"_src_path\": self.url}\n        if self.commit:\n            result[\"_commit\"] = self.commit\n        return result\n\n    def migration_tasks(\n        self, stage: Literal[\"before\", \"after\"], from_template: \"Template\"\n    ) -&gt; Sequence[Task]:\n        \"\"\"Get migration objects that match current version spec.\n\n        Versions are compared using PEP 440.\n\n        See [migrations][].\n\n        Args:\n            stage: A valid stage name to find tasks for.\n            from_template: Original template, from which we are migrating.\n        \"\"\"\n        result: List[Task] = []\n        if not (self.version and from_template.version):\n            return result\n        extra_env: Env = {\n            \"STAGE\": stage,\n            \"VERSION_FROM\": str(from_template.commit),\n            \"VERSION_TO\": str(self.commit),\n            \"VERSION_PEP440_FROM\": str(from_template.version),\n            \"VERSION_PEP440_TO\": str(self.version),\n        }\n        migration: dict\n        for migration in self._raw_config.get(\"_migrations\", []):\n            current = parse(migration[\"version\"])\n            if self.version &gt;= current &gt; from_template.version:\n                extra_env = {\n                    **extra_env,\n                    \"VERSION_CURRENT\": migration[\"version\"],\n                    \"VERSION_PEP440_CURRENT\": str(current),\n                }\n                for cmd in migration.get(stage, []):\n                    result.append(Task(cmd=cmd, extra_env=extra_env))\n        return result\n\n    @cached_property\n    def min_krupy_version(self) -&gt; Optional[Version]:\n        \"\"\"Get minimal krupy version for the template and validates it.\n\n        See [min_krupy_version][].\n        \"\"\"\n        try:\n            return Version(self.config_data[\"min_krupy_version\"])\n        except KeyError:\n            return None\n\n    @cached_property\n    def questions_data(self) -&gt; AnyByStrDict:\n        \"\"\"Get questions from the template.\n\n        See [questions][].\n        \"\"\"\n        result = filter_config(self._raw_config)[1]\n        for key in set(self.config_data.get(\"secret_questions\", [])):\n            if key in result:\n                result[key][\"secret\"] = True\n        return result\n\n    @cached_property\n    def secret_questions(self) -&gt; Set[str]:\n        \"\"\"Get names of secret questions from the template.\n\n        These questions shouldn't be saved into the answers file.\n        \"\"\"\n        result = set(self.config_data.get(\"secret_questions\", []))\n        for key, value in self.questions_data.items():\n            if value.get(\"secret\"):\n                result.add(key)\n        return result\n\n    @cached_property\n    def skip_if_exists(self) -&gt; StrSeq:\n        \"\"\"Get skip patterns from the template.\n\n        These files will never be rewritten when rendering the template.\n\n        See [skip_if_exists][].\n        \"\"\"\n        return self.config_data.get(\"skip_if_exists\", ())\n\n    @cached_property\n    def subdirectory(self) -&gt; str:\n        \"\"\"Get the subdirectory as specified in the template.\n\n        The subdirectory points to the real template code, allowing the\n        templater to separate it from other template assets, such as docs,\n        tests, etc.\n\n        See [subdirectory][].\n        \"\"\"\n        return self.config_data.get(\"subdirectory\", \"\")\n\n    @cached_property\n    def tasks(self) -&gt; Sequence[Task]:\n        \"\"\"Get tasks defined in the template.\n\n        See [tasks][].\n        \"\"\"\n        return [\n            Task(cmd=cmd, extra_env={\"STAGE\": \"task\"})\n            for cmd in self.config_data.get(\"tasks\", [])\n        ]\n\n    @cached_property\n    def templates_suffix(self) -&gt; str:\n        \"\"\"Get the suffix defined for templates.\n\n        By default: `.jinja`.\n\n        See [templates_suffix][].\n        \"\"\"\n        result = self.config_data.get(\"templates_suffix\")\n        if result is None:\n            return DEFAULT_TEMPLATES_SUFFIX\n        return result\n\n    @cached_property\n    def preserve_symlinks(self) -&gt; bool:\n        \"\"\"Know if Krupy should preserve symlinks when rendering the template.\n\n        See [preserve_symlinks][].\n        \"\"\"\n        return bool(self.config_data.get(\"preserve_symlinks\", False))\n\n    @cached_property\n    def local_abspath(self) -&gt; Path:\n        \"\"\"Get the absolute path to the template on disk.\n\n        This may clone it if `url` points to a VCS-tracked template.\n        Dirty changes for local VCS-tracked templates will be copied.\n        \"\"\"\n        result = Path(self.url)\n        if self.vcs == \"git\":\n            result = Path(clone(self.url_expanded, self.ref))\n            if self.ref is None:\n                checkout_latest_tag(result, self.use_prereleases)\n        if not result.is_dir():\n            raise ValueError(\"Local template must be a directory.\")\n        with suppress(OSError):\n            result = result.resolve()\n        return result\n\n    @cached_property\n    def url_expanded(self) -&gt; str:\n        \"\"\"Get usable URL.\n\n        `url` can be specified in shortcut\n        format, which wouldn't be understood by the underlying VCS system. This\n        property returns the expanded version, which should work properly.\n        \"\"\"\n        return get_repo(self.url) or self.url\n\n    @cached_property\n    def version(self) -&gt; Optional[Version]:\n        \"\"\"PEP440-compliant version object.\"\"\"\n        if self.vcs != \"git\" or not self.commit:\n            return None\n        try:\n            with local.cwd(self.local_abspath):\n                # Leverage dunamai by default; usually it gets best results.\n                # `dunamai.Version.from_git` needs `Pattern.DefaultUnprefixed`\n                # to be PEP440 compliant on version reading\n                return Version(\n                    dunamai.Version.from_git(\n                        pattern=dunamai.Pattern.DefaultUnprefixed\n                    ).serialize(style=dunamai.Style.Pep440)\n                )\n        except ValueError:\n            # A fully descriptive commit can be easily detected converted into a\n            # PEP440 version, because it has the format \"&lt;tag&gt;-&lt;count&gt;-g&lt;hash&gt;\"\n            if re.match(r\"^.+-\\d+-g\\w+$\", self.commit):\n                base, count, git_hash = self.commit.rsplit(\"-\", 2)\n                return Version(f\"{base}.post{count}+{git_hash}\")\n        # If we get here, the commit string is a tag\n        try:\n            return Version(self.commit)\n        except packaging.version.InvalidVersion:\n            # appears to not be a version\n            return None\n\n    @cached_property\n    def vcs(self) -&gt; Optional[VCSTypes]:\n        \"\"\"Get VCS system used by the template, if any.\"\"\"\n        if get_repo(self.url):\n            return \"git\"\n</code></pre>"},{"location":"reference/krupy/template/#krupy.template.Template.answers_relpath","title":"<code>answers_relpath: Path</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get the answers file relative path, as specified in the template.</p> <p>If not specified, returns the default <code>.krupy-answers.yml</code>.</p> <p>See answers_file.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.commit","title":"<code>commit: Optional[str]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>If the template is VCS-tracked, get its commit description.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.commit_hash","title":"<code>commit_hash: Optional[str]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>If the template is VCS-tracked, get its commit full hash.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.config_data","title":"<code>config_data: Dict[str, Any]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get config from the template.</p> <p>It reads the <code>krupy.yml</code> file to get its settings.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.envops","title":"<code>envops: Mapping</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get the Jinja configuration specified in the template, or default values.</p> <p>See envops.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.envquestions","title":"<code>envquestions: Mapping</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get the Jinja configuration specified in the template, or default values.</p> <p>See envquestions.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.exclude","title":"<code>exclude: Tuple[str, ...]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get exclusions specified in the template, or default ones.</p> <p>See exclude.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.jinja_extensions","title":"<code>jinja_extensions: Tuple[str, ...]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get Jinja2 extensions specified in the template, or <code>()</code>.</p> <p>See jinja_extensions.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.local_abspath","title":"<code>local_abspath: Path</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get the absolute path to the template on disk.</p> <p>This may clone it if <code>url</code> points to a VCS-tracked template. Dirty changes for local VCS-tracked templates will be copied.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.message_after_copy","title":"<code>message_after_copy: str</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get message to print after copy action specified in the template.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.message_after_update","title":"<code>message_after_update: str</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get message to print after update action specified in the template.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.message_before_copy","title":"<code>message_before_copy: str</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get message to print before copy action specified in the template.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.message_before_update","title":"<code>message_before_update: str</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get message to print before update action specified in the template.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.metadata","title":"<code>metadata: Dict[str, Any]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get template metadata.</p> <p>This data, if any, should be saved in the answers file to be able to restore the template to this same state.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.min_krupy_version","title":"<code>min_krupy_version: Optional[packaging.version.Version]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get minimal krupy version for the template and validates it.</p> <p>See min_krupy_version.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.preserve_symlinks","title":"<code>preserve_symlinks: bool</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Know if Krupy should preserve symlinks when rendering the template.</p> <p>See preserve_symlinks.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.questions_data","title":"<code>questions_data: Dict[str, Any]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get questions from the template.</p> <p>See questions.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.secret_questions","title":"<code>secret_questions: Set[str]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get names of secret questions from the template.</p> <p>These questions shouldn't be saved into the answers file.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.skip_if_exists","title":"<code>skip_if_exists: Sequence[str]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get skip patterns from the template.</p> <p>These files will never be rewritten when rendering the template.</p> <p>See skip_if_exists.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.subdirectory","title":"<code>subdirectory: str</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get the subdirectory as specified in the template.</p> <p>The subdirectory points to the real template code, allowing the templater to separate it from other template assets, such as docs, tests, etc.</p> <p>See subdirectory.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.tasks","title":"<code>tasks: Sequence[krupy.template.Task]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get tasks defined in the template.</p> <p>See tasks.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.templates_suffix","title":"<code>templates_suffix: str</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get the suffix defined for templates.</p> <p>By default: <code>.jinja</code>.</p> <p>See templates_suffix.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.url_expanded","title":"<code>url_expanded: str</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get usable URL.</p> <p><code>url</code> can be specified in shortcut format, which wouldn't be understood by the underlying VCS system. This property returns the expanded version, which should work properly.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.vcs","title":"<code>vcs: Optional[Literal['git']]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>Get VCS system used by the template, if any.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.version","title":"<code>version: Optional[packaging.version.Version]</code>  <code>cached</code> <code>property</code> <code>writable</code>","text":"<p>PEP440-compliant version object.</p>"},{"location":"reference/krupy/template/#krupy.template.Template.migration_tasks","title":"<code>migration_tasks(self, stage, from_template)</code>","text":"<p>Get migration objects that match current version spec.</p> <p>Versions are compared using PEP 440.</p> <p>See migrations.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>Literal['before', 'after']</code> <p>A valid stage name to find tasks for.</p> required <code>from_template</code> <code>Template</code> <p>Original template, from which we are migrating.</p> required Source code in <code>krupy/template.py</code> <pre><code>def migration_tasks(\n    self, stage: Literal[\"before\", \"after\"], from_template: \"Template\"\n) -&gt; Sequence[Task]:\n    \"\"\"Get migration objects that match current version spec.\n\n    Versions are compared using PEP 440.\n\n    See [migrations][].\n\n    Args:\n        stage: A valid stage name to find tasks for.\n        from_template: Original template, from which we are migrating.\n    \"\"\"\n    result: List[Task] = []\n    if not (self.version and from_template.version):\n        return result\n    extra_env: Env = {\n        \"STAGE\": stage,\n        \"VERSION_FROM\": str(from_template.commit),\n        \"VERSION_TO\": str(self.commit),\n        \"VERSION_PEP440_FROM\": str(from_template.version),\n        \"VERSION_PEP440_TO\": str(self.version),\n    }\n    migration: dict\n    for migration in self._raw_config.get(\"_migrations\", []):\n        current = parse(migration[\"version\"])\n        if self.version &gt;= current &gt; from_template.version:\n            extra_env = {\n                **extra_env,\n                \"VERSION_CURRENT\": migration[\"version\"],\n                \"VERSION_PEP440_CURRENT\": str(current),\n            }\n            for cmd in migration.get(stage, []):\n                result.append(Task(cmd=cmd, extra_env=extra_env))\n    return result\n</code></pre>"},{"location":"reference/krupy/template/#krupy.template.filter_config","title":"<code>filter_config(data)</code>","text":"<p>Separates config and questions data.</p> Source code in <code>krupy/template.py</code> <pre><code>def filter_config(data: AnyByStrDict) -&gt; Tuple[AnyByStrDict, AnyByStrDict]:\n    \"\"\"Separates config and questions data.\"\"\"\n    config_data: AnyByStrDict = {}\n    questions_data = {}\n    for k, v in data.items():\n        if k.startswith(\"_\"):\n            config_data[k[1:]] = v\n        else:\n            # Transform simplified questions format into complex\n            if not isinstance(v, dict):\n                v = {\"default\": v}\n            questions_data[k] = v\n    return config_data, questions_data\n</code></pre>"},{"location":"reference/krupy/template/#krupy.template.load_template_config","title":"<code>load_template_config(conf_path, quiet=False)</code>","text":"<p>Load the <code>krupy.yml</code> file.</p> <p>This is like a simple YAML load, but applying all specific quirks needed for the <code>krupy.yml</code> file.</p> <p>For example, it supports the <code>!include</code> tag with glob includes, and merges multiple sections.</p> <p>Parameters:</p> Name Type Description Default <code>conf_path</code> <code>Path</code> <p>The path to the <code>krupy.yml</code> file.</p> required <code>quiet</code> <code>bool</code> <p>Used to configure the exception.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>InvalidConfigFileError</code> <p>When the file is formatted badly.</p> Source code in <code>krupy/template.py</code> <pre><code>def load_template_config(conf_path: Path, quiet: bool = False) -&gt; AnyByStrDict:\n    \"\"\"Load the `krupy.yml` file.\n\n    This is like a simple YAML load, but applying all specific quirks needed\n    for [the `krupy.yml` file][the-krupyyml-file].\n\n    For example, it supports the `!include` tag with glob includes, and\n    merges multiple sections.\n\n    Params:\n        conf_path: The path to the `krupy.yml` file.\n        quiet: Used to configure the exception.\n\n    Raises:\n        InvalidConfigFileError: When the file is formatted badly.\n    \"\"\"\n\n    class _Loader(yaml.FullLoader):\n        \"\"\"Intermediate class to avoid monkey-patching main loader.\"\"\"\n\n    YamlIncludeConstructor.add_to_loader_class(\n        loader_class=_Loader, base_dir=conf_path.parent\n    )\n\n    with open(conf_path) as f:\n        try:\n            flattened_result = lflatten(yaml.load_all(f, Loader=_Loader))\n        except yaml.parser.ParserError as e:\n            raise InvalidConfigFileError(conf_path, quiet) from e\n\n    merged_options = defaultdict(list)\n    for option in (\n        \"_exclude\",\n        \"_jinja_extensions\",\n        \"_secret_questions\",\n        \"_skip_if_exists\",\n    ):\n        for result in flattened_result:\n            try:\n                values = result[option]\n            except KeyError:\n                pass\n            else:\n                merged_options[option].extend(values)\n\n    return dict(ChainMap(dict(merged_options), *reversed(flattened_result)))\n</code></pre>"},{"location":"reference/krupy/template/#krupy.template.verify_krupy_version","title":"<code>verify_krupy_version(version_str)</code>","text":"<p>Raise an error if the current Krupy version is less than the given version.</p> <p>Parameters:</p> Name Type Description Default <code>version_str</code> <code>str</code> <p>Minimal krupy version for the template.</p> required Source code in <code>krupy/template.py</code> <pre><code>def verify_krupy_version(version_str: str) -&gt; None:\n    \"\"\"Raise an error if the current Krupy version is less than the given version.\n\n    Args:\n        version_str:\n            Minimal krupy version for the template.\n    \"\"\"\n    installed_version = krupy_version()\n\n    # Disable check when running krupy as editable installation\n    if installed_version == Version(\"0.0.0\"):\n        warn(\n            \"Cannot check Krupy version constraint.\",\n            UnknownKrupyVersionWarning,\n        )\n        return\n    parsed_min = Version(version_str)\n    if installed_version &lt; parsed_min:\n        raise UnsupportedVersionError(\n            f\"This template requires Krupy version &gt;= {version_str}, \"\n            f\"while your version of Krupy is {installed_version}.\"\n        )\n    if installed_version.major &gt; parsed_min.major:\n        warn(\n            f\"This template was designed for Krupy {version_str}, \"\n            f\"but your version of Krupy is {installed_version}. \"\n            f\"You could find some incompatibilities.\",\n            OldTemplateWarning,\n        )\n</code></pre>"},{"location":"reference/krupy/tools/","title":"tools.py","text":"<p>Some utility functions.</p>"},{"location":"reference/krupy/tools/#krupy.tools.Style","title":"<code> Style        </code>","text":"<p>Common color styles.</p> Source code in <code>krupy/tools.py</code> <pre><code>class Style:\n    \"\"\"Common color styles.\"\"\"\n\n    OK: IntSeq = [colorama.Fore.GREEN, colorama.Style.BRIGHT]\n    WARNING: IntSeq = [colorama.Fore.YELLOW, colorama.Style.BRIGHT]\n    IGNORE: IntSeq = [colorama.Fore.CYAN]\n    DANGER: IntSeq = [colorama.Fore.RED, colorama.Style.BRIGHT]\n    RESET: IntSeq = [colorama.Fore.RESET, colorama.Style.RESET_ALL]\n</code></pre>"},{"location":"reference/krupy/tools/#krupy.tools.cast_to_bool","title":"<code>cast_to_bool(value)</code>","text":"<p>Parse anything to bool.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Anything to be casted to a bool. Tries to be as smart as possible.</p> <ol> <li>Cast to number. Then: 0 = False; anything else = True.</li> <li>Find YAML booleans,     YAML nulls or <code>none</code> in it     and use it appropriately.</li> <li>Cast to boolean using standard python <code>bool(value)</code>.</li> </ol> required Source code in <code>krupy/tools.py</code> <pre><code>def cast_to_bool(value: Any) -&gt; bool:\n    \"\"\"Parse anything to bool.\n\n    Params:\n        value:\n            Anything to be casted to a bool. Tries to be as smart as possible.\n\n            1.  Cast to number. Then: 0 = False; anything else = True.\n            1.  Find [YAML booleans](https://yaml.org/type/bool.html),\n                [YAML nulls](https://yaml.org/type/null.html) or `none` in it\n                and use it appropriately.\n            1.  Cast to boolean using standard python `bool(value)`.\n    \"\"\"\n    # Assume it's a number\n    with suppress(TypeError, ValueError):\n        return bool(float(value))\n    # Assume it's a string\n    with suppress(AttributeError):\n        lower = value.lower()\n        if lower in {\"y\", \"yes\", \"t\", \"true\", \"on\"}:\n            return True\n        elif lower in {\"n\", \"no\", \"f\", \"false\", \"off\", \"~\", \"null\", \"none\"}:\n            return False\n    # Assume nothing\n    return bool(value)\n</code></pre>"},{"location":"reference/krupy/tools/#krupy.tools.cast_to_str","title":"<code>cast_to_str(value)</code>","text":"<p>Parse anything to str.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Anything to be casted to a str.</p> required Source code in <code>krupy/tools.py</code> <pre><code>def cast_to_str(value: Any) -&gt; str:\n    \"\"\"Parse anything to str.\n\n    Params:\n        value:\n            Anything to be casted to a str.\n    \"\"\"\n    if isinstance(value, str):\n        return value.value if isinstance(value, Enum) else value\n    if isinstance(value, (float, int, Decimal)):\n        return str(value)\n    if isinstance(value, (bytes, bytearray)):\n        return value.decode()\n    raise ValueError(f\"Could not convert {value} to string\")\n</code></pre>"},{"location":"reference/krupy/tools/#krupy.tools.force_str_end","title":"<code>force_str_end(original_str, end='\\n')</code>","text":"<p>Make sure a <code>original_str</code> ends with <code>end</code>.</p> <p>Parameters:</p> Name Type Description Default <code>original_str</code> <code>str</code> <p>String that you want to ensure ending.</p> required <code>end</code> <code>str</code> <p>String that must exist at the end of <code>original_str</code></p> <code>'\\n'</code> Source code in <code>krupy/tools.py</code> <pre><code>def force_str_end(original_str: str, end: str = \"\\n\") -&gt; str:\n    \"\"\"Make sure a `original_str` ends with `end`.\n\n    Params:\n        original_str: String that you want to ensure ending.\n        end: String that must exist at the end of `original_str`\n    \"\"\"\n    if not original_str.endswith(end):\n        return original_str + end\n    return original_str\n</code></pre>"},{"location":"reference/krupy/tools/#krupy.tools.handle_remove_readonly","title":"<code>handle_remove_readonly(func, path, exc)</code>","text":"<p>Handle errors when trying to remove read-only files through <code>shutil.rmtree</code>.</p> <p>On Windows, <code>shutil.rmtree</code> does not handle read-only files very well. This handler makes sure the given file is writable, then re-execute the given removal function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>An OS-dependant function used to remove a file.</p> required <code>path</code> <code>str</code> <p>The path to the file to remove.</p> required <code>exc</code> <code>Tuple[BaseException, OSError, traceback]</code> <p>A <code>sys.exc_info()</code> object.</p> required Source code in <code>krupy/tools.py</code> <pre><code>def handle_remove_readonly(\n    func: Callable, path: str, exc: Tuple[BaseException, OSError, TracebackType]\n) -&gt; None:\n    \"\"\"Handle errors when trying to remove read-only files through `shutil.rmtree`.\n\n    On Windows, `shutil.rmtree` does not handle read-only files very well. This handler\n    makes sure the given file is writable, then re-execute the given removal function.\n\n    Arguments:\n        func: An OS-dependant function used to remove a file.\n        path: The path to the file to remove.\n        exc: A `sys.exc_info()` object.\n    \"\"\"\n    excvalue = exc[1]\n    if func in (os.rmdir, os.remove, os.unlink) and excvalue.errno == errno.EACCES:\n        os.chmod(path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)  # 0777\n        func(path)\n    else:\n        raise\n</code></pre>"},{"location":"reference/krupy/tools/#krupy.tools.krupy_version","title":"<code>krupy_version()</code>","text":"<p>Get closest match for the installed krupy version.</p> Source code in <code>krupy/tools.py</code> <pre><code>def krupy_version() -&gt; Version:\n    \"\"\"Get closest match for the installed krupy version.\"\"\"\n    # Importing __version__ at the top of the module creates a circular import\n    # (\"cannot import name '__version__' from partially initialized module 'krupy'\"),\n    # so instead we do a lazy import here\n    from . import __version__\n\n    if __version__ != \"0.0.0\":\n        return Version(__version__)\n\n    # Get the installed package version otherwise, which is sometimes more specific\n    return Version(version(\"krupy\"))\n</code></pre>"},{"location":"reference/krupy/tools/#krupy.tools.printf","title":"<code>printf(action, msg='', style=None, indent=10, quiet=False, file_=&lt;colorama.ansitowin32.StreamWrapper object at 0x1071c1490&gt;)</code>","text":"<p>Print string with common format.</p> Source code in <code>krupy/tools.py</code> <pre><code>def printf(\n    action: str,\n    msg: Any = \"\",\n    style: Optional[IntSeq] = None,\n    indent: int = 10,\n    quiet: Union[bool, StrictBool] = False,\n    file_: TextIO = sys.stdout,\n) -&gt; Optional[str]:\n    \"\"\"Print string with common format.\"\"\"\n    if quiet:\n        return None  # HACK: Satisfy MyPy\n    _msg = str(msg)\n    action = action.rjust(indent, \" \")\n    if not style:\n        return action + _msg\n\n    out = style + [action] + Style.RESET + [INDENT, _msg]  # type: ignore\n    print(*out, sep=\"\", file=file_)\n    return None  # HACK: Satisfy MyPy\n</code></pre>"},{"location":"reference/krupy/tools/#krupy.tools.printf_exception","title":"<code>printf_exception(e, action, msg='', indent=0, quiet=False)</code>","text":"<p>Print exception with common format.</p> Source code in <code>krupy/tools.py</code> <pre><code>def printf_exception(\n    e: Exception, action: str, msg: str = \"\", indent: int = 0, quiet: bool = False\n) -&gt; None:\n    \"\"\"Print exception with common format.\"\"\"\n    if not quiet:\n        print(\"\", file=sys.stderr)\n        printf(action, msg=msg, style=Style.DANGER, indent=indent, file_=sys.stderr)\n        print(HLINE, file=sys.stderr)\n        print(e, file=sys.stderr)\n        print(HLINE, file=sys.stderr)\n</code></pre>"},{"location":"reference/krupy/tools/#krupy.tools.readlink","title":"<code>readlink(link)</code>","text":"<p>A custom version of os.readlink/pathlib.Path.readlink.</p> <p>pathlib.Path.readlink is what we ideally would want to use, but it is only available on python&gt;=3.9.</p> Source code in <code>krupy/tools.py</code> <pre><code>def readlink(link: Path) -&gt; Path:\n    \"\"\"A custom version of os.readlink/pathlib.Path.readlink.\n\n    pathlib.Path.readlink is what we ideally would want to use, but it is only available on python&gt;=3.9.\n    \"\"\"\n    if sys.version_info &gt;= (3, 9):\n        return link.readlink()\n    else:\n        return Path(os.readlink(link))\n</code></pre>"},{"location":"reference/krupy/types/","title":"types.py","text":"<p>Complex types, annotations, validators.</p>"},{"location":"reference/krupy/types/#krupy.types.path_is_absolute","title":"<code>path_is_absolute(value)</code>","text":"<p>Require absolute paths in an argument.</p> Source code in <code>krupy/types.py</code> <pre><code>def path_is_absolute(value: Path) -&gt; Path:\n    \"\"\"Require absolute paths in an argument.\"\"\"\n    if not value.is_absolute():\n        from .errors import PathNotAbsoluteError\n\n        raise PathNotAbsoluteError(path=value)\n    return value\n</code></pre>"},{"location":"reference/krupy/types/#krupy.types.path_is_relative","title":"<code>path_is_relative(value)</code>","text":"<p>Require relative paths in an argument.</p> Source code in <code>krupy/types.py</code> <pre><code>def path_is_relative(value: Path) -&gt; Path:\n    \"\"\"Require relative paths in an argument.\"\"\"\n    if value.is_absolute():\n        from .errors import PathNotRelativeError\n\n        raise PathNotRelativeError(path=value)\n    return value\n</code></pre>"},{"location":"reference/krupy/user_data/","title":"user_data.py","text":"<p>Functions used to load user data.</p>"},{"location":"reference/krupy/user_data/#krupy.user_data.AnswersMap","title":"<code> AnswersMap        </code>  <code>dataclass</code>","text":"<p>Object that gathers answers from different sources.</p> <p>Attributes:</p> Name Type Description <code>user</code> <code>Dict[str, Any]</code> <p>Answers provided by the user, interactively.</p> <code>init</code> <code>Dict[str, Any]</code> <p>Answers provided on init.</p> <p>This will hold those answers that come from <code>--data</code> in CLI mode.</p> <p>See data.</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Data used to be able to reproduce the template.</p> <p>It comes from krupy.template.Template.metadata.</p> <code>last</code> <code>Dict[str, Any]</code> <p>Data from the answers file.</p> <code>user_defaults</code> <code>Dict[str, Any]</code> <p>Default data from the user e.g. previously completed and restored data.</p> <p>See krupy.main.Worker.</p> Source code in <code>krupy/user_data.py</code> <pre><code>@dataclass\nclass AnswersMap:\n    \"\"\"Object that gathers answers from different sources.\n\n    Attributes:\n        user:\n            Answers provided by the user, interactively.\n\n        init:\n            Answers provided on init.\n\n            This will hold those answers that come from `--data` in\n            CLI mode.\n\n            See [data][].\n\n        metadata:\n            Data used to be able to reproduce the template.\n\n            It comes from [krupy.template.Template.metadata][].\n\n        last:\n            Data from [the answers file][the-krupy-answersyml-file].\n\n        user_defaults:\n            Default data from the user e.g. previously completed and restored data.\n\n            See [krupy.main.Worker][].\n    \"\"\"\n\n    # Private\n    hidden: Set[str] = field(default_factory=set, init=False)\n\n    # Public\n    user: AnyByStrDict = field(default_factory=dict)\n    init: AnyByStrDict = field(default_factory=dict)\n    metadata: AnyByStrDict = field(default_factory=dict)\n    last: AnyByStrDict = field(default_factory=dict)\n    user_defaults: AnyByStrDict = field(default_factory=dict)\n\n    @property\n    def combined(self) -&gt; Mapping[str, Any]:\n        \"\"\"Answers combined from different sources, sorted by priority.\"\"\"\n        return dict(\n            ChainMap(\n                self.user,\n                self.init,\n                self.metadata,\n                self.last,\n                self.user_defaults,\n                DEFAULT_DATA,\n            )\n        )\n\n    def old_commit(self) -&gt; OptStr:\n        \"\"\"Commit when the project was updated from this template the last time.\"\"\"\n        return self.last.get(\"_commit\")\n\n    def hide(self, key: str) -&gt; None:\n        \"\"\"Remove an answer by key.\"\"\"\n        self.hidden.add(key)\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.AnswersMap.combined","title":"<code>combined: Mapping[str, Any]</code>  <code>property</code> <code>readonly</code>","text":"<p>Answers combined from different sources, sorted by priority.</p>"},{"location":"reference/krupy/user_data/#krupy.user_data.AnswersMap.hide","title":"<code>hide(self, key)</code>","text":"<p>Remove an answer by key.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def hide(self, key: str) -&gt; None:\n    \"\"\"Remove an answer by key.\"\"\"\n    self.hidden.add(key)\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.AnswersMap.old_commit","title":"<code>old_commit(self)</code>","text":"<p>Commit when the project was updated from this template the last time.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def old_commit(self) -&gt; OptStr:\n    \"\"\"Commit when the project was updated from this template the last time.\"\"\"\n    return self.last.get(\"_commit\")\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.Question","title":"<code> Question        </code>  <code>dataclass</code>","text":"<p>One question asked to the user.</p> <p>All attributes are init kwargs.</p> <p>Attributes:</p> Name Type Description <code>choices</code> <code>Union[Sequence[Any], Dict[Any, Any]]</code> <p>Selections available for the user if the question requires them. Can be templated.</p> <code>default</code> <code>Any</code> <p>Default value presented to the user to make it easier to respond. Can be templated.</p> <code>help</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Additional text printed to the user, explaining the purpose of this question. Can be templated.</p> <code>multiline</code> <code>Union[str, bool]</code> <p>Indicates if the question should allow multiline input. Defaults to <code>True</code> for JSON and YAML questions, and to <code>False</code> otherwise. Only meaningful for str-based questions. Can be templated.</p> <code>placeholder</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Text that appears if there's nothing written in the input field, but disappears as soon as the user writes anything. Can be templated.</p> <code>secret</code> <code>bool</code> <p>Indicates if the question should be removed from the answers file. If the question type is str, it will hide user input on the screen by displaying asterisks: <code>****</code>.</p> <code>type_name</code> <p>The type of question. Affects the rendering, validation and filtering. Can be templated.</p> <code>var_name</code> <code>str</code> <p>Question name in the answers dict.</p> <code>validator</code> <code>str</code> <p>Jinja template with which to validate the user input. This template will be rendered with the combined answers as variables; it should render nothing if the value is valid, and an error message to show to the user otherwise.</p> <code>when</code> <code>Union[str, bool]</code> <p>Condition that, if <code>False</code>, skips the question. Can be templated. If it is a boolean, it is used directly. If it is a str, it is converted to boolean using a parser similar to YAML, but only for boolean values.</p> <code>multiselect</code> <code>bool</code> <p>Indicates if the question supports multiple answers. Only supported by choices type.</p> <code>qmark</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Prefix displayed in front of questions</p> <code>style</code> <code>Dict[str, str]</code> <p>Question formmating style</p> Source code in <code>krupy/user_data.py</code> <pre><code>@dataclass(config=ConfigDict(arbitrary_types_allowed=True))\nclass Question:\n    \"\"\"One question asked to the user.\n\n    All attributes are init kwargs.\n\n    Attributes:\n        choices:\n            Selections available for the user if the question requires them.\n            Can be templated.\n\n        default:\n            Default value presented to the user to make it easier to respond.\n            Can be templated.\n\n        help:\n            Additional text printed to the user, explaining the purpose of\n            this question. Can be templated.\n\n        multiline:\n            Indicates if the question should allow multiline input. Defaults\n            to `True` for JSON and YAML questions, and to `False` otherwise.\n            Only meaningful for str-based questions. Can be templated.\n\n        placeholder:\n            Text that appears if there's nothing written in the input field,\n            but disappears as soon as the user writes anything. Can be templated.\n\n        secret:\n            Indicates if the question should be removed from the answers file.\n            If the question type is str, it will hide user input on the screen\n            by displaying asterisks: `****`.\n\n        type_name:\n            The type of question. Affects the rendering, validation and filtering.\n            Can be templated.\n\n        var_name:\n            Question name in the answers dict.\n\n        validator:\n            Jinja template with which to validate the user input. This template\n            will be rendered with the combined answers as variables; it should\n            render *nothing* if the value is valid, and an error message to show\n            to the user otherwise.\n\n        when:\n            Condition that, if `False`, skips the question. Can be templated.\n            If it is a boolean, it is used directly. If it is a str, it is\n            converted to boolean using a parser similar to YAML, but only for\n            boolean values.\n\n        multiselect:\n            Indicates if the question supports multiple answers.\n            Only supported by choices type.\n\n        qmark:\n            Prefix displayed in front of questions\n\n        style:\n            Question formmating style\n    \"\"\"\n\n    var_name: str\n    answers: AnswersMap\n    jinja_env: SandboxedEnvironment\n    envquestions: AnyByStrDict\n    choices: Union[Sequence[Any], Dict[Any, Any]] = field(default_factory=list)\n    default: Any = MISSING\n    help: AnyFormattedText = None\n    multiline: Union[str, bool] = False\n    placeholder: AnyFormattedText = None\n    secret: bool = False\n    type: str = Field(default=\"\", validate_default=True)\n    validator: str = \"\"\n    when: Union[str, bool] = True\n    multiselect: bool = False\n    qmark: AnyFormattedText = None\n    style: Dict[str, str] = field(default_factory=dict)\n\n    @field_validator(\"var_name\")\n    @classmethod\n    def _check_var_name(cls, v: str):\n        if v in DEFAULT_DATA:\n            raise ValueError(\"Invalid question name\")\n        return v\n\n    @field_validator(\"type\")\n    @classmethod\n    def _check_type(cls, v: str, info: ValidationInfo):\n        if v == \"\":\n            default_type_name = type(info.data.get(\"default\")).__name__\n            v = default_type_name if default_type_name in CAST_STR_TO_NATIVE else \"yaml\"\n        return v\n\n    @field_validator(\"secret\")\n    @classmethod\n    def _check_secret_question_default_value(cls, v: bool, info: ValidationInfo):\n        if v and info.data[\"default\"] is MISSING:\n            raise ValueError(\"Secret question requires a default value\")\n        return v\n\n    def cast_answer(self, answer: Any) -&gt; Any:\n        \"\"\"Cast answer to expected type.\"\"\"\n        type_name = self.get_type_name()\n        type_fn = CAST_STR_TO_NATIVE[type_name]\n        # Only JSON or YAML questions support `None` as an answer\n        if answer is None and type_name not in {\"json\", \"yaml\"}:\n            raise InvalidTypeError(\n                f'Invalid answer \"{answer}\" of type \"{type(answer)}\" '\n                f'to question \"{self.var_name}\" of type \"{type_name}\"'\n            )\n        try:\n            return type_fn(answer)\n        except (TypeError, AttributeError) as error:\n            # JSON or YAML failed because it wasn't a string; no need to convert\n            if type_name in {\"json\", \"yaml\"}:\n                return answer\n            raise InvalidTypeError from error\n\n    def get_default(self) -&gt; Any:\n        \"\"\"Get the default value for this question, casted to its expected type.\"\"\"\n        try:\n            result = self.answers.init[self.var_name]\n        except KeyError:\n            try:\n                result = self.answers.last[self.var_name]\n            except KeyError:\n                try:\n                    result = self.answers.user_defaults[self.var_name]\n                except KeyError:\n                    if self.default is MISSING:\n                        return MISSING\n                    result = self.render_value(self.default)\n        result = self.cast_answer(result)\n        return result\n\n    def get_default_rendered(self) -&gt; Union[bool, str, Choice, None, MissingType]:\n        \"\"\"Get default answer rendered for the questionary lib.\n\n        The questionary lib expects some specific data types, and returns\n        it when the user answers. Sometimes you need to compare the response\n        to the rendered one, or viceversa.\n\n        This helper allows such usages.\n        \"\"\"\n        default = self.get_default()\n        if default is MISSING:\n            return MISSING\n        # If there are choices, return the one that matches the expressed default\n        if self.choices:\n            for choice in self._formatted_choices:\n                if choice.value == default:\n                    return choice\n            return None\n        # Yes/No questions expect and return bools\n        if isinstance(default, bool) and self.get_type_name() == \"bool\":\n            return default\n        # Emptiness is expressed as an empty str\n        if default is None:\n            return \"\"\n        # JSON and YAML dumped depending on multiline setting\n        if self.get_type_name() == \"json\":\n            return json.dumps(default, indent=2 if self.get_multiline() else None)\n        if self.get_type_name() == \"yaml\":\n            return yaml.safe_dump(\n                default, default_flow_style=not self.get_multiline(), width=2147483647\n            ).strip()\n        # All other data has to be str\n        return str(default)\n\n    @cached_property\n    def _formatted_choices(self) -&gt; Sequence[Choice]:\n        \"\"\"Obtain choices rendered and properly formatted.\"\"\"\n        result = []\n        choices = self.choices\n        if isinstance(self.choices, dict):\n            choices = list(self.choices.items())\n        for choice in choices:\n            # If a choice is a value pair\n            if isinstance(choice, (tuple, list)):\n                name, value = choice\n            # If a choice is a single value\n            else:\n                name = value = choice\n            # The name must always be a str\n            name = str(self.render_value(name))\n            # Extract the extended syntax for dict-like (dict-style or\n            # tuple-style) choices if applicable\n            disabled = \"\"\n            if isinstance(choice, (tuple, list)) and isinstance(value, dict):\n                if \"value\" not in value:\n                    raise KeyError(\"Property 'value' is required\")\n                if \"validator\" in value and not isinstance(value[\"validator\"], str):\n                    raise ValueError(\"Property 'validator' must be a string\")\n                disabled = self.render_value(value.get(\"validator\", \"\"))\n                value = value[\"value\"]\n            # The value can be templated\n            value = self.render_value(value)\n            c = Choice(name, value, disabled=disabled)\n            # Try to cast the value according to the question's type to raise\n            # an error in case the value is incompatible.\n            self.cast_answer(c.value)\n            result.append(c)\n        return result\n\n    def get_mark(self) -&gt; AnyFormattedText:\n        \"\"\"Get the qmark that will be printed to the user.\"\"\"\n        if self.qmark:\n            if isinstance(self.qmark, list):\n                for i, x in self.qmark:\n                    temp = x\n                    temp[1] = self.render_value(temp[1])\n                    self.qmark[i] = temp\n                return self.qmark\n            return self.render_value(self.qmark)\n        if self.secret:\n            return \"\ud83d\udd75\ufe0f\"\n        return DEFAULT_QUESTION_PREFIX\n\n    def get_placeholder(self) -&gt; AnyFormattedText:\n        \"\"\"Render and obtain the placeholder.\"\"\"\n        if self.placeholder:\n            tokens = []\n            if isinstance(self.placeholder, list):\n                for x in self.placeholder:\n                    tokens.append((x[0], \"{} \".format(self.render_value(x[1]))))\n            else:\n                tokens.append((\"class:placeholder\", \"{} \".format(self.render_value(self.placeholder))))\n            return tokens\n        return None\n\n    def get_message(self) -&gt; AnyFormattedText:\n        \"\"\"Get the message that will be printed to the user.\"\"\"\n        answer_type = self.get_type_name() if self.envquestions['is_visible_type'] else None\n        default_value = self.get_default() if self.envquestions['is_visible_default_value'] else None\n        message = []\n        if self.help:\n            if isinstance(self.help, list):\n                for i, x in self.help:\n                    temp = x\n                    temp[1] = self.render_value(temp[1])\n                    self.help[i] = temp\n                if isinstance(answer_type, str) and len(answer_type.strip()) &gt; 0:\n                    self.help.append((\"class:type\", f\"({answer_type})\"))\n                if default_value is not None and default_value is not MISSING:\n                    self.help.append((\"class:default\", f\"[{default_value}]\"))\n                return self.help\n            else:\n                message.append((\"class:question\", self.render_value(self.help)))\n        else:\n            message.append((\"class:question\", self.var_name))\n\n        if isinstance(answer_type, str) and len(answer_type.strip()) &gt; 0:\n            message.append((\"class:type\", f\"({answer_type})\"))\n        if default_value is not None and default_value is not MISSING:\n            message.append((\"class:default\", f\"[{default_value}]\"))\n        return message\n\n    def get_questionary_structure(self, questionQCount: Any) -&gt; AnyByStrDict:\n        \"\"\"Get the question in a format that the questionary lib understands.\"\"\"\n        lexer = None\n        result: AnyByStrDict = {\n            \"filter\": self.cast_answer,\n            \"message\": self.get_message(),\n            \"mouse_support\": True,\n            \"name\": self.var_name,\n            \"qmark\": self.get_mark() if self.envquestions['is_visible_mark'] else None,\n            \"when\": lambda _: self.get_when(),\n            \"qcount\": questionQCount if self.envquestions['is_visible_count'] else None,\n            \"style\": merge_styles_default([DEFAULT_STYLE, Style.from_dict(self.envquestions['style']), Style.from_dict(self.style)]),\n        }\n        default = self.get_default_rendered()\n        if default is not MISSING:\n            result[\"default\"] = default\n        questionary_type = \"input\"\n        type_name = self.get_type_name()\n        if type_name == \"bool\":\n            questionary_type = \"confirm\"\n            # For backwards compatibility\n            if default is MISSING:\n                result[\"default\"] = False\n        if self.choices:\n            if self.multiselect:\n                questionary_type = \"checkbox\"\n            else:\n                questionary_type = \"select\"\n            result[\"choices\"] = self._formatted_choices\n        if questionary_type == \"input\":\n            if self.secret:\n                questionary_type = \"password\"\n            elif type_name == \"yaml\":\n                lexer = PygmentsLexer(YamlLexer)\n            elif type_name == \"json\":\n                lexer = PygmentsLexer(JsonLexer)\n            if lexer:\n                result[\"lexer\"] = lexer\n            result[\"multiline\"] = self.get_multiline()\n            placeholder = self.get_placeholder()\n            if placeholder:\n                result[\"placeholder\"] = placeholder\n            result[\"validate\"] = self.validate_answer\n        result.update({\"type\": questionary_type})\n        return result\n\n    def get_type_name(self) -&gt; str:\n        \"\"\"Render the type name and return it.\"\"\"\n        type_name = self.render_value(self.type)\n        if type_name not in CAST_STR_TO_NATIVE:\n            raise InvalidTypeError(\n                f'Unsupported type \"{type_name}\" in question \"{self.var_name}\"'\n            )\n        return type_name\n\n    def get_multiline(self) -&gt; bool:\n        \"\"\"Get the value for multiline.\"\"\"\n        return cast_to_bool(self.render_value(self.multiline))\n\n    def validate_answer(self, answer) -&gt; bool:\n        \"\"\"Validate user answer.\"\"\"\n        try:\n            ans = self.parse_answer(answer)\n        except Exception:\n            return False\n\n        try:\n            err_msg = self.render_value(self.validator, {self.var_name: ans}).strip()\n        except Exception as error:\n            raise ValidationError(message=str(error)) from error\n        if err_msg:\n            raise ValidationError(message=err_msg)\n        return True\n\n    def get_when(self) -&gt; bool:\n        \"\"\"Get skip condition for question.\"\"\"\n        return cast_to_bool(self.render_value(self.when))\n\n    def render_value(\n        self, value: Any, extra_answers: Optional[AnyByStrDict] = None\n    ) -&gt; str:\n        \"\"\"Render a single templated value using Jinja.\n\n        If the value cannot be used as a template, it will be returned as is.\n        `extra_answers` are combined self `self.answers.combined` when rendering\n        the template.\n        \"\"\"\n        try:\n            template = self.jinja_env.from_string(value)\n        except TypeError:\n            # value was not a string\n            return value\n        try:\n            return template.render({**self.answers.combined, **(extra_answers or {})})\n        except UndefinedError as error:\n            raise UserMessageError(str(error)) from error\n\n    def parse_answer(self, answer: Any) -&gt; Any:\n        \"\"\"Parse the answer according to the question's type.\"\"\"\n        ans = self.cast_answer(answer)\n        choices = self._formatted_choices\n        if not choices:\n            return ans\n        choice_error = \"\"\n        for choice in choices:\n            if ans == self.cast_answer(choice.value):\n                if not choice.disabled:\n                    return ans\n                if not choice_error:\n                    choice_error = choice.disabled\n        raise ValueError(\n            f\"Invalid choice: {choice_error}\" if choice_error else \"Invalid choice\"\n        )\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.Question.cast_answer","title":"<code>cast_answer(self, answer)</code>","text":"<p>Cast answer to expected type.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def cast_answer(self, answer: Any) -&gt; Any:\n    \"\"\"Cast answer to expected type.\"\"\"\n    type_name = self.get_type_name()\n    type_fn = CAST_STR_TO_NATIVE[type_name]\n    # Only JSON or YAML questions support `None` as an answer\n    if answer is None and type_name not in {\"json\", \"yaml\"}:\n        raise InvalidTypeError(\n            f'Invalid answer \"{answer}\" of type \"{type(answer)}\" '\n            f'to question \"{self.var_name}\" of type \"{type_name}\"'\n        )\n    try:\n        return type_fn(answer)\n    except (TypeError, AttributeError) as error:\n        # JSON or YAML failed because it wasn't a string; no need to convert\n        if type_name in {\"json\", \"yaml\"}:\n            return answer\n        raise InvalidTypeError from error\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.Question.get_default","title":"<code>get_default(self)</code>","text":"<p>Get the default value for this question, casted to its expected type.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def get_default(self) -&gt; Any:\n    \"\"\"Get the default value for this question, casted to its expected type.\"\"\"\n    try:\n        result = self.answers.init[self.var_name]\n    except KeyError:\n        try:\n            result = self.answers.last[self.var_name]\n        except KeyError:\n            try:\n                result = self.answers.user_defaults[self.var_name]\n            except KeyError:\n                if self.default is MISSING:\n                    return MISSING\n                result = self.render_value(self.default)\n    result = self.cast_answer(result)\n    return result\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.Question.get_default_rendered","title":"<code>get_default_rendered(self)</code>","text":"<p>Get default answer rendered for the questionary lib.</p> <p>The questionary lib expects some specific data types, and returns it when the user answers. Sometimes you need to compare the response to the rendered one, or viceversa.</p> <p>This helper allows such usages.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def get_default_rendered(self) -&gt; Union[bool, str, Choice, None, MissingType]:\n    \"\"\"Get default answer rendered for the questionary lib.\n\n    The questionary lib expects some specific data types, and returns\n    it when the user answers. Sometimes you need to compare the response\n    to the rendered one, or viceversa.\n\n    This helper allows such usages.\n    \"\"\"\n    default = self.get_default()\n    if default is MISSING:\n        return MISSING\n    # If there are choices, return the one that matches the expressed default\n    if self.choices:\n        for choice in self._formatted_choices:\n            if choice.value == default:\n                return choice\n        return None\n    # Yes/No questions expect and return bools\n    if isinstance(default, bool) and self.get_type_name() == \"bool\":\n        return default\n    # Emptiness is expressed as an empty str\n    if default is None:\n        return \"\"\n    # JSON and YAML dumped depending on multiline setting\n    if self.get_type_name() == \"json\":\n        return json.dumps(default, indent=2 if self.get_multiline() else None)\n    if self.get_type_name() == \"yaml\":\n        return yaml.safe_dump(\n            default, default_flow_style=not self.get_multiline(), width=2147483647\n        ).strip()\n    # All other data has to be str\n    return str(default)\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.Question.get_mark","title":"<code>get_mark(self)</code>","text":"<p>Get the qmark that will be printed to the user.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def get_mark(self) -&gt; AnyFormattedText:\n    \"\"\"Get the qmark that will be printed to the user.\"\"\"\n    if self.qmark:\n        if isinstance(self.qmark, list):\n            for i, x in self.qmark:\n                temp = x\n                temp[1] = self.render_value(temp[1])\n                self.qmark[i] = temp\n            return self.qmark\n        return self.render_value(self.qmark)\n    if self.secret:\n        return \"\ud83d\udd75\ufe0f\"\n    return DEFAULT_QUESTION_PREFIX\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.Question.get_message","title":"<code>get_message(self)</code>","text":"<p>Get the message that will be printed to the user.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def get_message(self) -&gt; AnyFormattedText:\n    \"\"\"Get the message that will be printed to the user.\"\"\"\n    answer_type = self.get_type_name() if self.envquestions['is_visible_type'] else None\n    default_value = self.get_default() if self.envquestions['is_visible_default_value'] else None\n    message = []\n    if self.help:\n        if isinstance(self.help, list):\n            for i, x in self.help:\n                temp = x\n                temp[1] = self.render_value(temp[1])\n                self.help[i] = temp\n            if isinstance(answer_type, str) and len(answer_type.strip()) &gt; 0:\n                self.help.append((\"class:type\", f\"({answer_type})\"))\n            if default_value is not None and default_value is not MISSING:\n                self.help.append((\"class:default\", f\"[{default_value}]\"))\n            return self.help\n        else:\n            message.append((\"class:question\", self.render_value(self.help)))\n    else:\n        message.append((\"class:question\", self.var_name))\n\n    if isinstance(answer_type, str) and len(answer_type.strip()) &gt; 0:\n        message.append((\"class:type\", f\"({answer_type})\"))\n    if default_value is not None and default_value is not MISSING:\n        message.append((\"class:default\", f\"[{default_value}]\"))\n    return message\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.Question.get_multiline","title":"<code>get_multiline(self)</code>","text":"<p>Get the value for multiline.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def get_multiline(self) -&gt; bool:\n    \"\"\"Get the value for multiline.\"\"\"\n    return cast_to_bool(self.render_value(self.multiline))\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.Question.get_placeholder","title":"<code>get_placeholder(self)</code>","text":"<p>Render and obtain the placeholder.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def get_placeholder(self) -&gt; AnyFormattedText:\n    \"\"\"Render and obtain the placeholder.\"\"\"\n    if self.placeholder:\n        tokens = []\n        if isinstance(self.placeholder, list):\n            for x in self.placeholder:\n                tokens.append((x[0], \"{} \".format(self.render_value(x[1]))))\n        else:\n            tokens.append((\"class:placeholder\", \"{} \".format(self.render_value(self.placeholder))))\n        return tokens\n    return None\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.Question.get_questionary_structure","title":"<code>get_questionary_structure(self, questionQCount)</code>","text":"<p>Get the question in a format that the questionary lib understands.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def get_questionary_structure(self, questionQCount: Any) -&gt; AnyByStrDict:\n    \"\"\"Get the question in a format that the questionary lib understands.\"\"\"\n    lexer = None\n    result: AnyByStrDict = {\n        \"filter\": self.cast_answer,\n        \"message\": self.get_message(),\n        \"mouse_support\": True,\n        \"name\": self.var_name,\n        \"qmark\": self.get_mark() if self.envquestions['is_visible_mark'] else None,\n        \"when\": lambda _: self.get_when(),\n        \"qcount\": questionQCount if self.envquestions['is_visible_count'] else None,\n        \"style\": merge_styles_default([DEFAULT_STYLE, Style.from_dict(self.envquestions['style']), Style.from_dict(self.style)]),\n    }\n    default = self.get_default_rendered()\n    if default is not MISSING:\n        result[\"default\"] = default\n    questionary_type = \"input\"\n    type_name = self.get_type_name()\n    if type_name == \"bool\":\n        questionary_type = \"confirm\"\n        # For backwards compatibility\n        if default is MISSING:\n            result[\"default\"] = False\n    if self.choices:\n        if self.multiselect:\n            questionary_type = \"checkbox\"\n        else:\n            questionary_type = \"select\"\n        result[\"choices\"] = self._formatted_choices\n    if questionary_type == \"input\":\n        if self.secret:\n            questionary_type = \"password\"\n        elif type_name == \"yaml\":\n            lexer = PygmentsLexer(YamlLexer)\n        elif type_name == \"json\":\n            lexer = PygmentsLexer(JsonLexer)\n        if lexer:\n            result[\"lexer\"] = lexer\n        result[\"multiline\"] = self.get_multiline()\n        placeholder = self.get_placeholder()\n        if placeholder:\n            result[\"placeholder\"] = placeholder\n        result[\"validate\"] = self.validate_answer\n    result.update({\"type\": questionary_type})\n    return result\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.Question.get_type_name","title":"<code>get_type_name(self)</code>","text":"<p>Render the type name and return it.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def get_type_name(self) -&gt; str:\n    \"\"\"Render the type name and return it.\"\"\"\n    type_name = self.render_value(self.type)\n    if type_name not in CAST_STR_TO_NATIVE:\n        raise InvalidTypeError(\n            f'Unsupported type \"{type_name}\" in question \"{self.var_name}\"'\n        )\n    return type_name\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.Question.get_when","title":"<code>get_when(self)</code>","text":"<p>Get skip condition for question.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def get_when(self) -&gt; bool:\n    \"\"\"Get skip condition for question.\"\"\"\n    return cast_to_bool(self.render_value(self.when))\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.Question.parse_answer","title":"<code>parse_answer(self, answer)</code>","text":"<p>Parse the answer according to the question's type.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def parse_answer(self, answer: Any) -&gt; Any:\n    \"\"\"Parse the answer according to the question's type.\"\"\"\n    ans = self.cast_answer(answer)\n    choices = self._formatted_choices\n    if not choices:\n        return ans\n    choice_error = \"\"\n    for choice in choices:\n        if ans == self.cast_answer(choice.value):\n            if not choice.disabled:\n                return ans\n            if not choice_error:\n                choice_error = choice.disabled\n    raise ValueError(\n        f\"Invalid choice: {choice_error}\" if choice_error else \"Invalid choice\"\n    )\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.Question.render_value","title":"<code>render_value(self, value, extra_answers=None)</code>","text":"<p>Render a single templated value using Jinja.</p> <p>If the value cannot be used as a template, it will be returned as is. <code>extra_answers</code> are combined self <code>self.answers.combined</code> when rendering the template.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def render_value(\n    self, value: Any, extra_answers: Optional[AnyByStrDict] = None\n) -&gt; str:\n    \"\"\"Render a single templated value using Jinja.\n\n    If the value cannot be used as a template, it will be returned as is.\n    `extra_answers` are combined self `self.answers.combined` when rendering\n    the template.\n    \"\"\"\n    try:\n        template = self.jinja_env.from_string(value)\n    except TypeError:\n        # value was not a string\n        return value\n    try:\n        return template.render({**self.answers.combined, **(extra_answers or {})})\n    except UndefinedError as error:\n        raise UserMessageError(str(error)) from error\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.Question.validate_answer","title":"<code>validate_answer(self, answer)</code>","text":"<p>Validate user answer.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def validate_answer(self, answer) -&gt; bool:\n    \"\"\"Validate user answer.\"\"\"\n    try:\n        ans = self.parse_answer(answer)\n    except Exception:\n        return False\n\n    try:\n        err_msg = self.render_value(self.validator, {self.var_name: ans}).strip()\n    except Exception as error:\n        raise ValidationError(message=str(error)) from error\n    if err_msg:\n        raise ValidationError(message=err_msg)\n    return True\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.load_answersfile_data","title":"<code>load_answersfile_data(dst_path, answers_file=None)</code>","text":"<p>Load answers data from a <code>$dst_path/$answers_file</code> file if it exists.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def load_answersfile_data(\n    dst_path: StrOrPath,\n    answers_file: OptStrOrPath = None,\n) -&gt; AnyByStrDict:\n    \"\"\"Load answers data from a `$dst_path/$answers_file` file if it exists.\"\"\"\n    try:\n        with open(Path(dst_path) / (answers_file or \".krupy-answers.yml\")) as fd:\n            return yaml.safe_load(fd)\n    except FileNotFoundError:\n        return {}\n</code></pre>"},{"location":"reference/krupy/user_data/#krupy.user_data.parse_yaml_string","title":"<code>parse_yaml_string(string)</code>","text":"<p>Parse a YAML string and raise a ValueError if parsing failed.</p> <p>This method is needed because prompt requires a <code>ValueError</code> to repeat failed questions.</p> Source code in <code>krupy/user_data.py</code> <pre><code>def parse_yaml_string(string: str) -&gt; Any:\n    \"\"\"Parse a YAML string and raise a ValueError if parsing failed.\n\n    This method is needed because [prompt]() requires a ``ValueError``\n    to repeat failed questions.\n    \"\"\"\n    try:\n        return yaml.safe_load(string)\n    except yaml.error.YAMLError as error:\n        raise ValueError(str(error))\n</code></pre>"},{"location":"reference/krupy/vcs/","title":"vcs.py","text":"<p>Utilities related to VCS.</p>"},{"location":"reference/krupy/vcs/#krupy.vcs.checkout_latest_tag","title":"<code>checkout_latest_tag(local_repo, use_prereleases=False)</code>","text":"<p>Checkout latest git tag and check it out, sorted by PEP 440.</p> <p>Parameters:</p> Name Type Description Default <code>local_repo</code> <code>Union[str, pathlib.Path]</code> <p>A git repository in the local filesystem.</p> required <code>use_prereleases</code> <code>Optional[bool]</code> <p>If <code>False</code>, skip prerelease git tags.</p> <code>False</code> Source code in <code>krupy/vcs.py</code> <pre><code>def checkout_latest_tag(local_repo: StrOrPath, use_prereleases: OptBool = False) -&gt; str:\n    \"\"\"Checkout latest git tag and check it out, sorted by PEP 440.\n\n    Parameters:\n        local_repo:\n            A git repository in the local filesystem.\n        use_prereleases:\n            If `False`, skip prerelease git tags.\n    \"\"\"\n    git = get_git()\n    with local.cwd(local_repo):\n        all_tags = filter(valid_version, git(\"tag\").split())\n        if not use_prereleases:\n            all_tags = filter(\n                lambda tag: not version.parse(tag).is_prerelease, all_tags\n            )\n        sorted_tags = sorted(all_tags, key=version.parse, reverse=True)\n        try:\n            latest_tag = str(sorted_tags[0])\n        except IndexError:\n            print(\n                colors.warn | \"No git tags found in template; using HEAD as ref\",\n                file=sys.stderr,\n            )\n            latest_tag = \"HEAD\"\n        git(\"checkout\", \"--force\", latest_tag)\n        git(\"submodule\", \"update\", \"--checkout\", \"--init\", \"--recursive\", \"--force\")\n        return latest_tag\n</code></pre>"},{"location":"reference/krupy/vcs/#krupy.vcs.clone","title":"<code>clone(url, ref=None)</code>","text":"<p>Clone repo into some temporary destination.</p> <p>Includes dirty changes for local templates by copying into a temp directory and applying a wip commit there.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Git-parseable URL of the repo. As returned by get_repo.</p> required <code>ref</code> <code>Optional[str]</code> <p>Reference to checkout. For Git repos, defaults to <code>HEAD</code>.</p> <code>None</code> Source code in <code>krupy/vcs.py</code> <pre><code>def clone(url: str, ref: OptStr = None) -&gt; str:\n    \"\"\"Clone repo into some temporary destination.\n\n    Includes dirty changes for local templates by copying into a temp\n    directory and applying a wip commit there.\n\n    Args:\n        url:\n            Git-parseable URL of the repo. As returned by\n            [get_repo][krupy.vcs.get_repo].\n        ref:\n            Reference to checkout. For Git repos, defaults to `HEAD`.\n    \"\"\"\n    git = get_git()\n    git_version = get_git_version()\n    location = mkdtemp(prefix=f\"{__name__}.clone.\")\n    _clone = git[\"clone\", \"--no-checkout\", url, location]\n    # Faster clones if possible\n    if git_version &gt;= Version(\"2.27\"):\n        url_match = re.match(\"(file://)?(.*)\", url)\n        if url_match is not None:\n            file_url = url_match.groups()[-1]\n        else:\n            file_url = url\n        if is_git_shallow_repo(file_url):\n            warn(\n                f\"The repository '{url}' is a shallow clone, this might lead to unexpected \"\n                \"failure or unusually high resource consumption.\",\n                ShallowCloneWarning,\n            )\n        else:\n            _clone = _clone[\"--filter=blob:none\"]\n    _clone()\n    # Include dirty changes if checking out a local HEAD\n    if ref in {None, \"HEAD\"} and os.path.exists(url) and Path(url).is_dir():\n        is_dirty = False\n        with local.cwd(url):\n            is_dirty = bool(git(\"status\", \"--porcelain\").strip())\n        if is_dirty:\n            url_abspath = Path(url).absolute()\n            with local.cwd(location):\n                git(\"--git-dir=.git\", f\"--work-tree={url_abspath}\", \"add\", \"-A\")\n                git(\n                    \"--git-dir=.git\",\n                    f\"--work-tree={url_abspath}\",\n                    \"commit\",\n                    \"-m\",\n                    \"Krupy automated commit for draft changes\",\n                    \"--no-verify\",\n                )\n                warn(\n                    \"Dirty template changes included automatically.\",\n                    DirtyLocalWarning,\n                )\n\n    with local.cwd(location):\n        git(\"checkout\", \"-f\", ref or \"HEAD\")\n        git(\"submodule\", \"update\", \"--checkout\", \"--init\", \"--recursive\", \"--force\")\n\n    return location\n</code></pre>"},{"location":"reference/krupy/vcs/#krupy.vcs.get_git","title":"<code>get_git(context_dir=None)</code>","text":"<p>Gets <code>git</code> command, or fails if it's not available</p> Source code in <code>krupy/vcs.py</code> <pre><code>def get_git(context_dir: OptStrOrPath = None) -&gt; LocalCommand:\n    \"\"\"Gets `git` command, or fails if it's not available\"\"\"\n    command = local[\"git\"]\n    if context_dir:\n        command = command[\"-C\", context_dir]\n    return command\n</code></pre>"},{"location":"reference/krupy/vcs/#krupy.vcs.get_repo","title":"<code>get_repo(url)</code>","text":"<p>Transform <code>url</code> into a git-parseable origin URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Valid examples:</p> <ul> <li>gh:Krunal-Kevadiya/krupy</li> <li>gl:Krunal-Kevadiya/krupy</li> <li>git@github.com:Krunal-Kevadiya/krupy.git</li> <li>git+https://mywebsiteisagitrepo.example.com/</li> <li>/local/path/to/git/repo</li> <li>/local/path/to/git/bundle/file.bundle</li> <li>~/path/to/git/repo</li> <li>~/path/to/git/repo.bundle</li> </ul> required Source code in <code>krupy/vcs.py</code> <pre><code>def get_repo(url: str) -&gt; OptStr:\n    \"\"\"Transform `url` into a git-parseable origin URL.\n\n    Args:\n        url:\n            Valid examples:\n\n            - gh:Krunal-Kevadiya/krupy\n            - gl:Krunal-Kevadiya/krupy\n            - git@github.com:Krunal-Kevadiya/krupy.git\n            - git+https://mywebsiteisagitrepo.example.com/\n            - /local/path/to/git/repo\n            - /local/path/to/git/bundle/file.bundle\n            - ~/path/to/git/repo\n            - ~/path/to/git/repo.bundle\n    \"\"\"\n    for pattern, replacement in REPLACEMENTS:\n        url = re.sub(pattern, replacement, url)\n\n    if url.endswith(GIT_POSTFIX) or url.startswith(GIT_PREFIX):\n        if url.startswith(\"git+\"):\n            url = url[4:]\n        elif url.startswith(\"https://\") and not url.endswith(GIT_POSTFIX):\n            url = \"\".join((url, GIT_POSTFIX))\n        return url\n\n    url_path = Path(url)\n    if url.startswith(\"~\"):\n        url_path = url_path.expanduser()\n\n    if is_git_repo_root(url_path) or is_git_bundle(url_path):\n        return url_path.as_posix()\n\n    return None\n</code></pre>"},{"location":"reference/krupy/vcs/#krupy.vcs.is_git_bundle","title":"<code>is_git_bundle(path)</code>","text":"<p>Indicate if a path is a valid git bundle.</p> Source code in <code>krupy/vcs.py</code> <pre><code>def is_git_bundle(path: Path) -&gt; bool:\n    \"\"\"Indicate if a path is a valid git bundle.\"\"\"\n    with suppress(OSError):\n        path = path.resolve()\n    with TemporaryDirectory(prefix=f\"{__name__}.is_git_bundle.\") as dirname:\n        with local.cwd(dirname):\n            get_git()(\"init\")\n            return bool(get_git()[\"bundle\", \"verify\", path] &amp; TF)\n</code></pre>"},{"location":"reference/krupy/vcs/#krupy.vcs.is_git_repo_root","title":"<code>is_git_repo_root(path)</code>","text":"<p>Indicate if a given path is a git repo root directory.</p> Source code in <code>krupy/vcs.py</code> <pre><code>def is_git_repo_root(path: StrOrPath) -&gt; bool:\n    \"\"\"Indicate if a given path is a git repo root directory.\"\"\"\n    try:\n        with local.cwd(Path(path, \".git\")):\n            return get_git()(\"rev-parse\", \"--is-inside-git-dir\").strip() == \"true\"\n    except OSError:\n        return False\n</code></pre>"},{"location":"reference/krupy/vcs/#krupy.vcs.is_git_shallow_repo","title":"<code>is_git_shallow_repo(path)</code>","text":"<p>Indicate if a given path is a git shallow repo directory.</p> Source code in <code>krupy/vcs.py</code> <pre><code>def is_git_shallow_repo(path: StrOrPath) -&gt; bool:\n    \"\"\"Indicate if a given path is a git shallow repo directory.\"\"\"\n    try:\n        return (\n            get_git()(\"-C\", path, \"rev-parse\", \"--is-shallow-repository\").strip()\n            == \"true\"\n        )\n    except (OSError, ProcessExecutionError):\n        return False\n</code></pre>"},{"location":"reference/krupy/vcs/#krupy.vcs.is_in_git_repo","title":"<code>is_in_git_repo(path)</code>","text":"<p>Indicate if a given path is in a git repo directory.</p> Source code in <code>krupy/vcs.py</code> <pre><code>def is_in_git_repo(path: StrOrPath) -&gt; bool:\n    \"\"\"Indicate if a given path is in a git repo directory.\"\"\"\n    try:\n        get_git()(\"-C\", path, \"rev-parse\", \"--show-toplevel\")\n        return True\n    except (OSError, ProcessExecutionError):\n        return False\n</code></pre>"},{"location":"reference/krupy/vcs/#krupy.vcs.valid_version","title":"<code>valid_version(version_)</code>","text":"<p>Tell if a string is a valid PEP 440 version specifier.</p> Source code in <code>krupy/vcs.py</code> <pre><code>def valid_version(version_: str) -&gt; bool:\n    \"\"\"Tell if a string is a valid [PEP 440][] version specifier.\n\n    [PEP 440]: https://peps.python.org/pep-0440/\n    \"\"\"\n    try:\n        version.parse(version_)\n    except InvalidVersion:\n        return False\n    return True\n</code></pre>"},{"location":"reference/questionary/form/","title":"form.py","text":""},{"location":"reference/questionary/form/#krupy.questionary.form.Form","title":"<code> Form        </code>","text":"<p>Multi question prompts. Questions are asked one after another.</p> <p>All the answers are returned as a dict with one entry per question.</p> <p>This class should not be invoked directly, instead use :func:<code>form</code>.</p> Source code in <code>krupy/questionary/form.py</code> <pre><code>class Form:\n    \"\"\"Multi question prompts. Questions are asked one after another.\n\n    All the answers are returned as a dict with one entry per question.\n\n    This class should not be invoked directly, instead use :func:`form`.\n    \"\"\"\n\n    form_fields: Sequence[FormField]\n\n    def __init__(self, *form_fields: FormField) -&gt; None:\n        self.form_fields = form_fields\n\n    def unsafe_ask(self, patch_stdout: bool = False) -&gt; Dict[str, Any]:\n        \"\"\"Ask the questions synchronously and return user response.\n\n        Does not catch keyboard interrupts.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n        Returns:\n            The answers from the form.\n        \"\"\"\n        return {f.key: f.question.unsafe_ask(patch_stdout) for f in self.form_fields}\n\n    async def unsafe_ask_async(self, patch_stdout: bool = False) -&gt; Dict[str, Any]:\n        \"\"\"Ask the questions using asyncio and return user response.\n\n        Does not catch keyboard interrupts.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n        Returns:\n            The answers from the form.\n        \"\"\"\n        return {\n            f.key: await f.question.unsafe_ask_async(patch_stdout)\n            for f in self.form_fields\n        }\n\n    def ask(\n        self, patch_stdout: bool = False, kbi_msg: str = DEFAULT_KBI_MESSAGE\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Ask the questions synchronously and return user response.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n            kbi_msg: The message to be printed on a keyboard interrupt.\n\n        Returns:\n            The answers from the form.\n        \"\"\"\n        try:\n            return self.unsafe_ask(patch_stdout)\n        except KeyboardInterrupt:\n            print(\"\")\n            print(kbi_msg)\n            print(\"\")\n            return {}\n\n    async def ask_async(\n        self, patch_stdout: bool = False, kbi_msg: str = DEFAULT_KBI_MESSAGE\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Ask the questions using asyncio and return user response.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n            kbi_msg: The message to be printed on a keyboard interrupt.\n\n        Returns:\n            The answers from the form.\n        \"\"\"\n        try:\n            return await self.unsafe_ask_async(patch_stdout)\n        except KeyboardInterrupt:\n            print(\"\")\n            print(kbi_msg)\n            print(\"\")\n            return {}\n</code></pre>"},{"location":"reference/questionary/form/#krupy.questionary.form.Form.ask","title":"<code>ask(self, patch_stdout=False, kbi_msg='Cancelled by user')</code>","text":"<p>Ask the questions synchronously and return user response.</p> <p>Parameters:</p> Name Type Description Default <code>patch_stdout</code> <code>bool</code> <p>Ensure that the prompt renders correctly if other threads           are printing to stdout.</p> <code>False</code> <code>kbi_msg</code> <code>str</code> <p>The message to be printed on a keyboard interrupt.</p> <code>'Cancelled by user'</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The answers from the form.</p> Source code in <code>krupy/questionary/form.py</code> <pre><code>def ask(\n    self, patch_stdout: bool = False, kbi_msg: str = DEFAULT_KBI_MESSAGE\n) -&gt; Dict[str, Any]:\n    \"\"\"Ask the questions synchronously and return user response.\n\n    Args:\n        patch_stdout: Ensure that the prompt renders correctly if other threads\n                      are printing to stdout.\n\n        kbi_msg: The message to be printed on a keyboard interrupt.\n\n    Returns:\n        The answers from the form.\n    \"\"\"\n    try:\n        return self.unsafe_ask(patch_stdout)\n    except KeyboardInterrupt:\n        print(\"\")\n        print(kbi_msg)\n        print(\"\")\n        return {}\n</code></pre>"},{"location":"reference/questionary/form/#krupy.questionary.form.Form.ask_async","title":"<code>ask_async(self, patch_stdout=False, kbi_msg='Cancelled by user')</code>  <code>async</code>","text":"<p>Ask the questions using asyncio and return user response.</p> <p>Parameters:</p> Name Type Description Default <code>patch_stdout</code> <code>bool</code> <p>Ensure that the prompt renders correctly if other threads           are printing to stdout.</p> <code>False</code> <code>kbi_msg</code> <code>str</code> <p>The message to be printed on a keyboard interrupt.</p> <code>'Cancelled by user'</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The answers from the form.</p> Source code in <code>krupy/questionary/form.py</code> <pre><code>async def ask_async(\n    self, patch_stdout: bool = False, kbi_msg: str = DEFAULT_KBI_MESSAGE\n) -&gt; Dict[str, Any]:\n    \"\"\"Ask the questions using asyncio and return user response.\n\n    Args:\n        patch_stdout: Ensure that the prompt renders correctly if other threads\n                      are printing to stdout.\n\n        kbi_msg: The message to be printed on a keyboard interrupt.\n\n    Returns:\n        The answers from the form.\n    \"\"\"\n    try:\n        return await self.unsafe_ask_async(patch_stdout)\n    except KeyboardInterrupt:\n        print(\"\")\n        print(kbi_msg)\n        print(\"\")\n        return {}\n</code></pre>"},{"location":"reference/questionary/form/#krupy.questionary.form.Form.unsafe_ask","title":"<code>unsafe_ask(self, patch_stdout=False)</code>","text":"<p>Ask the questions synchronously and return user response.</p> <p>Does not catch keyboard interrupts.</p> <p>Parameters:</p> Name Type Description Default <code>patch_stdout</code> <code>bool</code> <p>Ensure that the prompt renders correctly if other threads           are printing to stdout.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The answers from the form.</p> Source code in <code>krupy/questionary/form.py</code> <pre><code>def unsafe_ask(self, patch_stdout: bool = False) -&gt; Dict[str, Any]:\n    \"\"\"Ask the questions synchronously and return user response.\n\n    Does not catch keyboard interrupts.\n\n    Args:\n        patch_stdout: Ensure that the prompt renders correctly if other threads\n                      are printing to stdout.\n\n    Returns:\n        The answers from the form.\n    \"\"\"\n    return {f.key: f.question.unsafe_ask(patch_stdout) for f in self.form_fields}\n</code></pre>"},{"location":"reference/questionary/form/#krupy.questionary.form.Form.unsafe_ask_async","title":"<code>unsafe_ask_async(self, patch_stdout=False)</code>  <code>async</code>","text":"<p>Ask the questions using asyncio and return user response.</p> <p>Does not catch keyboard interrupts.</p> <p>Parameters:</p> Name Type Description Default <code>patch_stdout</code> <code>bool</code> <p>Ensure that the prompt renders correctly if other threads           are printing to stdout.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The answers from the form.</p> Source code in <code>krupy/questionary/form.py</code> <pre><code>async def unsafe_ask_async(self, patch_stdout: bool = False) -&gt; Dict[str, Any]:\n    \"\"\"Ask the questions using asyncio and return user response.\n\n    Does not catch keyboard interrupts.\n\n    Args:\n        patch_stdout: Ensure that the prompt renders correctly if other threads\n                      are printing to stdout.\n\n    Returns:\n        The answers from the form.\n    \"\"\"\n    return {\n        f.key: await f.question.unsafe_ask_async(patch_stdout)\n        for f in self.form_fields\n    }\n</code></pre>"},{"location":"reference/questionary/form/#krupy.questionary.form.FormField","title":"<code> FormField            (tuple)         </code>","text":"<p>Represents a question within a form</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <p>The name of the form field.</p> required <code>question</code> <p>The question to ask in the form field.</p> required Source code in <code>krupy/questionary/form.py</code> <pre><code>class FormField(NamedTuple):\n    \"\"\"\n    Represents a question within a form\n\n    Args:\n        key: The name of the form field.\n        question: The question to ask in the form field.\n    \"\"\"\n\n    key: str\n    question: Question\n</code></pre>"},{"location":"reference/questionary/form/#krupy.questionary.form.FormField.__getnewargs__","title":"<code>__getnewargs__(self)</code>  <code>special</code>","text":"<p>Return self as a plain tuple.  Used by copy and pickle.</p> Source code in <code>krupy/questionary/form.py</code> <pre><code>def __getnewargs__(self):\n    'Return self as a plain tuple.  Used by copy and pickle.'\n    return _tuple(self)\n</code></pre>"},{"location":"reference/questionary/form/#krupy.questionary.form.FormField.__new__","title":"<code>__new__(_cls, key, question)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>Create new instance of FormField(key, question)</p>"},{"location":"reference/questionary/form/#krupy.questionary.form.FormField.__repr__","title":"<code>__repr__(self)</code>  <code>special</code>","text":"<p>Return a nicely formatted representation string</p> Source code in <code>krupy/questionary/form.py</code> <pre><code>def __repr__(self):\n    'Return a nicely formatted representation string'\n    return self.__class__.__name__ + repr_fmt % self\n</code></pre>"},{"location":"reference/questionary/form/#krupy.questionary.form.form","title":"<code>form(**kwargs)</code>","text":"<p>Create a form with multiple questions.</p> <p>The parameter name of a question will be the key for the answer in the returned dict.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Question</code> <p>Questions to ask in the form.</p> <code>{}</code> Source code in <code>krupy/questionary/form.py</code> <pre><code>def form(**kwargs: Question) -&gt; \"Form\":\n    \"\"\"Create a form with multiple questions.\n\n    The parameter name of a question will be the key for the answer in\n    the returned dict.\n\n    Args:\n        kwargs: Questions to ask in the form.\n    \"\"\"\n    return Form(*(FormField(k, q) for k, q in kwargs.items()))\n</code></pre>"},{"location":"reference/questionary/prompt/","title":"prompt.py","text":""},{"location":"reference/questionary/prompt/#krupy.questionary.prompt.PromptParameterException","title":"<code> PromptParameterException            (ValueError)         </code>","text":"<p>Received a prompt with a missing parameter.</p> Source code in <code>krupy/questionary/prompt.py</code> <pre><code>class PromptParameterException(ValueError):\n    \"\"\"Received a prompt with a missing parameter.\"\"\"\n\n    def __init__(self, message: str, errors: Optional[BaseException] = None) -&gt; None:\n        # Call the base class constructor with the parameters it needs\n        super().__init__(f\"You must provide a `{message}` value\", errors)\n</code></pre>"},{"location":"reference/questionary/prompt/#krupy.questionary.prompt.prompt","title":"<code>prompt(questions, answers=None, patch_stdout=False, true_color=False, kbi_msg='Cancelled by user', **kwargs)</code>","text":"<p>Prompt the user for input on all the questions.</p> <p>Catches keyboard interrupts and prints a message.</p> <p>See :func:<code>unsafe_prompt</code> for possible question configurations.</p> <p>Parameters:</p> Name Type Description Default <code>questions</code> <code>Union[Dict[str, Any], Iterable[Mapping[str, Any]]]</code> <p>A list of question configs representing questions to        ask. A question config may have the following options:</p> <pre><code>   * type - The type of question.\n   * name - An ID for the question (to identify it in the answers :obj:`dict`).\n\n   * when - Callable to conditionally show the question. This function\n     takes a :obj:`dict` representing the current answers.\n\n   * filter - Function that the answer is passed to. The return value of this\n     function is saved as the answer.\n\n   Additional options correspond to the parameter names for\n   particular question types.\n</code></pre> required <code>answers</code> <code>Optional[Mapping[str, Any]]</code> <p>Default answers.</p> <code>None</code> <code>patch_stdout</code> <code>bool</code> <p>Ensure that the prompt renders correctly if other threads           are printing to stdout.</p> <code>False</code> <code>kbi_msg</code> <code>str</code> <p>The message to be printed on a keyboard interrupt.</p> <code>'Cancelled by user'</code> <code>true_color</code> <code>bool</code> <p>Use true color output.</p> <code>False</code> <code>color_depth</code> <p>Color depth to use. If <code>true_color</code> is set to true then this          value is ignored.</p> required <code>type</code> <p>Default <code>type</code> value to use in question config.</p> required <code>filter</code> <p>Default <code>filter</code> value to use in question config.</p> required <code>name</code> <p>Default <code>name</code> value to use in question config.</p> required <code>when</code> <p>Default <code>when</code> value to use in question config.</p> required <code>default</code> <p>Default <code>default</code> value to use in question config.</p> required <code>kwargs</code> <code>Any</code> <p>Additional options passed to every question.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of question answers.</p> Source code in <code>krupy/questionary/prompt.py</code> <pre><code>def prompt(\n    questions: Union[Dict[str, Any], Iterable[Mapping[str, Any]]],\n    answers: Optional[Mapping[str, Any]] = None,\n    patch_stdout: bool = False,\n    true_color: bool = False,\n    kbi_msg: str = DEFAULT_KBI_MESSAGE,\n    **kwargs: Any,\n) -&gt; Dict[str, Any]:\n    \"\"\"Prompt the user for input on all the questions.\n\n    Catches keyboard interrupts and prints a message.\n\n    See :func:`unsafe_prompt` for possible question configurations.\n\n    Args:\n        questions: A list of question configs representing questions to\n                   ask. A question config may have the following options:\n\n                   * type - The type of question.\n                   * name - An ID for the question (to identify it in the answers :obj:`dict`).\n\n                   * when - Callable to conditionally show the question. This function\n                     takes a :obj:`dict` representing the current answers.\n\n                   * filter - Function that the answer is passed to. The return value of this\n                     function is saved as the answer.\n\n                   Additional options correspond to the parameter names for\n                   particular question types.\n\n        answers: Default answers.\n\n        patch_stdout: Ensure that the prompt renders correctly if other threads\n                      are printing to stdout.\n\n        kbi_msg: The message to be printed on a keyboard interrupt.\n        true_color: Use true color output.\n\n        color_depth: Color depth to use. If ``true_color`` is set to true then this\n                     value is ignored.\n\n        type: Default ``type`` value to use in question config.\n        filter: Default ``filter`` value to use in question config.\n        name: Default ``name`` value to use in question config.\n        when: Default ``when`` value to use in question config.\n        default: Default ``default`` value to use in question config.\n        kwargs: Additional options passed to every question.\n\n    Returns:\n        Dictionary of question answers.\n    \"\"\"\n\n    try:\n        return unsafe_prompt(questions, answers, patch_stdout, true_color, **kwargs)\n    except KeyboardInterrupt:\n        print(\"\")\n        print(kbi_msg)\n        print(\"\")\n        return {}\n</code></pre>"},{"location":"reference/questionary/prompt/#krupy.questionary.prompt.unsafe_prompt","title":"<code>unsafe_prompt(questions, answers=None, patch_stdout=False, true_color=False, **kwargs)</code>","text":"<p>Prompt the user for input on all the questions.</p> <p>Won't catch keyboard interrupts.</p> <p>Parameters:</p> Name Type Description Default <code>questions</code> <code>Union[Dict[str, Any], Iterable[Mapping[str, Any]]]</code> <p>A list of question configs representing questions to        ask. A question config may have the following options:</p> <pre><code>   * type - The type of question.\n   * name - An ID for the question (to identify it in the answers :obj:`dict`).\n\n   * when - Callable to conditionally show the question. This function\n     takes a :obj:`dict` representing the current answers.\n\n   * filter - Function that the answer is passed to. The return value of this\n     function is saved as the answer.\n\n   Additional options correspond to the parameter names for\n   particular question types.\n</code></pre> required <code>answers</code> <code>Optional[Mapping[str, Any]]</code> <p>Default answers.</p> <code>None</code> <code>patch_stdout</code> <code>bool</code> <p>Ensure that the prompt renders correctly if other threads           are printing to stdout.</p> <code>False</code> <code>true_color</code> <code>bool</code> <p>Use true color output.</p> <code>False</code> <code>color_depth</code> <p>Color depth to use. If <code>true_color</code> is set to true then this          value is ignored.</p> required <code>type</code> <p>Default <code>type</code> value to use in question config.</p> required <code>filter</code> <p>Default <code>filter</code> value to use in question config.</p> required <code>name</code> <p>Default <code>name</code> value to use in question config.</p> required <code>when</code> <p>Default <code>when</code> value to use in question config.</p> required <code>default</code> <p>Default <code>default</code> value to use in question config.</p> required <code>kwargs</code> <code>Any</code> <p>Additional options passed to every question.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of question answers.</p> <p>Exceptions:</p> Type Description <code>KeyboardInterrupt</code> <p>raised on keyboard interrupt</p> Source code in <code>krupy/questionary/prompt.py</code> <pre><code>def unsafe_prompt(\n    questions: Union[Dict[str, Any], Iterable[Mapping[str, Any]]],\n    answers: Optional[Mapping[str, Any]] = None,\n    patch_stdout: bool = False,\n    true_color: bool = False,\n    **kwargs: Any,\n) -&gt; Dict[str, Any]:\n    \"\"\"Prompt the user for input on all the questions.\n\n    Won't catch keyboard interrupts.\n\n    Args:\n        questions: A list of question configs representing questions to\n                   ask. A question config may have the following options:\n\n                   * type - The type of question.\n                   * name - An ID for the question (to identify it in the answers :obj:`dict`).\n\n                   * when - Callable to conditionally show the question. This function\n                     takes a :obj:`dict` representing the current answers.\n\n                   * filter - Function that the answer is passed to. The return value of this\n                     function is saved as the answer.\n\n                   Additional options correspond to the parameter names for\n                   particular question types.\n\n        answers: Default answers.\n\n        patch_stdout: Ensure that the prompt renders correctly if other threads\n                      are printing to stdout.\n\n        true_color: Use true color output.\n\n        color_depth: Color depth to use. If ``true_color`` is set to true then this\n                     value is ignored.\n\n        type: Default ``type`` value to use in question config.\n        filter: Default ``filter`` value to use in question config.\n        name: Default ``name`` value to use in question config.\n        when: Default ``when`` value to use in question config.\n        default: Default ``default`` value to use in question config.\n        kwargs: Additional options passed to every question.\n\n    Returns:\n        Dictionary of question answers.\n\n    Raises:\n        KeyboardInterrupt: raised on keyboard interrupt\n    \"\"\"\n\n    if isinstance(questions, dict):\n        questions = [questions]\n\n    answers = dict(answers or {})\n\n    for question_config in questions:\n        question_config = dict(question_config)\n        # import the question\n        if \"type\" not in question_config:\n            raise PromptParameterException(\"type\")\n        # every type except 'print' needs a name\n        if \"name\" not in question_config and question_config[\"type\"] != \"print\":\n            raise PromptParameterException(\"name\")\n\n        _kwargs = kwargs.copy()\n        _kwargs.update(question_config)\n\n        _type = _kwargs.pop(\"type\")\n        _filter = _kwargs.pop(\"filter\", None)\n        name = _kwargs.pop(\"name\", None) if _type == \"print\" else _kwargs.pop(\"name\")\n        when = _kwargs.pop(\"when\", None)\n\n        if true_color:\n            _kwargs[\"color_depth\"] = ColorDepth.TRUE_COLOR\n\n        if when:\n            # at least a little sanity check!\n            if callable(question_config[\"when\"]):\n                try:\n                    if not question_config[\"when\"](answers):\n                        continue\n                except Exception as exception:\n                    raise ValueError(\n                        f\"Problem in 'when' check of \" f\"{name} question: {exception}\"\n                    ) from exception\n            else:\n                raise ValueError(\n                    \"'when' needs to be function that accepts a dict argument\"\n                )\n\n        # handle 'print' type\n        if _type == \"print\":\n            try:\n                message = _kwargs.pop(\"message\")\n            except KeyError as e:\n                raise PromptParameterException(\"message\") from e\n\n            # questions can take 'input' arg but print_formatted_text does not\n            # Remove 'input', if present, to avoid breaking during tests\n            _kwargs.pop(\"input\", None)\n\n            print_formatted_text(message, **_kwargs)\n            if name:\n                answers[name] = None\n            continue\n\n        choices = question_config.get(\"choices\")\n        if choices is not None and callable(choices):\n            calculated_choices = choices(answers)\n            question_config[\"choices\"] = calculated_choices\n            kwargs[\"choices\"] = calculated_choices\n\n        if _filter:\n            # at least a little sanity check!\n            if not callable(_filter):\n                raise ValueError(\n                    \"'filter' needs to be function that accepts an argument\"\n                )\n\n        if callable(question_config.get(\"default\")):\n            _kwargs[\"default\"] = question_config[\"default\"](answers)\n\n        create_question_func = prompt_by_name(_type)\n\n        if not create_question_func:\n            raise ValueError(\n                f\"No question type '{_type}' found. \"\n                f\"Known question types are {', '.join(AVAILABLE_PROMPTS)}.\"\n            )\n\n        missing_args = list(utils.missing_arguments(create_question_func, _kwargs))\n        if missing_args:\n            raise PromptParameterException(missing_args[0])\n\n        question = create_question_func(**_kwargs)\n\n        answer = question.unsafe_ask(patch_stdout)\n\n        if answer is not None:\n            if _filter:\n                try:\n                    answer = _filter(answer)\n                except Exception as exception:\n                    raise ValueError(\n                        f\"Problem processing 'filter' of {name} \"\n                        f\"question: {exception}\"\n                    ) from exception\n            answers[name] = answer\n\n    return answers\n</code></pre>"},{"location":"reference/questionary/question/","title":"question.py","text":""},{"location":"reference/questionary/question/#krupy.questionary.question.Question","title":"<code> Question        </code>","text":"<p>A question to be prompted.</p> <p>This is an internal class. Questions should be created using the predefined questions (e.g. text or password).</p> Source code in <code>krupy/questionary/question.py</code> <pre><code>class Question:\n    \"\"\"A question to be prompted.\n\n    This is an internal class. Questions should be created using the\n    predefined questions (e.g. text or password).\"\"\"\n\n    application: \"Application[Any]\"\n    should_skip_question: bool\n    default: Any\n\n    def __init__(self, application: \"Application[Any]\") -&gt; None:\n        self.application = application\n        self.should_skip_question = False\n        self.default = None\n\n    async def ask_async(\n        self, patch_stdout: bool = False, kbi_msg: str = DEFAULT_KBI_MESSAGE\n    ) -&gt; Any:\n        \"\"\"Ask the question using asyncio and return user response.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n            kbi_msg: The message to be printed on a keyboard interrupt.\n\n        Returns:\n            `Any`: The answer from the question.\n        \"\"\"\n\n        try:\n            sys.stdout.flush()\n            return await self.unsafe_ask_async(patch_stdout)\n        except KeyboardInterrupt:\n            print(\"\\n{}\\n\".format(kbi_msg))\n            return None\n\n    def ask(\n        self, patch_stdout: bool = False, kbi_msg: str = DEFAULT_KBI_MESSAGE\n    ) -&gt; Any:\n        \"\"\"Ask the question synchronously and return user response.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n            kbi_msg: The message to be printed on a keyboard interrupt.\n\n        Returns:\n            `Any`: The answer from the question.\n        \"\"\"\n\n        try:\n            return self.unsafe_ask(patch_stdout)\n        except KeyboardInterrupt:\n            print(\"\\n{}\\n\".format(kbi_msg))\n            return None\n\n    def unsafe_ask(self, patch_stdout: bool = False) -&gt; Any:\n        \"\"\"Ask the question synchronously and return user response.\n\n        Does not catch keyboard interrupts.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n        Returns:\n            `Any`: The answer from the question.\n        \"\"\"\n\n        if self.should_skip_question:\n            return self.default\n\n        if patch_stdout:\n            with prompt_toolkit.patch_stdout.patch_stdout():\n                return self.application.run()\n        else:\n            return self.application.run()\n\n    def skip_if(self, condition: bool, default: Any = None) -&gt; \"Question\":\n        \"\"\"Skip the question if flag is set and return the default instead.\n\n        Args:\n            condition: A conditional boolean value.\n            default: The default value to return.\n\n        Returns:\n            Question: self\n        \"\"\"\n\n        self.should_skip_question = condition\n        self.default = default\n        return self\n\n    async def unsafe_ask_async(self, patch_stdout: bool = False) -&gt; Any:\n        \"\"\"Ask the question using asyncio and return user response.\n\n        Does not catch keyboard interrupts.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n        Returns:\n            `Any`: The answer from the question.\n        \"\"\"\n\n        if self.should_skip_question:\n            return self.default\n\n        if not utils.ACTIVATED_ASYNC_MODE:\n            await utils.activate_prompt_toolkit_async_mode()\n\n        if patch_stdout:\n            with prompt_toolkit.patch_stdout.patch_stdout():\n                r = self.application.run_async()\n        else:\n            r = self.application.run_async()\n\n        if utils.is_prompt_toolkit_3():\n            return await r\n        else:\n            return await r.to_asyncio_future()  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/questionary/question/#krupy.questionary.question.Question.ask","title":"<code>ask(self, patch_stdout=False, kbi_msg='Cancelled by user')</code>","text":"<p>Ask the question synchronously and return user response.</p> <p>Parameters:</p> Name Type Description Default <code>patch_stdout</code> <code>bool</code> <p>Ensure that the prompt renders correctly if other threads           are printing to stdout.</p> <code>False</code> <code>kbi_msg</code> <code>str</code> <p>The message to be printed on a keyboard interrupt.</p> <code>'Cancelled by user'</code> <p>Returns:</p> Type Description <code>`Any`</code> <p>The answer from the question.</p> Source code in <code>krupy/questionary/question.py</code> <pre><code>def ask(\n    self, patch_stdout: bool = False, kbi_msg: str = DEFAULT_KBI_MESSAGE\n) -&gt; Any:\n    \"\"\"Ask the question synchronously and return user response.\n\n    Args:\n        patch_stdout: Ensure that the prompt renders correctly if other threads\n                      are printing to stdout.\n\n        kbi_msg: The message to be printed on a keyboard interrupt.\n\n    Returns:\n        `Any`: The answer from the question.\n    \"\"\"\n\n    try:\n        return self.unsafe_ask(patch_stdout)\n    except KeyboardInterrupt:\n        print(\"\\n{}\\n\".format(kbi_msg))\n        return None\n</code></pre>"},{"location":"reference/questionary/question/#krupy.questionary.question.Question.ask_async","title":"<code>ask_async(self, patch_stdout=False, kbi_msg='Cancelled by user')</code>  <code>async</code>","text":"<p>Ask the question using asyncio and return user response.</p> <p>Parameters:</p> Name Type Description Default <code>patch_stdout</code> <code>bool</code> <p>Ensure that the prompt renders correctly if other threads           are printing to stdout.</p> <code>False</code> <code>kbi_msg</code> <code>str</code> <p>The message to be printed on a keyboard interrupt.</p> <code>'Cancelled by user'</code> <p>Returns:</p> Type Description <code>`Any`</code> <p>The answer from the question.</p> Source code in <code>krupy/questionary/question.py</code> <pre><code>async def ask_async(\n    self, patch_stdout: bool = False, kbi_msg: str = DEFAULT_KBI_MESSAGE\n) -&gt; Any:\n    \"\"\"Ask the question using asyncio and return user response.\n\n    Args:\n        patch_stdout: Ensure that the prompt renders correctly if other threads\n                      are printing to stdout.\n\n        kbi_msg: The message to be printed on a keyboard interrupt.\n\n    Returns:\n        `Any`: The answer from the question.\n    \"\"\"\n\n    try:\n        sys.stdout.flush()\n        return await self.unsafe_ask_async(patch_stdout)\n    except KeyboardInterrupt:\n        print(\"\\n{}\\n\".format(kbi_msg))\n        return None\n</code></pre>"},{"location":"reference/questionary/question/#krupy.questionary.question.Question.skip_if","title":"<code>skip_if(self, condition, default=None)</code>","text":"<p>Skip the question if flag is set and return the default instead.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>bool</code> <p>A conditional boolean value.</p> required <code>default</code> <code>Any</code> <p>The default value to return.</p> <code>None</code> <p>Returns:</p> Type Description <code>Question</code> <p>self</p> Source code in <code>krupy/questionary/question.py</code> <pre><code>def skip_if(self, condition: bool, default: Any = None) -&gt; \"Question\":\n    \"\"\"Skip the question if flag is set and return the default instead.\n\n    Args:\n        condition: A conditional boolean value.\n        default: The default value to return.\n\n    Returns:\n        Question: self\n    \"\"\"\n\n    self.should_skip_question = condition\n    self.default = default\n    return self\n</code></pre>"},{"location":"reference/questionary/question/#krupy.questionary.question.Question.unsafe_ask","title":"<code>unsafe_ask(self, patch_stdout=False)</code>","text":"<p>Ask the question synchronously and return user response.</p> <p>Does not catch keyboard interrupts.</p> <p>Parameters:</p> Name Type Description Default <code>patch_stdout</code> <code>bool</code> <p>Ensure that the prompt renders correctly if other threads           are printing to stdout.</p> <code>False</code> <p>Returns:</p> Type Description <code>`Any`</code> <p>The answer from the question.</p> Source code in <code>krupy/questionary/question.py</code> <pre><code>def unsafe_ask(self, patch_stdout: bool = False) -&gt; Any:\n    \"\"\"Ask the question synchronously and return user response.\n\n    Does not catch keyboard interrupts.\n\n    Args:\n        patch_stdout: Ensure that the prompt renders correctly if other threads\n                      are printing to stdout.\n\n    Returns:\n        `Any`: The answer from the question.\n    \"\"\"\n\n    if self.should_skip_question:\n        return self.default\n\n    if patch_stdout:\n        with prompt_toolkit.patch_stdout.patch_stdout():\n            return self.application.run()\n    else:\n        return self.application.run()\n</code></pre>"},{"location":"reference/questionary/question/#krupy.questionary.question.Question.unsafe_ask_async","title":"<code>unsafe_ask_async(self, patch_stdout=False)</code>  <code>async</code>","text":"<p>Ask the question using asyncio and return user response.</p> <p>Does not catch keyboard interrupts.</p> <p>Parameters:</p> Name Type Description Default <code>patch_stdout</code> <code>bool</code> <p>Ensure that the prompt renders correctly if other threads           are printing to stdout.</p> <code>False</code> <p>Returns:</p> Type Description <code>`Any`</code> <p>The answer from the question.</p> Source code in <code>krupy/questionary/question.py</code> <pre><code>async def unsafe_ask_async(self, patch_stdout: bool = False) -&gt; Any:\n    \"\"\"Ask the question using asyncio and return user response.\n\n    Does not catch keyboard interrupts.\n\n    Args:\n        patch_stdout: Ensure that the prompt renders correctly if other threads\n                      are printing to stdout.\n\n    Returns:\n        `Any`: The answer from the question.\n    \"\"\"\n\n    if self.should_skip_question:\n        return self.default\n\n    if not utils.ACTIVATED_ASYNC_MODE:\n        await utils.activate_prompt_toolkit_async_mode()\n\n    if patch_stdout:\n        with prompt_toolkit.patch_stdout.patch_stdout():\n            r = self.application.run_async()\n    else:\n        r = self.application.run_async()\n\n    if utils.is_prompt_toolkit_3():\n        return await r\n    else:\n        return await r.to_asyncio_future()  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/questionary/quickstart/","title":"Quick Start","text":"<p>Questionary supports two different concepts:</p> <ul> <li>creating a single question for the user</li> </ul> <pre><code>  questionary.password(\"What's your secret?\").ask()\n</code></pre> <ul> <li>creating a form with multiple questions asked one after another</li> </ul> <pre><code>  answers = questionary.form(\n    first = questionary.confirm(\"Would you like the next question?\", default=True),\n    second = questionary.select(\"Select item\", choices=[\"item1\", \"item2\", \"item3\"])\n  ).ask()\n</code></pre>"},{"location":"reference/questionary/quickstart/#asking-a-single-question","title":"Asking a Single Question","text":"<p>Questionary ships with a lot of different Question Types to provide the right prompt for the right question. All of them work in the same way though. Firstly, you create a question:</p> <pre><code>  import questionary\n\n  question = questionary.text(\"What's your first name\")\n</code></pre> <p>and secondly, you need to prompt the user to answer it:</p> <pre><code>  answer = question.ask()\n</code></pre> <p>Since our question is a <code>text</code> prompt, <code>answer</code> will contain the text the user typed after they submitted it.</p> <p>You can concatenate creating and asking the question in a single line if you like, e.g.</p> <pre><code>  import questionary\n\n  answer = questionary.text(\"What's your first name\").ask()\n</code></pre> <p>Note</p> <p>There are a lot more question types apart from <code>text</code>. For a description of the different question types, head over to the Question Types.</p>"},{"location":"reference/questionary/quickstart/#asking-multiple-questions","title":"Asking Multiple Questions","text":"<p>You can use the form() function to ask a collection of Questions . The questions will be asked in the order they are passed to form(). <pre><code>  import questionary\n\n  answers = questionary.form(\n    first = questionary.confirm(\"Would you like the next question?\", default=True),\n    second = questionary.select(\"Select item\", choices=[\"item1\", \"item2\", \"item3\"])\n  ).ask()\n\n  print(answers)\n</code></pre> <p>The printed output will have the following format:</p> <pre><code>{'first': True, 'second': 'item2'}\n</code></pre> <p>The prompt() function also allows you to ask a collection of questions, however instead of taking Question instances, it takes a dictionary:</p> <pre><code>  import questionary\n\n  questions = [\n    {\n      \"type\": \"confirm\",\n      \"name\": \"first\",\n      \"message\": \"Would you like the next question?\",\n      \"default\": True,\n    },\n    {\n      \"type\": \"select\",\n      \"name\": \"second\",\n      \"message\": \"Select item\",\n      \"choices\": [\"item1\", \"item2\", \"item3\"],\n    },\n  ]\n\n  questionary.prompt(questions)\n</code></pre> <p>The format of the returned answers is the same as the one for form(). You can find more details on the configuration dictionaries in Create Questions from Dictionaries.</p>"},{"location":"reference/questionary/prompts/autocomplete/","title":"autocomplete.py","text":""},{"location":"reference/questionary/prompts/autocomplete/#krupy.questionary.prompts.autocomplete.WordCompleter","title":"<code> WordCompleter            (Completer)         </code>","text":"Source code in <code>krupy/questionary/prompts/autocomplete.py</code> <pre><code>class WordCompleter(Completer):\n    choices_source: Union[List[str], Callable[[], List[str]]]\n    ignore_case: bool\n    meta_information: Dict[str, Any]\n    match_middle: bool\n\n    def __init__(\n        self,\n        choices: Union[List[str], Callable[[], List[str]]],\n        ignore_case: bool = True,\n        meta_information: Optional[Dict[str, Any]] = None,\n        match_middle: bool = True,\n    ) -&gt; None:\n        self.choices_source = choices\n        self.ignore_case = ignore_case\n        self.meta_information = meta_information or {}\n        self.match_middle = match_middle\n\n    def _choices(self) -&gt; Iterable[str]:\n        return (\n            self.choices_source()\n            if callable(self.choices_source)\n            else self.choices_source\n        )\n\n    def _choice_matches(self, word_before_cursor: str, choice: str) -&gt; int:\n        \"\"\"Match index if found, -1 if not.\"\"\"\n\n        if self.ignore_case:\n            choice = choice.lower()\n\n        if self.match_middle:\n            return choice.find(word_before_cursor)\n        elif choice.startswith(word_before_cursor):\n            return 0\n        else:\n            return -1\n\n    @staticmethod\n    def _display_for_choice(choice: str, index: int, word_before_cursor: str) -&gt; HTML:\n        return HTML(\"{}&lt;b&gt;&lt;u&gt;{}&lt;/u&gt;&lt;/b&gt;{}\").format(\n            choice[:index],\n            choice[index : index + len(word_before_cursor)],  # noqa: E203\n            choice[index + len(word_before_cursor) : len(choice)],  # noqa: E203\n        )\n\n    def get_completions(\n        self, document: Document, complete_event: CompleteEvent\n    ) -&gt; Iterable[Completion]:\n        choices = self._choices()\n\n        # Get word/text before cursor.\n        word_before_cursor = document.text_before_cursor\n\n        if self.ignore_case:\n            word_before_cursor = word_before_cursor.lower()\n\n        for choice in choices:\n            index = self._choice_matches(word_before_cursor, choice)\n            if index == -1:\n                # didn't find a match\n                continue\n\n            display_meta = self.meta_information.get(choice, \"\")\n            display = self._display_for_choice(choice, index, word_before_cursor)\n\n            yield Completion(\n                choice,\n                start_position=-len(choice),\n                display=display.formatted_text,\n                display_meta=display_meta,\n                style=\"class:answer\",\n                selected_style=\"class:selected\",\n            )\n</code></pre>"},{"location":"reference/questionary/prompts/autocomplete/#krupy.questionary.prompts.autocomplete.WordCompleter.get_completions","title":"<code>get_completions(self, document, complete_event)</code>","text":"<p>This should be a generator that yields :class:<code>.Completion</code> instances.</p> <p>If the generation of completions is something expensive (that takes a lot of time), consider wrapping this <code>Completer</code> class in a <code>ThreadedCompleter</code>. In that case, the completer algorithm runs in a background thread and completions will be displayed as soon as they arrive.</p> <p>:param document: :class:<code>~prompt_toolkit.document.Document</code> instance. :param complete_event: :class:<code>.CompleteEvent</code> instance.</p> Source code in <code>krupy/questionary/prompts/autocomplete.py</code> <pre><code>def get_completions(\n    self, document: Document, complete_event: CompleteEvent\n) -&gt; Iterable[Completion]:\n    choices = self._choices()\n\n    # Get word/text before cursor.\n    word_before_cursor = document.text_before_cursor\n\n    if self.ignore_case:\n        word_before_cursor = word_before_cursor.lower()\n\n    for choice in choices:\n        index = self._choice_matches(word_before_cursor, choice)\n        if index == -1:\n            # didn't find a match\n            continue\n\n        display_meta = self.meta_information.get(choice, \"\")\n        display = self._display_for_choice(choice, index, word_before_cursor)\n\n        yield Completion(\n            choice,\n            start_position=-len(choice),\n            display=display.formatted_text,\n            display_meta=display_meta,\n            style=\"class:answer\",\n            selected_style=\"class:selected\",\n        )\n</code></pre>"},{"location":"reference/questionary/prompts/autocomplete/#krupy.questionary.prompts.autocomplete.autocomplete","title":"<code>autocomplete(message, choices, default='', qmark='?', completer=None, meta_information=None, ignore_case=True, match_middle=True, complete_style=&lt;CompleteStyle.COLUMN: 'COLUMN'&gt;, validate=None, style=None, qcount=None, **kwargs)</code>","text":"<p>Prompt the user to enter a message with autocomplete help.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import questionary\n&gt;&gt;&gt; questionary.autocomplete(\n...    'Choose ant specie',\n...    choices=[\n...         'Camponotus pennsylvanicus',\n...         'Linepithema humile',\n...         'Eciton burchellii',\n...         \"Atta colombica\",\n...         'Polyergus lucidus',\n...         'Polyergus rufescens',\n...    ]).ask()\n? Choose ant specie Atta colombica\n'Atta colombica'\n</code></pre> <p></p> <p>This is just a really basic example, the prompt can be customised using the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question text</p> required <code>choices</code> <code>List[str]</code> <p>Items shown in the selection, this contains items as strings</p> required <code>default</code> <code>str</code> <p>Default return value (single value).</p> <code>''</code> <code>qmark</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question prefix displayed in front of the question.    By default this is a <code>?</code></p> <code>'?'</code> <code>completer</code> <code>Optional[prompt_toolkit.completion.base.Completer]</code> <p>A prompt_toolkit prompt_toolkit.completion.Completion        implementation. If not set, a questionary completer implementation        will be used.</p> <code>None</code> <code>meta_information</code> <code>Optional[Dict[str, Any]]</code> <p>A dictionary with information/anything about choices.</p> <code>None</code> <code>ignore_case</code> <code>bool</code> <p>If true autocomplete would ignore case.</p> <code>True</code> <code>match_middle</code> <code>bool</code> <p>If true autocomplete would search in every string position           not only in string begin.</p> <code>True</code> <code>complete_style</code> <code>CompleteStyle</code> <p>How autocomplete menu would be shown, it could be <code>COLUMN</code> <code>MULTI_COLUMN</code> or <code>READLINE_LIKE</code> from             prompt_toolkit.shortcuts.CompleteStyle.</p> <code>&lt;CompleteStyle.COLUMN: 'COLUMN'&gt;</code> <code>validate</code> <code>Any</code> <p>Require the entered value to pass a validation. The       value can not be submitted until the validator accepts       it (e.g. to check minimum password length).</p> <pre><code>  This can either be a function accepting the input and\n  returning a boolean, or an class reference to a\n  subclass of the prompt toolkit Validator class.\n</code></pre> <code>None</code> <code>style</code> <code>Optional[prompt_toolkit.styles.style.Style]</code> <p>A custom color and style for the question parts. You can    configure colors as well as font types for different elements.</p> <code>None</code> <p>Returns:</p> Type Description <code>[Question]()</code> <p>Question instance, ready to be prompted (using <code>.ask()</code>).</p> Source code in <code>krupy/questionary/prompts/autocomplete.py</code> <pre><code>def autocomplete(\n    message: AnyFormattedText,\n    choices: List[str],\n    default: str = \"\",\n    qmark: AnyFormattedText = DEFAULT_QUESTION_PREFIX,\n    completer: Optional[Completer] = None,\n    meta_information: Optional[Dict[str, Any]] = None,\n    ignore_case: bool = True,\n    match_middle: bool = True,\n    complete_style: CompleteStyle = CompleteStyle.COLUMN,\n    validate: Any = None,\n    style: Optional[Style] = None,\n    qcount: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Question:\n    \"\"\"Prompt the user to enter a message with autocomplete help.\n\n    Example:\n        &gt;&gt;&gt; import questionary\n        &gt;&gt;&gt; questionary.autocomplete(\n        ...    'Choose ant specie',\n        ...    choices=[\n        ...         'Camponotus pennsylvanicus',\n        ...         'Linepithema humile',\n        ...         'Eciton burchellii',\n        ...         \"Atta colombica\",\n        ...         'Polyergus lucidus',\n        ...         'Polyergus rufescens',\n        ...    ]).ask()\n        ? Choose ant specie Atta colombica\n        'Atta colombica'\n\n    &lt;img alt=\"../../../../images/autocomplete.gif\" src=\"../../../../images/autocomplete.gif\"&gt;\n\n    This is just a really basic example, the prompt can be customised using the\n    parameters.\n\n\n    Args:\n        message: Question text\n\n        choices: Items shown in the selection, this contains items as strings\n\n        default: Default return value (single value).\n\n        qmark: Question prefix displayed in front of the question.\n               By default this is a ``?``\n\n        completer: A prompt_toolkit [prompt_toolkit.completion.Completion]()\n                   implementation. If not set, a questionary completer implementation\n                   will be used.\n\n        meta_information: A dictionary with information/anything about choices.\n\n        ignore_case: If true autocomplete would ignore case.\n\n        match_middle: If true autocomplete would search in every string position\n                      not only in string begin.\n\n        complete_style: How autocomplete menu would be shown, it could be ``COLUMN``\n                        ``MULTI_COLUMN`` or ``READLINE_LIKE`` from\n                        [prompt_toolkit.shortcuts.CompleteStyle]().\n\n        validate: Require the entered value to pass a validation. The\n                  value can not be submitted until the validator accepts\n                  it (e.g. to check minimum password length).\n\n                  This can either be a function accepting the input and\n                  returning a boolean, or an class reference to a\n                  subclass of the prompt toolkit Validator class.\n\n        style: A custom color and style for the question parts. You can\n               configure colors as well as font types for different elements.\n\n    Returns:\n        [Question](): Question instance, ready to be prompted (using ``.ask()``).\n    \"\"\"\n    merged_style = merge_styles_default([style])\n\n    def get_prompt_tokens() -&gt; List[Tuple[str, str]]:\n        tokens = []\n\n        if qcount is not None:\n            tokens.append((\"class:qcount\", \"{} \".format(qcount)))\n        if isinstance(qmark, list):\n            for x in qmark:\n                tokens.append((x[0], \"{}\".format(x[1])))\n            tokens.append((\"class:qmark\", \" {}\".format(\"\")))\n        elif isinstance(qmark, str) and len(qmark.strip()) &gt; 0:\n            tokens.append((\"class:qmark\", \"{} \".format(qmark)))\n        if isinstance(message, list):\n            for x in message:\n                tokens.append((x[0], \"{}\".format(x[1])))\n        elif isinstance(message, str) and len(message.strip()) &gt; 0:\n            tokens.append((\"class:question\", \"{}\".format(message)))\n        tokens.append((\"class:question\", \" {}\".format(\"\\n\")))\n        return tokens\n\n    def get_meta_style(meta: Optional[Dict[str, Any]]) -&gt; Optional[Dict[str, Any]]:\n        if meta:\n            for key in meta:\n                meta[key] = HTML(\"&lt;text&gt;{}&lt;/text&gt;\").format(meta[key])\n\n        return meta\n\n    validator = build_validator(validate)\n\n    if completer is None:\n        if not choices:\n            raise ValueError(\"No choices is given, you should use Text question.\")\n        # use the default completer\n        completer = WordCompleter(\n            choices,\n            ignore_case=ignore_case,\n            meta_information=get_meta_style(meta_information),\n            match_middle=match_middle,\n        )\n\n    p: PromptSession = PromptSession(\n        get_prompt_tokens,\n        lexer=SimpleLexer(\"class:answer\"),\n        style=merged_style,\n        completer=completer,\n        validator=validator,\n        complete_style=complete_style,\n        **kwargs,\n    )\n    p.default_buffer.reset(Document(default))\n\n    return Question(p.app)\n</code></pre>"},{"location":"reference/questionary/prompts/checkbox/","title":"checkbox.py","text":""},{"location":"reference/questionary/prompts/checkbox/#krupy.questionary.prompts.checkbox.checkbox","title":"<code>checkbox(message, choices, default=None, validate=&lt;function &lt;lambda&gt; at 0x1071091c0&gt;, qmark='?', pointer='\u00bb', style=None, initial_choice=None, use_arrow_keys=True, use_jk_keys=True, use_emacs_keys=True, instruction=None, qcount=None, **kwargs)</code>","text":"<p>Ask the user to select from a list of items.</p> <p>This is a multiselect, the user can choose one, none or many of the items.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import questionary\n&gt;&gt;&gt; questionary.checkbox(\n...    'Select toppings',\n...    choices=[\n...        \"Cheese\",\n...        \"Tomato\",\n...        \"Pineapple\",\n...    ]).ask()\n? Select toppings done (2 selections)\n['Cheese', 'Pineapple']\n</code></pre> <p></p> <p>This is just a really basic example, the prompt can be customised using the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question text</p> required <code>choices</code> <code>Sequence[Union[str, krupy.questionary.prompts.common.Choice, Dict[str, Any]]]</code> <p>Items shown in the selection, this can contain Choice or      or Separator objects or simple items as strings. Passing      Choice objects, allows you to configure the item more      (e.g. preselecting it or disabling it).</p> required <code>default</code> <code>Optional[str]</code> <p>Default return value (single value). If you want to preselect      multiple items, use <code>Choice(\"foo\", checked=True)</code> instead.</p> <code>None</code> <code>validate</code> <code>Callable[[List[str]], Union[bool, str]]</code> <p>Require the entered value to pass a validation. The       value can not be submitted until the validator accepts       it (e.g. to check minimum password length).</p> <pre><code>  This should be a function accepting the input and\n  returning a boolean. Alternatively, the return value\n  may be a string (indicating failure), which contains\n  the error message to be displayed.\n</code></pre> <code>&lt;function &lt;lambda&gt; at 0x1071091c0&gt;</code> <code>qmark</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question prefix displayed in front of the question.    By default this is a <code>?</code>.</p> <code>'?'</code> <code>pointer</code> <code>Optional[str]</code> <p>Pointer symbol in front of the currently highlighted element.      By default this is a <code>\u00bb</code>.      Use <code>None</code> to disable it.</p> <code>'\u00bb'</code> <code>style</code> <code>Optional[prompt_toolkit.styles.style.Style]</code> <p>A custom color and style for the question parts. You can    configure colors as well as font types for different elements.</p> <code>None</code> <code>initial_choice</code> <code>Union[str, krupy.questionary.prompts.common.Choice, Dict[str, Any]]</code> <p>A value corresponding to a selectable item in the choices,             to initially set the pointer position to.</p> <code>None</code> <code>use_arrow_keys</code> <code>bool</code> <p>Allow the user to select items from the list using             arrow keys.</p> <code>True</code> <code>use_jk_keys</code> <code>bool</code> <p>Allow the user to select items from the list using          <code>j</code> (down) and <code>k</code> (up) keys.</p> <code>True</code> <code>use_emacs_keys</code> <code>bool</code> <p>Allow the user to select items from the list using             <code>Ctrl+N</code> (down) and <code>Ctrl+P</code> (up) keys.</p> <code>True</code> <code>instruction</code> <code>Optional[str]</code> <p>A message describing how to navigate the menu.</p> <code>None</code> <p>Returns:</p> Type Description <code>[Question]()</code> <p>Question instance, ready to be prompted (using <code>.ask()</code>).</p> Source code in <code>krupy/questionary/prompts/checkbox.py</code> <pre><code>def checkbox(\n    message: AnyFormattedText,\n    choices: Sequence[Union[str, Choice, Dict[str, Any]]],\n    default: Optional[str] = None,\n    validate: Callable[[List[str]], Union[bool, str]] = lambda a: True,\n    qmark: AnyFormattedText = DEFAULT_QUESTION_PREFIX,\n    pointer: Optional[str] = DEFAULT_SELECTED_POINTER,\n    style: Optional[Style] = None,\n    initial_choice: Optional[Union[str, Choice, Dict[str, Any]]] = None,\n    use_arrow_keys: bool = True,\n    use_jk_keys: bool = True,\n    use_emacs_keys: bool = True,\n    instruction: Optional[str] = None,\n    qcount: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Question:\n    \"\"\"Ask the user to select from a list of items.\n\n    This is a multiselect, the user can choose one, none or many of the\n    items.\n\n    Example:\n        &gt;&gt;&gt; import questionary\n        &gt;&gt;&gt; questionary.checkbox(\n        ...    'Select toppings',\n        ...    choices=[\n        ...        \"Cheese\",\n        ...        \"Tomato\",\n        ...        \"Pineapple\",\n        ...    ]).ask()\n        ? Select toppings done (2 selections)\n        ['Cheese', 'Pineapple']\n\n    &lt;img alt=\"../../../../images/checkbox.gif\" src=\"../../../../images/checkbox.gif\"&gt;\n\n    This is just a really basic example, the prompt can be customised using the\n    parameters.\n\n\n    Args:\n        message: Question text\n\n        choices: Items shown in the selection, this can contain [Choice]() or\n                 or [Separator]() objects or simple items as strings. Passing\n                 [Choice]() objects, allows you to configure the item more\n                 (e.g. preselecting it or disabling it).\n\n        default: Default return value (single value). If you want to preselect\n                 multiple items, use ``Choice(\"foo\", checked=True)`` instead.\n\n        validate: Require the entered value to pass a validation. The\n                  value can not be submitted until the validator accepts\n                  it (e.g. to check minimum password length).\n\n                  This should be a function accepting the input and\n                  returning a boolean. Alternatively, the return value\n                  may be a string (indicating failure), which contains\n                  the error message to be displayed.\n\n        qmark: Question prefix displayed in front of the question.\n               By default this is a ``?``.\n\n        pointer: Pointer symbol in front of the currently highlighted element.\n                 By default this is a ``\u00bb``.\n                 Use ``None`` to disable it.\n\n        style: A custom color and style for the question parts. You can\n               configure colors as well as font types for different elements.\n\n        initial_choice: A value corresponding to a selectable item in the choices,\n                        to initially set the pointer position to.\n\n        use_arrow_keys: Allow the user to select items from the list using\n                        arrow keys.\n\n        use_jk_keys: Allow the user to select items from the list using\n                     `j` (down) and `k` (up) keys.\n\n        use_emacs_keys: Allow the user to select items from the list using\n                        `Ctrl+N` (down) and `Ctrl+P` (up) keys.\n        instruction: A message describing how to navigate the menu.\n\n    Returns:\n        [Question](): Question instance, ready to be prompted (using ``.ask()``).\n    \"\"\"\n\n    if not (use_arrow_keys or use_jk_keys or use_emacs_keys):\n        raise ValueError(\n            \"Some option to move the selection is required. Arrow keys or j/k or \"\n            \"Emacs keys.\"\n        )\n\n    merged_style = merge_styles_default(\n        [\n            # Disable the default inverted colours bottom-toolbar behaviour (for\n            # the error message). However it can be re-enabled with a custom\n            # style.\n            Style([(\"bottom-toolbar\", \"noreverse\")]),\n            style,\n        ]\n    )\n\n    if not callable(validate):\n        raise ValueError(\"validate must be callable\")\n\n    ic = InquirerControl(\n        choices, default, pointer=pointer, initial_choice=initial_choice\n    )\n\n    def get_prompt_tokens() -&gt; List[Tuple[str, str]]:\n        tokens = []\n\n        if qcount is not None:\n            tokens.append((\"class:qcount\", \"{} \".format(qcount)))\n        if isinstance(qmark, list):\n            for x in qmark:\n                tokens.append((x[0], \"{}\".format(x[1])))\n            tokens.append((\"class:qmark\", \" {}\".format(\"\")))\n        elif isinstance(qmark, str) and len(qmark.strip()) &gt; 0:\n            tokens.append((\"class:qmark\", \"{} \".format(qmark)))\n        if isinstance(message, list):\n            for x in message:\n                tokens.append((x[0], \"{}\".format(x[1])))\n        elif isinstance(message, str) and len(message.strip()) &gt; 0:\n            tokens.append((\"class:question\", \"{}\".format(message)))\n        tokens.append((\"class:question\", \" {}\".format(\"\\n\")))\n\n        if ic.is_answered:\n            nbr_selected = len(ic.selected_options)\n            if nbr_selected == 0:\n                tokens.append((\"class:answer\", \"done\"))\n            elif nbr_selected == 1:\n                if isinstance(ic.get_selected_values()[0].title, list):\n                    ts = ic.get_selected_values()[0].title\n                    tokens.append(\n                        (\n                            \"class:answer\",\n                            \"\".join([token[1] for token in ts]),  # type:ignore\n                        )\n                    )\n                else:\n                    tokens.append(\n                        (\n                            \"class:answer\",\n                            \"[{}]\".format(ic.get_selected_values()[0].title),\n                        )\n                    )\n            else:\n                tokens.append(\n                    (\"class:answer\", \"done ({} selections)\".format(nbr_selected))\n                )\n        else:\n            if instruction is not None:\n                tokens.append((\"class:instruction\", instruction))\n            else:\n                tokens.append(\n                    (\n                        \"class:instruction\",\n                        \"(Use arrow keys to move, \"\n                        \"&lt;space&gt; to select, \"\n                        \"&lt;a&gt; to toggle, \"\n                        \"&lt;i&gt; to invert)\",\n                    )\n                )\n        return tokens\n\n    def get_selected_values() -&gt; List[Any]:\n        return [c.value for c in ic.get_selected_values()]\n\n    def perform_validation(selected_values: List[str]) -&gt; bool:\n        verdict = validate(selected_values)\n        valid = verdict is True\n\n        if not valid:\n            if verdict is False:\n                error_text = INVALID_INPUT\n            else:\n                error_text = str(verdict)\n\n            error_message = FormattedText([(\"class:validation-toolbar\", error_text)])\n\n        ic.error_message = (\n            error_message if not valid and ic.submission_attempted else None  # type: ignore[assignment]\n        )\n\n        return valid\n\n    layout = common.create_inquirer_layout(ic, get_prompt_tokens, **kwargs)\n\n    bindings = KeyBindings()\n\n    @bindings.add(Keys.ControlQ, eager=True)\n    @bindings.add(Keys.ControlC, eager=True)\n    def _(event):\n        event.app.exit(exception=KeyboardInterrupt, style=\"class:aborting\")\n\n    @bindings.add(\" \", eager=True)\n    def toggle(_event):\n        pointed_choice = ic.get_pointed_at().value\n        if pointed_choice in ic.selected_options:\n            ic.selected_options.remove(pointed_choice)\n        else:\n            ic.selected_options.append(pointed_choice)\n\n        perform_validation(get_selected_values())\n\n    @bindings.add(\"i\", eager=True)\n    def invert(_event):\n        inverted_selection = [\n            c.value\n            for c in ic.choices\n            if not isinstance(c, Separator)\n            and c.value not in ic.selected_options\n            and not c.disabled\n        ]\n        ic.selected_options = inverted_selection\n\n        perform_validation(get_selected_values())\n\n    @bindings.add(\"a\", eager=True)\n    def all(_event):\n        all_selected = True  # all choices have been selected\n        for c in ic.choices:\n            if (\n                not isinstance(c, Separator)\n                and c.value not in ic.selected_options\n                and not c.disabled\n            ):\n                # add missing ones\n                ic.selected_options.append(c.value)\n                all_selected = False\n        if all_selected:\n            ic.selected_options = []\n\n        perform_validation(get_selected_values())\n\n    def move_cursor_down(event):\n        ic.select_next()\n        while not ic.is_selection_valid():\n            ic.select_next()\n\n    def move_cursor_up(event):\n        ic.select_previous()\n        while not ic.is_selection_valid():\n            ic.select_previous()\n\n    if use_arrow_keys:\n        bindings.add(Keys.Down, eager=True)(move_cursor_down)\n        bindings.add(Keys.Up, eager=True)(move_cursor_up)\n\n    if use_jk_keys:\n        bindings.add(\"j\", eager=True)(move_cursor_down)\n        bindings.add(\"k\", eager=True)(move_cursor_up)\n\n    if use_emacs_keys:\n        bindings.add(Keys.ControlN, eager=True)(move_cursor_down)\n        bindings.add(Keys.ControlP, eager=True)(move_cursor_up)\n\n    @bindings.add(Keys.ControlM, eager=True)\n    def set_answer(event):\n        selected_values = get_selected_values()\n        ic.submission_attempted = True\n\n        if perform_validation(selected_values):\n            ic.is_answered = True\n            event.app.exit(result=selected_values)\n\n    @bindings.add(Keys.Any)\n    def other(_event):\n        \"\"\"Disallow inserting other text.\"\"\"\n\n    return Question(\n        Application(\n            layout=layout,\n            key_bindings=bindings,\n            style=merged_style,\n            **utils.used_kwargs(kwargs, Application.__init__),\n        )\n    )\n</code></pre>"},{"location":"reference/questionary/prompts/common/","title":"common.py","text":""},{"location":"reference/questionary/prompts/common/#krupy.questionary.prompts.common.Choice","title":"<code> Choice        </code>","text":"<p>One choice in a [select]](), rawselect or checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Text shown in the selection list.</p> required <code>value</code> <code>Optional[Any]</code> <p>Value returned, when the choice is selected. If this argument    is <code>None</code> or unset, then the value of <code>title</code> is used.</p> <code>None</code> <code>disabled</code> <code>Optional[str]</code> <p>If set, the choice can not be selected by the user. The       provided text is used to explain, why the selection is       disabled.</p> <code>None</code> <code>checked</code> <code>Optional[bool]</code> <p>Preselect this choice when displaying the options.</p> <code>False</code> <code>shortcut_key</code> <code>Union[str, bool]</code> <p>Key shortcut used to select this item.</p> <code>True</code> Source code in <code>krupy/questionary/prompts/common.py</code> <pre><code>class Choice:\n    \"\"\"One choice in a [select]](), [rawselect]() or [checkbox]().\n\n    Args:\n        title: Text shown in the selection list.\n\n        value: Value returned, when the choice is selected. If this argument\n               is `None` or unset, then the value of `title` is used.\n\n        disabled: If set, the choice can not be selected by the user. The\n                  provided text is used to explain, why the selection is\n                  disabled.\n\n        checked: Preselect this choice when displaying the options.\n\n        shortcut_key: Key shortcut used to select this item.\n    \"\"\"\n\n    title: AnyFormattedText\n    \"\"\"Display string for the choice\"\"\"\n\n    value: Optional[Any]\n    \"\"\"Value of the choice\"\"\"\n\n    disabled: Optional[str]\n    \"\"\"Whether the choice can be selected\"\"\"\n\n    checked: Optional[bool]\n    \"\"\"Whether the choice is initially selected\"\"\"\n\n    shortcut_key: Optional[str]\n    \"\"\"A shortcut key for the choice\"\"\"\n\n    def __init__(\n        self,\n        title: AnyFormattedText,\n        value: Optional[Any] = None,\n        disabled: Optional[str] = None,\n        checked: Optional[bool] = False,\n        shortcut_key: Optional[Union[str, bool]] = True,\n    ) -&gt; None:\n        self.disabled = disabled\n        self.title = title\n        self.checked = checked if checked is not None else False\n\n        if value is not None:\n            self.value = value\n        elif isinstance(title, list):\n            self.value = \"\".join([token[1] for token in title])\n        else:\n            self.value = title\n\n        if shortcut_key is not None:\n            if isinstance(shortcut_key, bool):\n                self.auto_shortcut = shortcut_key\n                self.shortcut_key = None\n            else:\n                self.shortcut_key = str(shortcut_key)\n                self.auto_shortcut = False\n        else:\n            self.shortcut_key = None\n            self.auto_shortcut = True\n\n    @staticmethod\n    def build(c: Union[str, \"Choice\", Dict[str, Any]]) -&gt; \"Choice\":\n        \"\"\"Create a choice object from different representations.\n\n        Args:\n            c: Either a :obj:`str`, [Choice]() or :obj:`dict` with\n               ``name``, ``value``, ``disabled``, ``checked`` and\n               ``key`` properties.\n\n        Returns:\n            An instance of the [Choice]() object.\n        \"\"\"\n\n        if isinstance(c, Choice):\n            return c\n        elif isinstance(c, str):\n            return Choice(c, c)\n        else:\n            return Choice(\n                c.get(\"name\"),\n                c.get(\"value\"),\n                c.get(\"disabled\", None),\n                c.get(\"checked\"),\n                c.get(\"key\"),\n            )\n\n    def get_shortcut_title(self):\n        if self.shortcut_key is None:\n            return \"-) \"\n        else:\n            return \"{}) \".format(self.shortcut_key)\n</code></pre>"},{"location":"reference/questionary/prompts/common/#krupy.questionary.prompts.common.Choice.build","title":"<code>build(c)</code>  <code>staticmethod</code>","text":"<p>Create a choice object from different representations.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>Union[str, Choice, Dict[str, Any]]</code> <p>Either a :obj:<code>str</code>, Choice or :obj:<code>dict</code> with <code>name</code>, <code>value</code>, <code>disabled</code>, <code>checked</code> and <code>key</code> properties.</p> required <p>Returns:</p> Type Description <code>Choice</code> <p>An instance of the Choice object.</p> Source code in <code>krupy/questionary/prompts/common.py</code> <pre><code>@staticmethod\ndef build(c: Union[str, \"Choice\", Dict[str, Any]]) -&gt; \"Choice\":\n    \"\"\"Create a choice object from different representations.\n\n    Args:\n        c: Either a :obj:`str`, [Choice]() or :obj:`dict` with\n           ``name``, ``value``, ``disabled``, ``checked`` and\n           ``key`` properties.\n\n    Returns:\n        An instance of the [Choice]() object.\n    \"\"\"\n\n    if isinstance(c, Choice):\n        return c\n    elif isinstance(c, str):\n        return Choice(c, c)\n    else:\n        return Choice(\n            c.get(\"name\"),\n            c.get(\"value\"),\n            c.get(\"disabled\", None),\n            c.get(\"checked\"),\n            c.get(\"key\"),\n        )\n</code></pre>"},{"location":"reference/questionary/prompts/common/#krupy.questionary.prompts.common.Separator","title":"<code> Separator            (Choice)         </code>","text":"<p>Used to space/separate choices group.</p> Source code in <code>krupy/questionary/prompts/common.py</code> <pre><code>class Separator(Choice):\n    \"\"\"Used to space/separate choices group.\"\"\"\n\n    default_separator: str = \"-\" * 15\n    \"\"\"The default separator used if none is specified\"\"\"\n\n    line: str\n    \"\"\"The string being used as a separator\"\"\"\n\n    def __init__(self, line: Optional[str] = None) -&gt; None:\n        \"\"\"Create a separator in a list.\n\n        Args:\n            line: Text to be displayed in the list, by default uses ``---``.\n        \"\"\"\n\n        self.line = line or self.default_separator\n        super().__init__(self.line, None, \"-\")\n</code></pre>"},{"location":"reference/questionary/prompts/common/#krupy.questionary.prompts.common.Separator.default_separator","title":"<code>default_separator: str</code>","text":"<p>The default separator used if none is specified</p>"},{"location":"reference/questionary/prompts/common/#krupy.questionary.prompts.common.Separator.__init__","title":"<code>__init__(self, line=None)</code>  <code>special</code>","text":"<p>Create a separator in a list.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>Optional[str]</code> <p>Text to be displayed in the list, by default uses <code>---</code>.</p> <code>None</code> Source code in <code>krupy/questionary/prompts/common.py</code> <pre><code>def __init__(self, line: Optional[str] = None) -&gt; None:\n    \"\"\"Create a separator in a list.\n\n    Args:\n        line: Text to be displayed in the list, by default uses ``---``.\n    \"\"\"\n\n    self.line = line or self.default_separator\n    super().__init__(self.line, None, \"-\")\n</code></pre>"},{"location":"reference/questionary/prompts/common/#krupy.questionary.prompts.common.create_inquirer_layout","title":"<code>create_inquirer_layout(ic, get_prompt_tokens, **kwargs)</code>","text":"<p>Create a layout combining question and inquirer selection.</p> Source code in <code>krupy/questionary/prompts/common.py</code> <pre><code>def create_inquirer_layout(\n    ic: InquirerControl,\n    get_prompt_tokens: Callable[[], List[Tuple[str, str]]],\n    **kwargs: Any,\n) -&gt; Layout:\n    \"\"\"Create a layout combining question and inquirer selection.\"\"\"\n\n    ps: PromptSession = PromptSession(\n        get_prompt_tokens, reserve_space_for_menu=0, **kwargs\n    )\n    _fix_unecessary_blank_lines(ps)\n\n    validation_prompt: PromptSession = PromptSession(\n        bottom_toolbar=lambda: ic.error_message, **kwargs\n    )\n\n    return Layout(\n        HSplit(\n            [\n                ps.layout.container,\n                ConditionalContainer(Window(ic), filter=~IsDone()),\n                ConditionalContainer(\n                    validation_prompt.layout.container,\n                    filter=Condition(lambda: ic.error_message is not None),\n                ),\n            ]\n        )\n    )\n</code></pre>"},{"location":"reference/questionary/prompts/common/#krupy.questionary.prompts.common.print_formatted_text","title":"<code>print_formatted_text(text, style=None, **kwargs)</code>","text":"<p>Print formatted text.</p> <p>Sometimes you want to spice up your printed messages a bit, questionary.print is a helper to do just that.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import questionary\n&gt;&gt;&gt; questionary.print(\"Hello World \ud83e\udd84\", style=\"bold italic fg:darkred\")\nHello World \ud83e\udd84\n</code></pre> <p></p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to be printed.</p> required <code>style</code> <code>Optional[str]</code> <p>Style used for printing. The style argument uses the prompt :ref:<code>toolkit style strings &lt;prompt_toolkit:styling&gt;</code>.</p> <code>None</code> Source code in <code>krupy/questionary/prompts/common.py</code> <pre><code>def print_formatted_text(text: str, style: Optional[str] = None, **kwargs: Any) -&gt; None:\n    \"\"\"Print formatted text.\n\n    Sometimes you want to spice up your printed messages a bit,\n    [questionary.print]() is a helper to do just that.\n\n    Example:\n\n        &gt;&gt;&gt; import questionary\n        &gt;&gt;&gt; questionary.print(\"Hello World \ud83e\udd84\", style=\"bold italic fg:darkred\")\n        Hello World \ud83e\udd84\n\n    &lt;img alt=\"../../../../images/print.gif\" src=\"../../../../images/print.gif\"&gt;\n\n    Args:\n        text: Text to be printed.\n        style: Style used for printing. The style argument uses the\n            prompt :ref:`toolkit style strings &lt;prompt_toolkit:styling&gt;`.\n    \"\"\"\n    from prompt_toolkit import print_formatted_text as pt_print\n    from prompt_toolkit.formatted_text import FormattedText as FText\n\n    if style is not None:\n        text_style = Style([(\"text\", style)])\n    else:\n        text_style = DEFAULT_STYLE\n\n    pt_print(FText([(\"class:text\", text)]), style=text_style, **kwargs)\n</code></pre>"},{"location":"reference/questionary/prompts/confirm/","title":"confirm.py","text":""},{"location":"reference/questionary/prompts/confirm/#krupy.questionary.prompts.confirm.confirm","title":"<code>confirm(message, default=True, qmark='?', style=None, auto_enter=True, instruction=None, qcount=None, **kwargs)</code>","text":"<p>A yes or no question. The user can either confirm or deny.</p> <p>This question type can be used to prompt the user for a confirmation of a yes-or-no question. If the user just hits enter, the default value will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import questionary\n&gt;&gt;&gt; questionary.confirm(\"Are you amazed?\").ask()\n? Are you amazed? Yes\nTrue\n</code></pre> <p></p> <p>This is just a really basic example, the prompt can be customised using the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question text.</p> required <code>default</code> <code>bool</code> <p>Default value will be returned if the user just hits      enter.</p> <code>True</code> <code>qmark</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question prefix displayed in front of the question.    By default this is a <code>?</code>.</p> <code>'?'</code> <code>style</code> <code>Optional[prompt_toolkit.styles.style.Style]</code> <p>A custom color and style for the question parts. You can    configure colors as well as font types for different elements.</p> <code>None</code> <code>auto_enter</code> <code>bool</code> <p>If set to <code>False</code>, the user needs to press the 'enter' key to accept their answer. If set to <code>True</code>, a valid input will be accepted without the need to press 'Enter'.</p> <code>True</code> <code>instruction</code> <code>Optional[str]</code> <p>A message describing how to proceed through the          confirmation prompt.</p> <code>None</code> <p>Returns:</p> Type Description <code>[Question]()</code> <p>Question instance, ready to be prompted (using <code>.ask()</code>).</p> Source code in <code>krupy/questionary/prompts/confirm.py</code> <pre><code>def confirm(\n    message: AnyFormattedText,\n    default: bool = True,\n    qmark: AnyFormattedText = DEFAULT_QUESTION_PREFIX,\n    style: Optional[Style] = None,\n    auto_enter: bool = True,\n    instruction: Optional[str] = None,\n    qcount: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Question:\n    \"\"\"A yes or no question. The user can either confirm or deny.\n\n    This question type can be used to prompt the user for a confirmation\n    of a yes-or-no question. If the user just hits enter, the default\n    value will be returned.\n\n    Example:\n        &gt;&gt;&gt; import questionary\n        &gt;&gt;&gt; questionary.confirm(\"Are you amazed?\").ask()\n        ? Are you amazed? Yes\n        True\n\n    &lt;img alt=\"../../../../images/confirm.gif\" src=\"../../../../images/confirm.gif\"&gt;\n\n    This is just a really basic example, the prompt can be customised using the\n    parameters.\n\n\n    Args:\n        message: Question text.\n\n        default: Default value will be returned if the user just hits\n                 enter.\n\n        qmark: Question prefix displayed in front of the question.\n               By default this is a ``?``.\n\n        style: A custom color and style for the question parts. You can\n               configure colors as well as font types for different elements.\n\n        auto_enter: If set to `False`, the user needs to press the 'enter' key to\n            accept their answer. If set to `True`, a valid input will be\n            accepted without the need to press 'Enter'.\n\n        instruction: A message describing how to proceed through the\n                     confirmation prompt.\n    Returns:\n        [Question](): Question instance, ready to be prompted (using `.ask()`).\n    \"\"\"\n    merged_style = merge_styles_default([style])\n\n    status = {\"answer\": None, \"complete\": False}\n\n    def get_prompt_tokens():\n        tokens = []\n\n        if qcount is not None:\n            tokens.append((\"class:qcount\", \"{} \".format(qcount)))\n        if isinstance(qmark, list):\n            for x in qmark:\n                tokens.append((x[0], \"{}\".format(x[1])))\n            tokens.append((\"class:qmark\", \" {}\".format(\"\")))\n        elif isinstance(qmark, str) and len(qmark.strip()) &gt; 0:\n            tokens.append((\"class:qmark\", \"{} \".format(qmark)))\n        if isinstance(message, list):\n            for x in message:\n                tokens.append((x[0], \"{}\".format(x[1])))\n        elif isinstance(message, str) and len(message.strip()) &gt; 0:\n            tokens.append((\"class:question\", \"{}\".format(message)))\n        tokens.append((\"class:question\", \" {}\".format(\"\\n\")))\n\n        if instruction is not None:\n            tokens.append((\"class:instruction\", instruction))\n        elif not status[\"complete\"]:\n            _instruction = YES_OR_NO if default else NO_OR_YES\n            tokens.append((\"class:instruction\", \"{} \".format(_instruction)))\n\n        if status[\"answer\"] is not None:\n            answer = YES if status[\"answer\"] else NO\n            tokens.append((\"class:answer\", answer))\n\n        return to_formatted_text(tokens)\n\n    def exit_with_result(event):\n        status[\"complete\"] = True\n        event.app.exit(result=status[\"answer\"])\n\n    bindings = KeyBindings()\n\n    @bindings.add(Keys.ControlQ, eager=True)\n    @bindings.add(Keys.ControlC, eager=True)\n    def _(event):\n        event.app.exit(exception=KeyboardInterrupt, style=\"class:aborting\")\n\n    @bindings.add(\"n\")\n    @bindings.add(\"N\")\n    def key_n(event):\n        status[\"answer\"] = False\n        if auto_enter:\n            exit_with_result(event)\n\n    @bindings.add(\"y\")\n    @bindings.add(\"Y\")\n    def key_y(event):\n        status[\"answer\"] = True\n        if auto_enter:\n            exit_with_result(event)\n\n    @bindings.add(Keys.ControlH)\n    def key_backspace(event):\n        status[\"answer\"] = None\n\n    @bindings.add(Keys.ControlM, eager=True)\n    def set_answer(event):\n        if status[\"answer\"] is None:\n            status[\"answer\"] = default\n\n        exit_with_result(event)\n\n    @bindings.add(Keys.Any)\n    def other(event):\n        \"\"\"Disallow inserting other text.\"\"\"\n\n    return Question(\n        PromptSession(\n            get_prompt_tokens, key_bindings=bindings, style=merged_style, **kwargs\n        ).app\n    )\n</code></pre>"},{"location":"reference/questionary/prompts/password/","title":"password.py","text":""},{"location":"reference/questionary/prompts/password/#krupy.questionary.prompts.password.password","title":"<code>password(message, default='', validate=None, qmark='?', style=None, qcount=None, **kwargs)</code>","text":"<p>A text input where a user can enter a secret which won't be displayed on the CLI.</p> <p>This question type can be used to prompt the user for information that should not be shown in the command line. The typed text will be replaced with <code>*</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import questionary\n&gt;&gt;&gt; questionary.password(\"What's your secret?\").ask()\n? What's your secret? ********\n'secret42'\n</code></pre> <p></p> <p>This is just a really basic example, the prompt can be customised using the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question text.</p> required <code>default</code> <code>str</code> <p>Default value will be returned if the user just hits      enter.</p> <code>''</code> <code>validate</code> <code>Any</code> <p>Require the entered value to pass a validation. The       value can not be submitted until the validator accepts       it (e.g. to check minimum password length).</p> <pre><code>  This can either be a function accepting the input and\n  returning a boolean, or an class reference to a\n  subclass of the prompt toolkit Validator class.\n</code></pre> <code>None</code> <code>qmark</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question prefix displayed in front of the question.    By default this is a <code>?</code>.</p> <code>'?'</code> <code>style</code> <code>Optional[prompt_toolkit.styles.style.Style]</code> <p>A custom color and style for the question parts. You can    configure colors as well as font types for different elements.</p> <code>None</code> <p>Returns:</p> Type Description <code>[Question]()</code> <p>Question instance, ready to be prompted (using <code>.ask()</code>).</p> Source code in <code>krupy/questionary/prompts/password.py</code> <pre><code>def password(\n    message: AnyFormattedText,\n    default: str = \"\",\n    validate: Any = None,\n    qmark: AnyFormattedText = DEFAULT_QUESTION_PREFIX,\n    style: Optional[Style] = None,\n    qcount: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Question:\n    \"\"\"A text input where a user can enter a secret which won't be displayed on the CLI.\n\n    This question type can be used to prompt the user for information\n    that should not be shown in the command line. The typed text will be\n    replaced with ``*``.\n\n    Example:\n        &gt;&gt;&gt; import questionary\n        &gt;&gt;&gt; questionary.password(\"What's your secret?\").ask()\n        ? What's your secret? ********\n        'secret42'\n\n    &lt;img alt=\"../../../../images/password.gif\" src=\"../../../../images/password.gif\"&gt;\n\n    This is just a really basic example, the prompt can be customised using the\n    parameters.\n\n    Args:\n        message: Question text.\n\n        default: Default value will be returned if the user just hits\n                 enter.\n\n        validate: Require the entered value to pass a validation. The\n                  value can not be submitted until the validator accepts\n                  it (e.g. to check minimum password length).\n\n                  This can either be a function accepting the input and\n                  returning a boolean, or an class reference to a\n                  subclass of the prompt toolkit Validator class.\n\n        qmark: Question prefix displayed in front of the question.\n               By default this is a ``?``.\n\n        style: A custom color and style for the question parts. You can\n               configure colors as well as font types for different elements.\n\n    Returns:\n        [Question](): Question instance, ready to be prompted (using ``.ask()``).\n    \"\"\"\n\n    return text.text(\n        message,\n        default,\n        validate,\n        qmark,\n        style,\n        qcount,\n        is_password=True,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/questionary/prompts/path/","title":"path.py","text":""},{"location":"reference/questionary/prompts/path/#krupy.questionary.prompts.path.GreatUXPathCompleter","title":"<code> GreatUXPathCompleter            (PathCompleter)         </code>","text":"<p>Wraps prompt_toolkit.completion.PathCompleter.</p> <p>Makes sure completions for directories end with a path separator. Also make sure the right path separator is used. Checks if <code>get_paths</code> returns list of existing directories.</p> Source code in <code>krupy/questionary/prompts/path.py</code> <pre><code>class GreatUXPathCompleter(PathCompleter):\n    \"\"\"Wraps [prompt_toolkit.completion.PathCompleter]().\n\n    Makes sure completions for directories end with a path separator. Also make sure\n    the right path separator is used. Checks if `get_paths` returns list of existing\n    directories.\n    \"\"\"\n\n    def __init__(\n        self,\n        only_directories: bool = False,\n        get_paths: Optional[Callable[[], List[str]]] = None,\n        file_filter: Optional[Callable[[str], bool]] = None,\n        min_input_len: int = 0,\n        expanduser: bool = False,\n    ) -&gt; None:\n        \"\"\"Adds validation of 'get_paths' to [prompt_toolkit.completion.PathCompleter]().\n\n        Args:\n            only_directories (bool): If True, only directories will be\n                returned, but no files. Defaults to False.\n            get_paths (Callable[[], List[str]], optional): Callable which\n                returns a list of directories to look into when the user enters a\n                relative path. If None, set to (lambda: [\".\"]). Defaults to None.\n            file_filter (Callable[[str], bool], optional): Callable which\n                takes a filename and returns whether this file should show up in the\n                completion. ``None`` when no filtering has to be done. Defaults to None.\n            min_input_len (int): Don't do autocompletion when the input string\n                is shorter. Defaults to 0.\n            expanduser (bool): If True, tilde (~) is expanded. Defaults to\n                False.\n\n        Raises:\n            ValueError: If any of the by `get_paths` returned directories does not\n                exist.\n        \"\"\"\n        # if get_paths is None, make it return the current working dir\n        get_paths = get_paths or (lambda: [\".\"])\n        # validation of get_paths\n        for current_path in get_paths():\n            if not os.path.isdir(current_path):\n                raise (\n                    ValueError(\n                        \"\\n Completer for file paths 'get_paths' must return only existing directories, but\"\n                        f\" '{current_path}' does not exist.\"\n                    )\n                )\n        # call PathCompleter __init__\n        super().__init__(\n            only_directories=only_directories,\n            get_paths=get_paths,\n            file_filter=file_filter,\n            min_input_len=min_input_len,\n            expanduser=expanduser,\n        )\n\n    def get_completions(\n        self, document: Document, complete_event: CompleteEvent\n    ) -&gt; Iterable[Completion]:\n        \"\"\"Get completions.\n\n        Wraps [prompt_toolkit.completion.PathCompleter](). Makes sure completions\n        for directories end with a path separator. Also make sure the right path\n        separator is used.\n        \"\"\"\n        completions = super(GreatUXPathCompleter, self).get_completions(\n            document, complete_event\n        )\n\n        for completion in completions:\n            # check if the display value ends with a path separator.\n            # first check if display is properly set\n            styled_display = completion.display[0]\n            # styled display is a formatted text (a tuple of the text and its style)\n            # second tuple entry is the text\n            if styled_display[1][-1] == \"/\":\n                # replace separator with the OS specific one\n                display_text = styled_display[1][:-1] + os.path.sep\n                # update the styled display with the modified text\n                completion.display[0] = (styled_display[0], display_text)\n                # append the separator to the text as well - unclear why the normal\n                # path completer omits it from the text. this improves UX for the\n                # user, as they don't need to type the separator after auto-completing\n                # a directory\n                completion.text += os.path.sep\n            yield completion\n</code></pre>"},{"location":"reference/questionary/prompts/path/#krupy.questionary.prompts.path.GreatUXPathCompleter.__init__","title":"<code>__init__(self, only_directories=False, get_paths=None, file_filter=None, min_input_len=0, expanduser=False)</code>  <code>special</code>","text":"<p>Adds validation of 'get_paths' to prompt_toolkit.completion.PathCompleter.</p> <p>Parameters:</p> Name Type Description Default <code>only_directories</code> <code>bool</code> <p>If True, only directories will be returned, but no files. Defaults to False.</p> <code>False</code> <code>get_paths</code> <code>Callable[[], List[str]]</code> <p>Callable which returns a list of directories to look into when the user enters a relative path. If None, set to (lambda: [\".\"]). Defaults to None.</p> <code>None</code> <code>file_filter</code> <code>Callable[[str], bool]</code> <p>Callable which takes a filename and returns whether this file should show up in the completion. <code>None</code> when no filtering has to be done. Defaults to None.</p> <code>None</code> <code>min_input_len</code> <code>int</code> <p>Don't do autocompletion when the input string is shorter. Defaults to 0.</p> <code>0</code> <code>expanduser</code> <code>bool</code> <p>If True, tilde (~) is expanded. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If any of the by <code>get_paths</code> returned directories does not exist.</p> Source code in <code>krupy/questionary/prompts/path.py</code> <pre><code>def __init__(\n    self,\n    only_directories: bool = False,\n    get_paths: Optional[Callable[[], List[str]]] = None,\n    file_filter: Optional[Callable[[str], bool]] = None,\n    min_input_len: int = 0,\n    expanduser: bool = False,\n) -&gt; None:\n    \"\"\"Adds validation of 'get_paths' to [prompt_toolkit.completion.PathCompleter]().\n\n    Args:\n        only_directories (bool): If True, only directories will be\n            returned, but no files. Defaults to False.\n        get_paths (Callable[[], List[str]], optional): Callable which\n            returns a list of directories to look into when the user enters a\n            relative path. If None, set to (lambda: [\".\"]). Defaults to None.\n        file_filter (Callable[[str], bool], optional): Callable which\n            takes a filename and returns whether this file should show up in the\n            completion. ``None`` when no filtering has to be done. Defaults to None.\n        min_input_len (int): Don't do autocompletion when the input string\n            is shorter. Defaults to 0.\n        expanduser (bool): If True, tilde (~) is expanded. Defaults to\n            False.\n\n    Raises:\n        ValueError: If any of the by `get_paths` returned directories does not\n            exist.\n    \"\"\"\n    # if get_paths is None, make it return the current working dir\n    get_paths = get_paths or (lambda: [\".\"])\n    # validation of get_paths\n    for current_path in get_paths():\n        if not os.path.isdir(current_path):\n            raise (\n                ValueError(\n                    \"\\n Completer for file paths 'get_paths' must return only existing directories, but\"\n                    f\" '{current_path}' does not exist.\"\n                )\n            )\n    # call PathCompleter __init__\n    super().__init__(\n        only_directories=only_directories,\n        get_paths=get_paths,\n        file_filter=file_filter,\n        min_input_len=min_input_len,\n        expanduser=expanduser,\n    )\n</code></pre>"},{"location":"reference/questionary/prompts/path/#krupy.questionary.prompts.path.GreatUXPathCompleter.get_completions","title":"<code>get_completions(self, document, complete_event)</code>","text":"<p>Get completions.</p> <p>Wraps prompt_toolkit.completion.PathCompleter. Makes sure completions for directories end with a path separator. Also make sure the right path separator is used.</p> Source code in <code>krupy/questionary/prompts/path.py</code> <pre><code>def get_completions(\n    self, document: Document, complete_event: CompleteEvent\n) -&gt; Iterable[Completion]:\n    \"\"\"Get completions.\n\n    Wraps [prompt_toolkit.completion.PathCompleter](). Makes sure completions\n    for directories end with a path separator. Also make sure the right path\n    separator is used.\n    \"\"\"\n    completions = super(GreatUXPathCompleter, self).get_completions(\n        document, complete_event\n    )\n\n    for completion in completions:\n        # check if the display value ends with a path separator.\n        # first check if display is properly set\n        styled_display = completion.display[0]\n        # styled display is a formatted text (a tuple of the text and its style)\n        # second tuple entry is the text\n        if styled_display[1][-1] == \"/\":\n            # replace separator with the OS specific one\n            display_text = styled_display[1][:-1] + os.path.sep\n            # update the styled display with the modified text\n            completion.display[0] = (styled_display[0], display_text)\n            # append the separator to the text as well - unclear why the normal\n            # path completer omits it from the text. this improves UX for the\n            # user, as they don't need to type the separator after auto-completing\n            # a directory\n            completion.text += os.path.sep\n        yield completion\n</code></pre>"},{"location":"reference/questionary/prompts/path/#krupy.questionary.prompts.path.path","title":"<code>path(message, default='', qmark='?', validate=None, completer=None, style=None, only_directories=False, get_paths=None, file_filter=None, complete_style=&lt;CompleteStyle.MULTI_COLUMN: 'MULTI_COLUMN'&gt;, qcount=None, **kwargs)</code>","text":"<p>A text input for a file or directory path with autocompletion enabled.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import questionary\n&gt;&gt;&gt; questionary.path(\n&gt;&gt;&gt;    \"What's the path to the projects version file?\"\n&gt;&gt;&gt; ).ask()\n? What's the path to the projects version file? ./pyproject.toml\n'./pyproject.toml'\n</code></pre> <p></p> <p>This is just a really basic example, the prompt can be customized using the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question text.</p> required <code>default</code> <code>str</code> <p>Default return value (single value).</p> <code>''</code> <code>qmark</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question prefix displayed in front of the question.    By default this is a <code>?</code>.</p> <code>'?'</code> <code>complete_style</code> <code>CompleteStyle</code> <p>How autocomplete menu would be shown, it could be <code>COLUMN</code> <code>MULTI_COLUMN</code> or <code>READLINE_LIKE</code> from             prompt_toolkit.shortcuts.CompleteStyle.</p> <code>&lt;CompleteStyle.MULTI_COLUMN: 'MULTI_COLUMN'&gt;</code> <code>validate</code> <code>Any</code> <p>Require the entered value to pass a validation. The       value can not be submitted until the validator accepts       it (e.g. to check minimum password length).</p> <pre><code>  This can either be a function accepting the input and\n  returning a boolean, or an class reference to a\n  subclass of the prompt toolkit Validator class.\n</code></pre> <code>None</code> <code>completer</code> <code>Optional[prompt_toolkit.completion.base.Completer]</code> <p>A custom completer to use in the prompt. For more information,        see <code>this &lt;https://python-prompt-toolkit.readthedocs.io/en/master/pages/asking_for_input.html#a-custom-completer&gt;</code>_.</p> <code>None</code> <code>style</code> <code>Optional[prompt_toolkit.styles.style.Style]</code> <p>A custom color and style for the question parts. You can    configure colors as well as font types for different elements.</p> <code>None</code> <code>only_directories</code> <code>bool</code> <p>Only show directories in auto completion. This option               does not do anything if a custom <code>completer</code> is               passed.</p> <code>False</code> <code>get_paths</code> <code>Optional[Callable[[], List[str]]]</code> <p>Set a callable to generate paths to traverse for suggestions. This option        does not do anything if a custom <code>completer</code> is        passed.</p> <code>None</code> <code>file_filter</code> <code>Optional[Callable[[str], bool]]</code> <p>Optional callable to filter suggested paths. Only paths          where the passed callable evaluates to <code>True</code> will show up in          the suggested paths. This does not validate the typed path, e.g.          it is still possible for the user to enter a path manually, even          though this filter evaluates to <code>False</code>. If in addition to          filtering suggestions you also want to validate the result, use          <code>validate</code> in combination with the <code>file_filter</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>[Question]()</code> <p>Question instance, ready to be prompted (using <code>.ask()</code>).</p> Source code in <code>krupy/questionary/prompts/path.py</code> <pre><code>def path(\n    message: AnyFormattedText,\n    default: str = \"\",\n    qmark: AnyFormattedText = DEFAULT_QUESTION_PREFIX,\n    validate: Any = None,\n    completer: Optional[Completer] = None,\n    style: Optional[Style] = None,\n    only_directories: bool = False,\n    get_paths: Optional[Callable[[], List[str]]] = None,\n    file_filter: Optional[Callable[[str], bool]] = None,\n    complete_style: CompleteStyle = CompleteStyle.MULTI_COLUMN,\n    qcount: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Question:\n    \"\"\"A text input for a file or directory path with autocompletion enabled.\n\n    Example:\n        &gt;&gt;&gt; import questionary\n        &gt;&gt;&gt; questionary.path(\n        &gt;&gt;&gt;    \"What's the path to the projects version file?\"\n        &gt;&gt;&gt; ).ask()\n        ? What's the path to the projects version file? ./pyproject.toml\n        './pyproject.toml'\n\n    &lt;img alt=\"../../../../images/path.gif\" src=\"../../../../images/path.gif\"&gt;\n\n    This is just a really basic example, the prompt can be customized using the\n    parameters.\n\n    Args:\n        message: Question text.\n\n        default: Default return value (single value).\n\n        qmark: Question prefix displayed in front of the question.\n               By default this is a ``?``.\n\n        complete_style: How autocomplete menu would be shown, it could be ``COLUMN``\n                        ``MULTI_COLUMN`` or ``READLINE_LIKE`` from\n                        [prompt_toolkit.shortcuts.CompleteStyle]().\n\n        validate: Require the entered value to pass a validation. The\n                  value can not be submitted until the validator accepts\n                  it (e.g. to check minimum password length).\n\n                  This can either be a function accepting the input and\n                  returning a boolean, or an class reference to a\n                  subclass of the prompt toolkit Validator class.\n\n        completer: A custom completer to use in the prompt. For more information,\n                   see `this &lt;https://python-prompt-toolkit.readthedocs.io/en/master/pages/asking_for_input.html#a-custom-completer&gt;`_.\n\n        style: A custom color and style for the question parts. You can\n               configure colors as well as font types for different elements.\n\n        only_directories: Only show directories in auto completion. This option\n                          does not do anything if a custom ``completer`` is\n                          passed.\n\n        get_paths: Set a callable to generate paths to traverse for suggestions. This option\n                   does not do anything if a custom ``completer`` is\n                   passed.\n\n        file_filter: Optional callable to filter suggested paths. Only paths\n                     where the passed callable evaluates to ``True`` will show up in\n                     the suggested paths. This does not validate the typed path, e.g.\n                     it is still possible for the user to enter a path manually, even\n                     though this filter evaluates to ``False``. If in addition to\n                     filtering suggestions you also want to validate the result, use\n                     ``validate`` in combination with the ``file_filter``.\n\n    Returns:\n        [Question](): Question instance, ready to be prompted (using ``.ask()``).\n    \"\"\"  # noqa: W505, E501\n    merged_style = merge_styles_default([style])\n\n    def get_prompt_tokens() -&gt; List[Tuple[str, str]]:\n        tokens = []\n\n        if qcount is not None:\n            tokens.append((\"class:qcount\", \"{} \".format(qcount)))\n        if isinstance(qmark, list):\n            for x in qmark:\n                tokens.append((x[0], \"{}\".format(x[1])))\n            tokens.append((\"class:qmark\", \" {}\".format(\"\")))\n        elif isinstance(qmark, str) and len(qmark.strip()) &gt; 0:\n            tokens.append((\"class:qmark\", \"{} \".format(qmark)))\n        if isinstance(message, list):\n            for x in message:\n                tokens.append((x[0], \"{}\".format(x[1])))\n        elif isinstance(message, str) and len(message.strip()) &gt; 0:\n            tokens.append((\"class:question\", \"{}\".format(message)))\n        tokens.append((\"class:question\", \" {}\".format(\"\\n\")))\n        return tokens\n\n    validator = build_validator(validate)\n\n    completer = completer or GreatUXPathCompleter(\n        get_paths=get_paths,\n        only_directories=only_directories,\n        file_filter=file_filter,\n        expanduser=True,\n    )\n\n    bindings = KeyBindings()\n\n    @bindings.add(Keys.ControlM, eager=True)\n    def set_answer(event: KeyPressEvent):\n        if event.current_buffer.complete_state is not None:\n            event.current_buffer.complete_state = None\n        elif event.app.current_buffer.validate(set_cursor=True):\n            # When the validation succeeded, accept the input.\n            result_path = event.app.current_buffer.document.text\n            if result_path.endswith(os.path.sep):\n                result_path = result_path[:-1]\n\n            event.app.exit(result=result_path)\n            event.app.current_buffer.append_to_history()\n\n    @bindings.add(os.path.sep, eager=True)\n    def next_segment(event: KeyPressEvent):\n        b = event.app.current_buffer\n\n        if b.complete_state:\n            b.complete_state = None\n\n        current_path = b.document.text\n        if not current_path.endswith(os.path.sep):\n            b.insert_text(os.path.sep)\n\n        b.start_completion(select_first=False)\n\n    p: PromptSession = PromptSession(\n        get_prompt_tokens,\n        lexer=SimpleLexer(\"class:answer\"),\n        style=merged_style,\n        completer=completer,\n        validator=validator,\n        complete_style=complete_style,\n        key_bindings=bindings,\n        **kwargs,\n    )\n    p.default_buffer.reset(Document(default))\n\n    return Question(p.app)\n</code></pre>"},{"location":"reference/questionary/prompts/press_any_key_to_continue/","title":"press_any_key_to_continue.py","text":""},{"location":"reference/questionary/prompts/press_any_key_to_continue/#krupy.questionary.prompts.press_any_key_to_continue.press_any_key_to_continue","title":"<code>press_any_key_to_continue(message, style=None, qmark='?', qcount=None, **kwargs)</code>","text":"<p>Wait until user presses any key to continue.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import questionary\n&gt;&gt;&gt; questionary.press_any_key_to_continue().ask()\n Press any key to continue...\n''\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question text. Defaults to <code>\"Press any key to continue...\"</code></p> required <code>style</code> <code>Optional[prompt_toolkit.styles.style.Style]</code> <p>A custom color and style for the question parts. You can    configure colors as well as font types for different elements.</p> <code>None</code> <p>Returns:</p> Type Description <code>[Question]()</code> <p>Question instance, ready to be prompted (using <code>.ask()</code>).</p> Source code in <code>krupy/questionary/prompts/press_any_key_to_continue.py</code> <pre><code>def press_any_key_to_continue(\n    message: AnyFormattedText,\n    style: Optional[Style] = None,\n    qmark: AnyFormattedText = DEFAULT_QUESTION_PREFIX,\n    qcount: Optional[str] = None,\n    **kwargs: Any,\n):\n    \"\"\"Wait until user presses any key to continue.\n\n    Example:\n        &gt;&gt;&gt; import questionary\n        &gt;&gt;&gt; questionary.press_any_key_to_continue().ask()\n         Press any key to continue...\n        ''\n\n    Args:\n        message: Question text. Defaults to ``\"Press any key to continue...\"``\n\n        style: A custom color and style for the question parts. You can\n               configure colors as well as font types for different elements.\n\n    Returns:\n        [Question](): Question instance, ready to be prompted (using ``.ask()``).\n    \"\"\"\n    merged_style = merge_styles_default([style])\n\n    if message is None and help is None:\n        message = \"Press any key to continue...\"\n\n    def get_prompt_tokens():\n        tokens = []\n\n        if qcount is not None:\n            tokens.append((\"class:qcount\", \"{} \".format(qcount)))\n        if isinstance(qmark, list):\n            for x in qmark:\n                tokens.append((x[0], \"{}\".format(x[1])))\n            tokens.append((\"class:qmark\", \" {}\".format(\"\")))\n        elif isinstance(qmark, str) and len(qmark.strip()) &gt; 0:\n            tokens.append((\"class:qmark\", \"{} \".format(qmark)))\n        if isinstance(message, list):\n            for x in message:\n                tokens.append((x[0], \"{}\".format(x[1])))\n        elif isinstance(message, str) and len(message.strip()) &gt; 0:\n            tokens.append((\"class:question\", \"{}\".format(message)))\n        tokens.append((\"class:question\", \" {}\".format(\"\\n\")))\n\n        return to_formatted_text(tokens)\n\n    def exit_with_result(event):\n        event.app.exit(result=None)\n\n    bindings = KeyBindings()\n\n    @bindings.add(Keys.Any)\n    def any_key(event):\n        exit_with_result(event)\n\n    return Question(\n        PromptSession(\n            get_prompt_tokens, key_bindings=bindings, style=merged_style, **kwargs\n        ).app\n    )\n</code></pre>"},{"location":"reference/questionary/prompts/rawselect/","title":"rawselect.py","text":""},{"location":"reference/questionary/prompts/rawselect/#krupy.questionary.prompts.rawselect.rawselect","title":"<code>rawselect(message, choices, default=None, qmark='?', pointer='\u00bb', style=None, qcount=None, **kwargs)</code>","text":"<p>Ask the user to select one item from a list of choices using shortcuts.</p> <p>The user can only select one option.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import questionary\n&gt;&gt;&gt; questionary.rawselect(\n...     \"What do you want to do?\",\n...     choices=[\n...         \"Order a pizza\",\n...         \"Make a reservation\",\n...         \"Ask for opening hours\"\n...     ]).ask()\n? What do you want to do? Order a pizza\n'Order a pizza'\n</code></pre> <p></p> <p>This is just a really basic example, the prompt can be customised using the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question text.</p> required <code>choices</code> <code>Sequence[Union[str, krupy.questionary.prompts.common.Choice, Dict[str, Any]]]</code> <p>Items shown in the selection, this can contain Choice or      or Separator objects or simple items as strings. Passing      Choice objects, allows you to configure the item more      (e.g. preselecting it or disabling it).</p> required <code>default</code> <code>Optional[str]</code> <p>Default return value (single value).</p> <code>None</code> <code>qmark</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question prefix displayed in front of the question.    By default this is a <code>?</code>.</p> <code>'?'</code> <code>pointer</code> <code>Optional[str]</code> <p>Pointer symbol in front of the currently highlighted element.      By default this is a <code>\u00bb</code>.      Use <code>None</code> to disable it.</p> <code>'\u00bb'</code> <code>style</code> <code>Optional[prompt_toolkit.styles.style.Style]</code> <p>A custom color and style for the question parts. You can    configure colors as well as font types for different elements.</p> <code>None</code> <p>Returns:</p> Type Description <code>[Question]()</code> <p>Question instance, ready to be prompted (using <code>.ask()</code>).</p> Source code in <code>krupy/questionary/prompts/rawselect.py</code> <pre><code>def rawselect(\n    message: AnyFormattedText,\n    choices: Sequence[Union[str, Choice, Dict[str, Any]]],\n    default: Optional[str] = None,\n    qmark: AnyFormattedText = DEFAULT_QUESTION_PREFIX,\n    pointer: Optional[str] = DEFAULT_SELECTED_POINTER,\n    style: Optional[Style] = None,\n    qcount: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Question:\n    \"\"\"Ask the user to select one item from a list of choices using shortcuts.\n\n    The user can only select one option.\n\n    Example:\n        &gt;&gt;&gt; import questionary\n        &gt;&gt;&gt; questionary.rawselect(\n        ...     \"What do you want to do?\",\n        ...     choices=[\n        ...         \"Order a pizza\",\n        ...         \"Make a reservation\",\n        ...         \"Ask for opening hours\"\n        ...     ]).ask()\n        ? What do you want to do? Order a pizza\n        'Order a pizza'\n\n    &lt;img alt=\"../../../../images/rawselect.gif\" src=\"../../../../images/rawselect.gif\"&gt;\n\n    This is just a really basic example, the prompt can be customised using the\n    parameters.\n\n    Args:\n        message: Question text.\n\n        choices: Items shown in the selection, this can contain [Choice]() or\n                 or [Separator]() objects or simple items as strings. Passing\n                 [Choice]() objects, allows you to configure the item more\n                 (e.g. preselecting it or disabling it).\n\n        default: Default return value (single value).\n\n        qmark: Question prefix displayed in front of the question.\n               By default this is a ``?``.\n\n        pointer: Pointer symbol in front of the currently highlighted element.\n                 By default this is a ``\u00bb``.\n                 Use ``None`` to disable it.\n\n        style: A custom color and style for the question parts. You can\n               configure colors as well as font types for different elements.\n\n    Returns:\n        [Question](): Question instance, ready to be prompted (using ``.ask()``).\n    \"\"\"\n    return select.select(\n        message,\n        choices,\n        default,\n        qmark,\n        pointer,\n        style,\n        qcount,\n        use_shortcuts=True,\n        use_arrow_keys=False,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/questionary/prompts/select/","title":"select.py","text":""},{"location":"reference/questionary/prompts/select/#krupy.questionary.prompts.select.select","title":"<code>select(message, choices, default=None, qmark='?', pointer='\u00bb', style=None, qcount=None, use_shortcuts=False, use_arrow_keys=True, use_indicator=False, use_jk_keys=True, use_emacs_keys=True, show_selected=False, instruction=None, **kwargs)</code>","text":"<p>A list of items to select one option from.</p> <p>The user can pick one option and confirm it (if you want to allow the user to select multiple options, use questionary.checkbox instead).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import questionary\n&gt;&gt;&gt; questionary.select(\n...     \"What do you want to do?\",\n...     choices=[\n...         \"Order a pizza\",\n...         \"Make a reservation\",\n...         \"Ask for opening hours\"\n...     ]).ask()\n? What do you want to do? Order a pizza\n'Order a pizza'\n</code></pre> <p></p> <p>This is just a really basic example, the prompt can be customised using the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question text</p> required <code>choices</code> <code>Sequence[Union[str, krupy.questionary.prompts.common.Choice, Dict[str, Any]]]</code> <p>Items shown in the selection, this can contain Choice or      or Separator objects or simple items as strings. Passing      Choice objects, allows you to configure the item more      (e.g. preselecting it or disabling it).</p> required <code>default</code> <code>Union[str, krupy.questionary.prompts.common.Choice, Dict[str, Any]]</code> <p>A value corresponding to a selectable item in the choices,      to initially set the pointer position to.</p> <code>None</code> <code>qmark</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question prefix displayed in front of the question.    By default this is a <code>?</code>.</p> <code>'?'</code> <code>pointer</code> <code>Optional[str]</code> <p>Pointer symbol in front of the currently highlighted element.      By default this is a <code>\u00bb</code>.      Use <code>None</code> to disable it.</p> <code>'\u00bb'</code> <code>instruction</code> <code>Optional[str]</code> <p>A hint on how to navigate the menu.          It's <code>(Use shortcuts)</code> if only <code>use_shortcuts</code> is set          to True, <code>(Use arrow keys or shortcuts)</code> if <code>use_arrow_keys</code>          &amp; <code>use_shortcuts</code> are set and <code>(Use arrow keys)</code> by default.</p> <code>None</code> <code>style</code> <code>Optional[prompt_toolkit.styles.style.Style]</code> <p>A custom color and style for the question parts. You can    configure colors as well as font types for different elements.</p> <code>None</code> <code>use_indicator</code> <code>bool</code> <p>Flag to enable the small indicator in front of the            list highlighting the current location of the selection            cursor.</p> <code>False</code> <code>use_shortcuts</code> <code>bool</code> <p>Allow the user to select items from the list using            shortcuts. The shortcuts will be displayed in front of            the list items. Arrow keys, j/k keys and shortcuts are            not mutually exclusive.</p> <code>False</code> <code>use_arrow_keys</code> <code>bool</code> <p>Allow the user to select items from the list using             arrow keys. Arrow keys, j/k keys and shortcuts are not             mutually exclusive.</p> <code>True</code> <code>use_jk_keys</code> <code>bool</code> <p>Allow the user to select items from the list using          <code>j</code> (down) and <code>k</code> (up) keys. Arrow keys, j/k keys and          shortcuts are not mutually exclusive.</p> <code>True</code> <code>use_emacs_keys</code> <code>bool</code> <p>Allow the user to select items from the list using             <code>Ctrl+N</code> (down) and <code>Ctrl+P</code> (up) keys. Arrow keys, j/k keys,             emacs keys and shortcuts are not mutually exclusive.</p> <code>True</code> <code>show_selected</code> <code>bool</code> <p>Display current selection choice at the bottom of list.</p> <code>False</code> <p>Returns:</p> Type Description <code>[Question]()</code> <p>Question instance, ready to be prompted (using <code>.ask()</code>).</p> Source code in <code>krupy/questionary/prompts/select.py</code> <pre><code>def select(\n    message: AnyFormattedText,\n    choices: Sequence[Union[str, Choice, Dict[str, Any]]],\n    default: Optional[Union[str, Choice, Dict[str, Any]]] = None,\n    qmark: AnyFormattedText = DEFAULT_QUESTION_PREFIX,\n    pointer: Optional[str] = DEFAULT_SELECTED_POINTER,\n    style: Optional[Style] = None,\n    qcount: Optional[str] = None,\n    use_shortcuts: bool = False,\n    use_arrow_keys: bool = True,\n    use_indicator: bool = False,\n    use_jk_keys: bool = True,\n    use_emacs_keys: bool = True,\n    show_selected: bool = False,\n    instruction: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Question:\n    \"\"\"A list of items to select **one** option from.\n\n    The user can pick one option and confirm it (if you want to allow\n    the user to select multiple options, use [questionary.checkbox]() instead).\n\n    Example:\n        &gt;&gt;&gt; import questionary\n        &gt;&gt;&gt; questionary.select(\n        ...     \"What do you want to do?\",\n        ...     choices=[\n        ...         \"Order a pizza\",\n        ...         \"Make a reservation\",\n        ...         \"Ask for opening hours\"\n        ...     ]).ask()\n        ? What do you want to do? Order a pizza\n        'Order a pizza'\n\n    &lt;img alt=\"../../../../images/select.gif\" src=\"../../../../images/select.gif\"&gt;\n\n    This is just a really basic example, the prompt can be customised using the\n    parameters.\n\n\n    Args:\n        message: Question text\n\n        choices: Items shown in the selection, this can contain [Choice]() or\n                 or [Separator]() objects or simple items as strings. Passing\n                 [Choice]() objects, allows you to configure the item more\n                 (e.g. preselecting it or disabling it).\n\n        default: A value corresponding to a selectable item in the choices,\n                 to initially set the pointer position to.\n\n        qmark: Question prefix displayed in front of the question.\n               By default this is a ``?``.\n\n        pointer: Pointer symbol in front of the currently highlighted element.\n                 By default this is a ``\u00bb``.\n                 Use ``None`` to disable it.\n\n        instruction: A hint on how to navigate the menu.\n                     It's ``(Use shortcuts)`` if only ``use_shortcuts`` is set\n                     to True, ``(Use arrow keys or shortcuts)`` if ``use_arrow_keys``\n                     &amp; ``use_shortcuts`` are set and ``(Use arrow keys)`` by default.\n\n        style: A custom color and style for the question parts. You can\n               configure colors as well as font types for different elements.\n\n        use_indicator: Flag to enable the small indicator in front of the\n                       list highlighting the current location of the selection\n                       cursor.\n\n        use_shortcuts: Allow the user to select items from the list using\n                       shortcuts. The shortcuts will be displayed in front of\n                       the list items. Arrow keys, j/k keys and shortcuts are\n                       not mutually exclusive.\n\n        use_arrow_keys: Allow the user to select items from the list using\n                        arrow keys. Arrow keys, j/k keys and shortcuts are not\n                        mutually exclusive.\n\n        use_jk_keys: Allow the user to select items from the list using\n                     `j` (down) and `k` (up) keys. Arrow keys, j/k keys and\n                     shortcuts are not mutually exclusive.\n\n        use_emacs_keys: Allow the user to select items from the list using\n                        `Ctrl+N` (down) and `Ctrl+P` (up) keys. Arrow keys, j/k keys,\n                        emacs keys and shortcuts are not mutually exclusive.\n\n        show_selected: Display current selection choice at the bottom of list.\n\n    Returns:\n        [Question](): Question instance, ready to be prompted (using ``.ask()``).\n    \"\"\"\n    if not (use_arrow_keys or use_shortcuts or use_jk_keys or use_emacs_keys):\n        raise ValueError(\n            (\n                \"Some option to move the selection is required. \"\n                \"Arrow keys, j/k keys, emacs keys, or shortcuts.\"\n            )\n        )\n\n    if use_shortcuts and use_jk_keys:\n        if any(getattr(c, \"shortcut_key\", \"\") in [\"j\", \"k\"] for c in choices):\n            raise ValueError(\n                \"A choice is trying to register j/k as a \"\n                \"shortcut key when they are in use as arrow keys \"\n                \"disable one or the other.\"\n            )\n\n    if choices is None or len(choices) == 0:\n        raise ValueError(\"A list of choices needs to be provided.\")\n\n    if use_shortcuts and len(choices) &gt; len(InquirerControl.SHORTCUT_KEYS):\n        raise ValueError(\n            \"A list with shortcuts supports a maximum of {} \"\n            \"choices as this is the maximum number \"\n            \"of keyboard shortcuts that are available. You\"\n            \"provided {} choices!\"\n            \"\".format(len(InquirerControl.SHORTCUT_KEYS), len(choices))\n        )\n\n    merged_style = merge_styles_default([style])\n\n    ic = InquirerControl(\n        choices,\n        default,\n        pointer=pointer,\n        use_indicator=use_indicator,\n        use_shortcuts=use_shortcuts,\n        show_selected=show_selected,\n        use_arrow_keys=use_arrow_keys,\n        initial_choice=default,\n    )\n\n    def get_prompt_tokens():\n        # noinspection PyListCreation\n        tokens = []\n\n        if qcount is not None:\n            tokens.append((\"class:qcount\", \"{} \".format(qcount)))\n        if isinstance(qmark, list):\n            for x in qmark:\n                tokens.append((x[0], \"{}\".format(x[1])))\n            tokens.append((\"class:qmark\", \" {}\".format(\"\")))\n        elif isinstance(qmark, str) and len(qmark.strip()) &gt; 0:\n            tokens.append((\"class:qmark\", \"{} \".format(qmark)))\n        if isinstance(message, list):\n            for x in message:\n                tokens.append((x[0], \"{}\".format(x[1])))\n        elif isinstance(message, str) and len(message.strip()) &gt; 0:\n            tokens.append((\"class:question\", \"{}\".format(message)))\n        tokens.append((\"class:question\", \" {}\".format(\"\\n\")))\n\n        if ic.is_answered:\n            if isinstance(ic.get_pointed_at().title, list):\n                tokens.append(\n                    (\n                        \"class:answer\",\n                        \"\".join([token[1] for token in ic.get_pointed_at().title]),\n                    )\n                )\n            else:\n                tokens.append((\"class:answer\", ic.get_pointed_at().title))\n        else:\n            if instruction:\n                tokens.append((\"class:instruction\", instruction))\n            else:\n                if use_shortcuts and use_arrow_keys:\n                    instruction_msg = \"(Use shortcuts or arrow keys)\"\n                elif use_shortcuts and not use_arrow_keys:\n                    instruction_msg = \"(Use shortcuts)\"\n                else:\n                    instruction_msg = \"(Use arrow keys)\"\n                tokens.append((\"class:instruction\", instruction_msg))\n\n        return tokens\n\n    layout = common.create_inquirer_layout(ic, get_prompt_tokens, **kwargs)\n\n    bindings = KeyBindings()\n\n    @bindings.add(Keys.ControlQ, eager=True)\n    @bindings.add(Keys.ControlC, eager=True)\n    def _(event):\n        event.app.exit(exception=KeyboardInterrupt, style=\"class:aborting\")\n\n    if use_shortcuts:\n        # add key bindings for choices\n        for i, c in enumerate(ic.choices):\n            if c.shortcut_key is None and not c.disabled and not use_arrow_keys:\n                raise RuntimeError(\n                    \"{} does not have a shortcut and arrow keys \"\n                    \"for movement are disabled. \"\n                    \"This choice is not reachable.\".format(c.title)\n                )\n            if isinstance(c, Separator) or c.shortcut_key is None:\n                continue\n\n            # noinspection PyShadowingNames\n            def _reg_binding(i, keys):\n                # trick out late evaluation with a \"function factory\":\n                # https://stackoverflow.com/a/3431699\n                @bindings.add(keys, eager=True)\n                def select_choice(event):\n                    ic.pointed_at = i\n\n            _reg_binding(i, c.shortcut_key)\n\n    def move_cursor_down(event):\n        ic.select_next()\n        while not ic.is_selection_valid():\n            ic.select_next()\n\n    def move_cursor_up(event):\n        ic.select_previous()\n        while not ic.is_selection_valid():\n            ic.select_previous()\n\n    if use_arrow_keys:\n        bindings.add(Keys.Down, eager=True)(move_cursor_down)\n        bindings.add(Keys.Up, eager=True)(move_cursor_up)\n\n    if use_jk_keys:\n        bindings.add(\"j\", eager=True)(move_cursor_down)\n        bindings.add(\"k\", eager=True)(move_cursor_up)\n\n    if use_emacs_keys:\n        bindings.add(Keys.ControlN, eager=True)(move_cursor_down)\n        bindings.add(Keys.ControlP, eager=True)(move_cursor_up)\n\n    @bindings.add(Keys.ControlM, eager=True)\n    def set_answer(event):\n        ic.is_answered = True\n        event.app.exit(result=ic.get_pointed_at().value)\n\n    @bindings.add(Keys.Any)\n    def other(event):\n        \"\"\"Disallow inserting other text.\"\"\"\n\n    return Question(\n        Application(\n            layout=layout,\n            key_bindings=bindings,\n            style=merged_style,\n            **utils.used_kwargs(kwargs, Application.__init__),\n        )\n    )\n</code></pre>"},{"location":"reference/questionary/prompts/text/","title":"text.py","text":""},{"location":"reference/questionary/prompts/text/#krupy.questionary.prompts.text.text","title":"<code>text(message, default='', validate=None, qmark='?', style=None, qcount=None, multiline=False, instruction=None, lexer=None, **kwargs)</code>","text":"<p>Prompt the user to enter a free text message.</p> <p>This question type can be used to prompt the user for some text input.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import questionary\n&gt;&gt;&gt; questionary.text(\"What's your first name?\").ask()\n? What's your first name? Tom\n'Tom'\n</code></pre> <p></p> <p>This is just a really basic example, the prompt can be customised using the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question text.</p> required <code>default</code> <code>str</code> <p>Default value will be returned if the user just hits      enter.</p> <code>''</code> <code>validate</code> <code>Any</code> <p>Require the entered value to pass a validation. The       value can not be submitted until the validator accepts       it (e.g. to check minimum password length).</p> <pre><code>  This can either be a function accepting the input and\n  returning a boolean, or an class reference to a\n  subclass of the prompt toolkit Validator class.\n</code></pre> <code>None</code> <code>qmark</code> <code>Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], NoneType]]]]</code> <p>Question prefix displayed in front of the question.    By default this is a <code>?</code>.</p> <code>'?'</code> <code>style</code> <code>Optional[prompt_toolkit.styles.style.Style]</code> <p>A custom color and style for the question parts. You can    configure colors as well as font types for different elements.</p> <code>None</code> <code>multiline</code> <code>bool</code> <p>If <code>True</code>, multiline input will be enabled.</p> <code>False</code> <code>instruction</code> <code>Optional[str]</code> <p>Write instructions for the user if needed. If <code>None</code>          and <code>multiline=True</code>, some instructions will appear.</p> <code>None</code> <code>lexer</code> <code>Optional[prompt_toolkit.lexers.base.Lexer]</code> <p>Supply a valid lexer to style the answer. Leave empty to    use a simple one by default.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Additional arguments, they will be passed to prompt toolkit.</p> <code>{}</code> <p>Returns:</p> Type Description <code>[Question]()</code> <p>Question instance, ready to be prompted (using <code>.ask()</code>).</p> Source code in <code>krupy/questionary/prompts/text.py</code> <pre><code>def text(\n    message: AnyFormattedText,\n    default: str = \"\",\n    validate: Any = None,\n    qmark: AnyFormattedText = DEFAULT_QUESTION_PREFIX,\n    style: Optional[Style] = None,\n    qcount: Optional[str] = None,\n    multiline: bool = False,\n    instruction: Optional[str] = None,\n    lexer: Optional[Lexer] = None,\n    **kwargs: Any,\n) -&gt; Question:\n    \"\"\"Prompt the user to enter a free text message.\n\n    This question type can be used to prompt the user for some text input.\n\n    Example:\n        &gt;&gt;&gt; import questionary\n        &gt;&gt;&gt; questionary.text(\"What's your first name?\").ask()\n        ? What's your first name? Tom\n        'Tom'\n\n    &lt;img alt=\"../../../../images/text.gif\" src=\"../../../../images/text.gif\"&gt;\n\n    This is just a really basic example, the prompt can be customised using the\n    parameters.\n\n    Args:\n        message: Question text.\n\n        default: Default value will be returned if the user just hits\n                 enter.\n\n        validate: Require the entered value to pass a validation. The\n                  value can not be submitted until the validator accepts\n                  it (e.g. to check minimum password length).\n\n                  This can either be a function accepting the input and\n                  returning a boolean, or an class reference to a\n                  subclass of the prompt toolkit Validator class.\n\n        qmark: Question prefix displayed in front of the question.\n               By default this is a ``?``.\n\n        style: A custom color and style for the question parts. You can\n               configure colors as well as font types for different elements.\n\n        multiline: If ``True``, multiline input will be enabled.\n\n        instruction: Write instructions for the user if needed. If ``None``\n                     and ``multiline=True``, some instructions will appear.\n\n        lexer: Supply a valid lexer to style the answer. Leave empty to\n               use a simple one by default.\n\n        kwargs: Additional arguments, they will be passed to prompt toolkit.\n\n    Returns:\n        [Question](): Question instance, ready to be prompted (using ``.ask()``).\n    \"\"\"\n    merged_style = merge_styles_default([style])\n    lexer = lexer or SimpleLexer(\"class:answer\")\n    validator = build_validator(validate)\n\n    if instruction is None and multiline:\n        instruction = INSTRUCTION_MULTILINE\n\n    def get_prompt_tokens() -&gt; List[Tuple[str, str]]:\n        tokens = []\n\n        if qcount is not None:\n            tokens.append((\"class:qcount\", \"{} \".format(qcount)))\n        if isinstance(qmark, list):\n            for x in qmark:\n                tokens.append((x[0], \"{}\".format(x[1])))\n            tokens.append((\"class:qmark\", \" {}\".format(\"\")))\n        elif isinstance(qmark, str) and len(qmark.strip()) &gt; 0:\n            tokens.append((\"class:qmark\", \"{} \".format(qmark)))\n        if isinstance(message, list):\n            for x in message:\n                tokens.append((x[0], \"{}\".format(x[1])))\n        elif isinstance(message, str) and len(message.strip()) &gt; 0:\n            tokens.append((\"class:question\", \"{}\".format(message)))\n        tokens.append((\"class:question\", \" {}\".format(\"\\n\")))\n\n        if instruction:\n            tokens.append((\"class:instruction\", \" {} \".format(instruction)))\n        return tokens\n\n    p: PromptSession = PromptSession(\n        get_prompt_tokens,\n        style=merged_style,\n        validator=validator,\n        lexer=lexer,\n        multiline=multiline,\n        **kwargs,\n    )\n    p.default_buffer.reset(Document(default))\n\n    return Question(p.app)\n</code></pre>"}]}